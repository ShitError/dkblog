/*
 Navicat Premium Data Transfer

 Source Server         : www.jishudaniu.com
 Source Server Type    : MySQL
 Source Server Version : 80028
 Source Host           : 121.40.238.163:3306
 Source Schema         : dkblog

 Target Server Type    : MySQL
 Target Server Version : 80028
 File Encoding         : 65001

 Date: 01/04/2022 03:38:41
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_article
-- ----------------------------
DROP TABLE IF EXISTS `t_article`;
CREATE TABLE `t_article`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL COMMENT '作者',
  `category_id` int NULL DEFAULT NULL COMMENT '文章分类',
  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章缩略图',
  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标题',
  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '内容',
  `type` tinyint(1) NOT NULL DEFAULT 0 COMMENT '文章类型 1原创 2转载 3翻译',
  `original_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '原文链接',
  `is_top` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否置顶 0否 1是',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除  0否 1是',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态值 1公开 2私密 3评论可见',
  `create_time` datetime NOT NULL COMMENT '发表时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  FULLTEXT INDEX `ft_search`(`article_content`)
) ENGINE = InnoDB AUTO_INCREMENT = 61 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article
-- ----------------------------
INSERT INTO `t_article` VALUES (53, 1, 333, 'https://static.jishudaniu.com/articles/85eee7640539ffe9441828c685acf567.jpg', 'nginx基本使用', '# 1. 常用命令\n\n以下命令nginx已经通过apt安装好了，有nginx命令。\n\n## 1. 查看版本\n\n```shell\nnginx -v\n```\n\n如果你想同时看到更详细的配置项，使用 -V\n\n```shell\nnginx -V\n```\n\n## 2. 查看 Nginx 配置语法的正确性\n\n```shell\nsudo nginx -t\n```\n\n这里如果用大写 T，效果就是 测试、丢弃并退出\n\n```shell\nsudo nginx -T\n```\n\n## 3. 为Nginx指定一个配置文件\n\n```shell\nnginx -c </path/config> #为Nginx指定一个配置文件，来代替缺省值conf/nginx.conf\n```\n\n## 4. 启动 Nginx 服务\n\n```shell\nsudo systemctl start nginx #systemd\nOR\nsudo service nginx start   #sysvinit\n```\n\n## 5. 开机自启动\n\n```shell\nsudo systemctl enable nginx #systemd\n或\nsudo service nginx enable   #sysv init\n```\n\n## 6. 重启 Nginx 服务\n\n重启的意思是，停止 然后 启动\n\n```shell\nsudo systemctl restart nginx #systemd\n或\nsudo service nginx restart   #sysv init\n```\n\n## 7. 查看 Nginx 服务状态\n\n这条是看运行时的服务状态信息的。\n\n```shell\nsudo systemctl status nginx #systemd\n或\nsudo service nginx status   #sysvinit\n```\n\n## 8. 重载 Nginx 服务\n\n重载是重新加载 配置文件，看命令：\n\n```shell\nsudo systemctl reload nginx #systemd\n或\nsudo service nginx reload   #sysvinit\n```\n\n## 9. 停止 Nginx 服务\n\n不管你是什么原因想停了它，都可以用：\n\n```shell\nsudo systemctl stop nginx #systemd\nOR\nsudo service nginx stop   #sysvinit\n```\n\n## 10. 查看命令帮助\n\n如果还有什么不懂，或者想知道其他命令，就用这个\n\n```shell\nsystemctl -h nginx\n```\n\n# 2. 配置文件\n\nnginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改\n\n![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132450.png)\n\n## 第一部分：全局块 \n\n从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\n\n比如上面第一行配置的：\n\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132657.png)\n\n这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约\n\n##  第二部分：events 块\n\nevents 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。\n\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132920.png)\n\n上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\n\n## 第三部分：http 块\n\n这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\n\n需要注意的是：http 块也可以包括 **http** **全局块**、**server** **块**。\n\n### 1. http全局块\n\nhttp 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\n\n**upstream**（上游服务器设置，主要为反向代理、负载均衡相关配置，upstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡\n\n### 2. server块\n\n这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。\n\n每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。\n\n而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。\n\n#### 1.全局 server 块\n\n最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。\n\n#### 2. location块\n\n一个 server 块可以配置多个 location 块。\n\n这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。\n\n## nginx.conf 详细的配置文件介绍\n\n```properties\n#定义Nginx运行的用户和用户组\nuser www www; \n\n#nginx进程数，通常设置成和cpu的数量相等\nworker_processes 4; \n\n#全局错误日志定义类型，[debug | info | notice | warn | error | crit]\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n\n#进程pid文件\n#pid        logs/nginx.pid;\n\n\n#指定进程可以打开的最大描述符：数目\n#工作模式与连接数上限\n##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\nworker_rlimit_nofile 65535;\n\n\nevents {\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\n    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。\n    #补充说明：\n    #与apache相类，nginx针对不同的操作系统，有不同的事件模型\n    #A）标准事件模型\n    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll\n    #B）高效事件模型\n    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。\n    #Epoll：使用于Linux内核2.6版本及以后的系统。\n    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。\n    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。\n    use epoll\n    \n    \n    #单个进程最大连接数（最大连接数=连接数+进程数）\n    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。\n    worker_connections  1024;\n    \n    #keepalive 超时时间\n    keepalive_timeout 60;\n    \n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。\n    #分页大小可以用命令getconf PAGESIZE 取得。\n    #[root@web001 ~]# getconf PAGESIZE\n    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。\n    client_header_buffer_size 4k;\n    \n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\n    open_file_cache max=65535 inactive=60s;\n    \n    \n    #这个是指多长时间检查一次缓存的有效信息。\n    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.\n    open_file_cache_valid 80s;\n    \n    \n    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\n    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.\n    open_file_cache_min_uses 1;\n    \n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.\n    open_file_cache_errors on;\n}\n\n\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp{\n    #文件扩展名与文件类型映射表\n    include mime.types;\n    \n    #默认文件类型\n    default_type application/octet-stream;\n    \n    #默认编码\n    charset utf-8;\n    \n    #服务器名字的hash表大小\n    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.\n    server_names_hash_bucket_size 128;\n    \n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\n    client_header_buffer_size 32k;\n    \n    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。\n    large_client_header_buffers 4 64k;\n    \n    #设定通过nginx上传文件的大小\n    client_max_body_size 8m;\n    \n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。\n    sendfile on;\n    \n     #开启目录列表访问，合适下载服务器，默认关闭。\n    autoindex on;\n    \n      #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\n    tcp_nopush on;\n     \n    tcp_nodelay on;\n    \n    #长连接超时时间，单位是秒\n    keepalive_timeout 120;\n    \n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\n    fastcgi_connect_timeout 300;\n    fastcgi_send_timeout 300;\n    fastcgi_read_timeout 300;\n    fastcgi_buffer_size 64k;\n    fastcgi_buffers 4 64k;\n    fastcgi_busy_buffers_size 128k;\n    fastcgi_temp_file_write_size 128k;\n    \n    #gzip模块设置\n    gzip on; #开启gzip压缩输出\n    gzip_min_length 1k;    #最小压缩文件大小\n    gzip_buffers 4 16k;    #压缩缓冲区\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n    gzip_comp_level 2;     #压缩等级\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\n    gzip_vary on;\n\n    #开启限制IP连接数的时候需要使用\n    #limit_zone crawler $binary_remote_addr 10m;\n    \n    \n    #负载均衡配置\n    upstream piao.jd.com {\n     \n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\n        server 192.168.80.121:80 weight=3;\n        server 192.168.80.122:80 weight=2;\n        server 192.168.80.123:80 weight=3;\n\n        #nginx的upstream目前支持4种方式的分配\n        #1、轮询（默认）\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n        #2、weight\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n        #例如：\n        #upstream bakend {\n        #    server 192.168.0.14 weight=10;\n        #    server 192.168.0.15 weight=10;\n        #}\n        #2、ip_hash\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n        #例如：\n        #upstream bakend {\n        #    ip_hash;\n        #    server 192.168.0.14:88;\n        #    server 192.168.0.15:80;\n        #}\n        #3、fair（第三方）\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n        #upstream backend {\n        #    server server1;\n        #    server server2;\n        #    fair;\n        #}\n        #4、url_hash（第三方）\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n        #upstream backend {\n        #    server squid1:3128;\n        #    server squid2:3128;\n        #    hash $request_uri;\n        #    hash_method crc32;\n        #}\n\n        #tips:\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\n        #    ip_hash;\n        #    server 127.0.0.1:9090 down;\n        #    server 127.0.0.1:8080 weight=2;\n        #    server 127.0.0.1:6060;\n        #    server 127.0.0.1:7070 backup;\n        #}\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\n\n        #每个设备的状态设置为:\n        #1.down表示单前的server暂时不参与负载\n        #2.weight为weight越大，负载的权重就越大。\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\n    }\n    \n    \n    #虚拟主机的配置\n    server {\n        #监听端口\n        listen 80;\n\n        #域名可以有多个，用空格隔开\n        server_name www.jd.com jd.com;\n        #默认入口文件名称\n        index index.html index.htm index.php;\n        root /data/www/jd;\n\n        #对******进行负载均衡\n        location ~ .*.(php|php5)?$\n        {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            include fastcgi.conf;\n        }\n         \n        #图片缓存时间设置\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n            expires 10d;\n        }\n         \n        #JS和CSS缓存时间设置\n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n         \n        #日志格式设定\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\n        #$remote_user：用来记录客户端用户名称；\n        #$time_local： 用来记录访问时间与时区；\n        #$request： 用来记录请求的url与http协议；\n        #$status： 用来记录请求状态；成功是200，\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\n        #$http_referer：用来记录从那个页面链接访问过来的；\n        #$http_user_agent：记录客户浏览器的相关信息；\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\n        log_format access \'$remote_addr - $remote_user [$time_local] \"$request\" \'\n        \'$status $body_bytes_sent \"$http_referer\" \'\n        \'\"$http_user_agent\" $http_x_forwarded_for\';\n         \n        #定义本虚拟主机的访问日志\n        access_log  /usr/local/nginx/logs/host.access.log  main;\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\n         \n        #对 \"/connect-controller\" 启用反向代理\n        location /connect-controller {\n            proxy_pass http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n             \n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n             \n            #以下是一些反向代理的配置，可选。\n            proxy_set_header Host $host;\n\n            #允许客户端请求的最大单文件字节数\n            client_max_body_size 10m;\n\n            #缓冲区代理缓冲用户端请求的最大字节数，\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\n            client_body_buffer_size 128k;\n\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\n            proxy_intercept_errors on;\n\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\n            #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_connect_timeout 90;\n\n            #后端服务器数据回传时间(代理发送超时)\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\n            proxy_send_timeout 90;\n\n            #连接成功后，后端服务器响应时间(代理接收超时)\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\n            proxy_read_timeout 90;\n\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\n            proxy_buffer_size 4k;\n\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\n            proxy_buffers 4 32k;\n\n            #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_busy_buffers_size 64k;\n\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n            proxy_temp_file_write_size 64k;\n        }\n        \n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat或resin处理\n        location ~ .(jsp|jspx|do)?$ {\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        }\n    }\n}\n```\n\n## 总结\n\nNginx 配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置）。\n\nmain 部分设置的指令影响其他所有部分的设置；\n\nserver 部分的指令主要用于制定虚拟主机域名、IP 和端口号；\n\nupstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；\n\nlocation 部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。\n\n他们之间的关系：server 继承 main，location 继承 server；upstream 既不会继承指令也不会被继承。\n\n', 2, 'https://github.com/krislinzhao/StudyNotes', 0, 0, 1, '2021-12-28 16:18:55', '2022-03-07 01:38:16');
INSERT INTO `t_article` VALUES (54, 1, 333, 'https://static.jishudaniu.com/articles/495b49617f83556109b1dee076c22f31.jpg', 'Docker常用命令', '\n```shell\n\nattach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像\n\nbuild     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像\n\ncommit    Create a new image from a container changes   # 提交当前容器为新的镜像\n\ncp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中\n\ncreate    Create a new container                        # 创建一个新的容器，同 run，但不启动容器\n\ndiff      Inspect changes on a container\'s filesystem   # 查看 docker 容器变化\n\nevents    Get real time events from the server          # 从 docker 服务获取容器实时事件\n\nexec      Run a command in an existing container        # 在已存在的容器上运行命令\n\nexport    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\n\nhistory   Show the history of an image                  # 展示一个镜像形成历史\n\nimages    List images                                   # 列出系统当前镜像\n\nimport    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]\n\ninfo      Display system-wide information               # 显示系统相关信息\n\ninspect   Return low-level information on a container   # 查看容器详细信息\n\nkill      Kill a running container                      # kill 指定 docker 容器\n\nload      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]\n\nlogin     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器\n\nlogout    Log out from a Docker registry server          # 从当前 Docker registry 退出\n\nlogs      Fetch the logs of a container                 # 输出当前容器日志信息\n\nport      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口\n\npause     Pause all processes within a container        # 暂停容器\n\nps        List containers                               # 列出容器列表\n\npull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像\n\npush      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器\n\nrestart   Restart a running container                   # 重启运行的容器\n\nrm        Remove one or more containers                 # 移除一个或者多个容器\n\nrmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n\nrun       Run a command in a new container              # 创建一个新的容器并运行一个命令\n\nsave      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 \n\nload]\n\nsearch    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像\n\nstart     Start a stopped containers                    # 启动容器\n\nstop      Stop a running containers                     # 停止容器\n\ntag       Tag an image into a repository                # 给源中镜像打标签\n\ntop       Lookup the running processes of a container   # 查看容器中运行的进程信息\n\nunpause   Unpause a paused container                    # 取消暂停容器\n\nversion   Show the docker version information           # 查看 docker 版本号\n\nwait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值\n```', 1, '', 0, 0, 1, '2021-12-31 16:42:03', '2022-02-26 16:43:18');
INSERT INTO `t_article` VALUES (55, 1, 334, 'https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg', 'APlayer音乐播放器', '##### 1.首先在head中引入样式\n```html\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\">\n```\n##### 2.引入js文件\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\"></script>\n<!-- require MetingJS -->\n<script src=\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\"></script>\n```\n##### 3.下面帖代码\n```html\n<template>\n  <meting-js server=\"netease\"\n             type=\"playlist\"\n             id=\"7052482444\"\n             fixed=\"true\"\n             autoplay=\"true\"\n             loop=\"all\"\n             order=\"random\"\n             preload=\"auto\"\n             list-folded=\"ture\"\n             list-max-height=\"500px\"\n></meting-js>\n```\n左下角是效果', 1, '', 0, 0, 1, '2022-01-24 17:02:01', '2022-03-03 12:51:49');
INSERT INTO `t_article` VALUES (56, 1, 333, 'https://static.jishudaniu.com/articles/681d5410a7dda848709ac71f7d04ab63.jpg', '高校支付宝自动打卡', '前段时间在github上面的脚本挂了（ps：打卡接口屏蔽了国外ip）），想着能不能搬到linux上去。然后配上我的学生机就开始了。\n**打卡api：**\n```shell\nhttps://fxgl.jx.edu.cn/高校id/public/homeQd?loginName=学号id&loginType=0\n//把高校id和学号替换成自己的\n```\n| 学校名称                      | 学校标识码 | 所在地   |\n| ----------------------------- | ---------- | -------- |\n| 南昌大学                      | 4136010403 | 南昌市   |\n| 华东交通大学                  | 4136010404 | 南昌市   |\n| 东华理工大学                  | 4136010405 | 抚州市   |\n| 南昌航空大学                  | 4136010406 | 南昌市   |\n| 江西理工大学                  | 4136010407 | 赣州市   |\n| 景德镇陶瓷大学                | 4136010408 | 景德镇市 |\n| 江西农业大学                  | 4136010410 | 南昌市   |\n| 江西中医药大学                | 4136010412 | 南昌市   |\n| 赣南医学院                    | 4136010413 | 赣州市   |\n| 江西师范大学                  | 4136010414 | 南昌市   |\n| 上饶师范学院                  | 4136010416 | 上饶市   |\n| 宜春学院                      | 4136010417 | 宜春市   |\n| 赣南师范大学                  | 4136010418 | 赣州市   |\n| 井冈山大学                    | 4136010419 | 吉安市   |\n| 江西财经大学                  | 4136010421 | 南昌市   |\n| 江西科技学院                  | 4136010846 | 南昌市   |\n| 景德镇学院                    | 4136010894 | 景德镇市 |\n| 萍乡学院                      | 4136010895 | 萍乡市   |\n| 江西科技师范大学              | 4136011318 | 南昌市   |\n| 南昌工程学院                  | 4136011319 | 南昌市   |\n| 江西警察学院                  | 4136011504 | 南昌市   |\n| 新余学院                      | 4136011508 | 新余市   |\n| 九江学院                      | 4136011843 | 九江市   |\n| 江西工程学院                  | 4136012766 | 新余市   |\n| 南昌理工学院                  | 4136012795 | 南昌市   |\n| 江西应用科技学院              | 4136012938 | 南昌市   |\n| 江西服装学院                  | 4136013418 | 南昌市   |\n| 南昌工学院                    | 4136013421 | 南昌市   |\n| 南昌大学科学技术学院          | 4136013429 | 南昌市   |\n| 南昌大学共青学院              | 4136013430 | 九江市   |\n| 华东交通大学理工学院          | 4136013431 | 南昌市   |\n| 东华理工大学长江学院          | 4136013432 | 抚州市   |\n| 南昌航空大学科技学院          | 4136013433 | 南昌市   |\n| 江西理工大学应用科学学院      | 4136013434 | 赣州市   |\n| 景德镇陶瓷大学科技艺术学院    | 4136013435 | 景德镇市 |\n| 江西农业大学南昌商学院        | 4136013436 | 南昌市   |\n| 江西中医药大学科技学院        | 4136013437 | 南昌市   |\n| 江西师范大学科学技术学院      | 4136013438 | 南昌市   |\n| 赣南师范大学科技学院          | 4136013439 | 赣州市   |\n| 江西科技师范大学理工学院      | 4136013440 | 南昌市   |\n| 江西财经大学现代经济管理 学院 | 4136013441 | 南昌市   |\n| 豫章师范学院                  | 4136013774 | 南昌市   |\n| 南昌师范学院                  | 4136014437 | 南昌市   |\n| 上饶幼儿师范高等专科学校      | 3636000312 | 上饶市   |\n| 抚州幼儿师范高等专科学校      | 3636000519 | 抚州市   |\n| 江西工业职业技术学院          | 4136010839 | 南昌市   |\n| 江西医学高等专科学校          | 4136010888 | 上饶市   |\n| 九江职业大学                  | 4136011505 | 九江市   |\n| 九江职业技术学院              | 4136011785 | 九江市   |\n| 江西司法警官职业学院          | 4136012929 | 南昌市   |\n| 江西陶瓷工艺美术职业技术 学院 | 4136012930 | 景德镇市 |\n| 江西旅游商贸职业学院          | 4136012932 | 南昌市   |\n| 江西电力职业技术学院          | 4136012933 | 南昌市   |\n| 江西环境工程职业学院          | 4136012934 | 赣州市   |\n| 江西艺术职业学院              | 4136012936 | 南昌市   |\n| 鹰潭职业技术学院              | 4136012937 | 鹰潭市   |\n| 江西信息应用职业技术学院      | 4136012939 | 南昌市   |\n| 江西交通职业技术学院          | 4136012940 | 南昌市   |\n| 江西财经职业学院              | 4136012941 | 九江市   |\n| 江西应用技术职业学院          | 4136012942 | 赣州市   |\n| 江西现代职业技术学院          | 4136012943 | 南昌市   |\n| 江西工业工程职业技术学院      | 4136012944 | 萍乡市   |\n| 江西机电职业技术学院          | 4136012976 | 南昌市   |\n| 江西科技职业学院              | 4136013419 | 南昌市   |\n| 南昌职业学院                  | 4136013420 | 南昌市   |\n| 江西外语外贸职业学院          | 4136013422 | 南昌市   |\n| 江西工业贸易职业技术学院      | 4136013423 | 南昌市   |\n| 宜春职业技术学院              | 4136013424 | 宜春市   |\n| 江西应用工程职业学院          | 4136013425 | 萍乡市   |\n| 江西生物科技职业学院          | 4136013426 | 南昌市   |\n| 江西建设职业技术学院          | 4136013427 | 南昌市   |\n| 抚州职业技术学院              | 4136013428 | 抚州市   |\n| 江西中医药高等专科学校        | 4136013775 | 抚州市   |\n| 江西先锋软件职业技术学院      | 4136013776 | 南昌市   |\n| 江西经济管理职业学院          | 4136013866 | 南昌市   |\n| 江西制造职业技术学院          | 4136013867 | 南昌市   |\n| 江西工程职业学院              | 4136013868 | 南昌市   |\n| 江西青年职业学院              | 4136013869 | 南昌市   |\n| 上饶职业技术学院              | 4136013870 | 上饶市   |\n| 江西航空职业技术学院          | 4136013871 | 南昌市   |\n| 江西农业工程职业学院          | 4136013872 | 宜春市   |\n| 赣西科技职业学院              | 4136013873 | 新余市   |\n| 江西卫生职业学院              | 4136013965 | 南昌市   |\n| 江西新能源科技职业学院        | 4136014166 | 新余市   |\n| 江西枫林涉外经贸职业学院      | 4136014167 | 九江市   |\n| 江西泰豪动漫职业学院          | 4136014168 | 南昌市   |\n| 江西冶金职业技术学院          | 4136014241 | 新余市   |\n| 江西管理职业学院              | 4136014249 | 南昌市   |\n| 江西传媒职业学院              | 4136014250 | 南昌市   |\n| 江西工商职业技术学院          | 4136014321 | 南昌市   |\n| 景德镇陶瓷职业技术学院        | 4136014402 | 景德镇市 |\n| 共青科技职业学院              | 4136014403 | 九江市   |\n| 赣州师范高等专科学校          | 4136014465 | 赣州市   |\n| 江西水利职业学院              | 4136014476 | 南昌市   |\n| 宜春幼儿师范高等专科学校      | 4136014494 | 宜春市   |\n| 吉安职业技术学院              | 4136014504 | 吉安市   |\n| 江西洪州职业学院              | 4136014505 | 宜春市   |\n| 江西师范高等专科学校          | 4136014537 | 鹰潭市   |\n| 南昌影视传播职业学院          | 4136014544 | 南昌市   |\n| 赣南卫生健康职业学院          | 4136014569 | 赣州市   |\n\n这里是江西的其他地区的自己百度，有些学校学号不等于id号。具体要自己查\n\n## linux操作\n用ftp工具把文件上传，文件下载和配置[看这](看这)\n用到python3和crontab安装:\n```shell\nyum install python3\nyum install python3-pip\nyum install crontabs\npython3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py //查看打卡成不成功\n```\n\n**文件地址：**\n![](https://static-jsdn.oss-cn-shenzhen.aliyuncs.com/img/20220226174853.png)\n命令：\n```shell\ncrontab –e //crontab脚本编辑文件\n0 2 * * * python3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py\n//每天晚上两点自动打卡，我自己的经常不打卡所以多设置几个比较好\n```\n\n```shell\ncrontab -l //检查\nservice crond start //启动\n```', 1, '', 0, 0, 1, '2021-11-06 18:09:03', '2022-02-26 23:52:57');
INSERT INTO `t_article` VALUES (57, 1, 335, 'https://static.jishudaniu.com/articles/193a084cdf280332dd5e156ddd0433d0.jpg', 'SpringBoot启动定时任务', '## 1、启动类里面使用@EnableScheduling 注解开启功能，自动扫描：\n\n\n\n```java\n@SpringBootApplication\n@EnableScheduling //开启定时任务\npublic class MainApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MainApplication.class, args);\n    }\n}\n```\n\n## 2、新建一个Job类：\n\n> - 要在任务的类上写@Component\n> - 要在任务方法上写@Scheduled\n\n\n\n```java\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\n\n\n@Component\npublic class Jobs {\n    //表示方法执行完成后5秒\n    @Scheduled(fixedDelay = 5000)\n    public void fixedDelayJob() throws InterruptedException {\n        System.out.println(\"fixedDelay 每隔5秒\" + new Date());\n    }\n\n    //表示每隔3秒\n    @Scheduled(fixedRate = 3000)\n    public void fixedRateJob() {\n\n        System.out.println(\"fixedRate 每隔3秒\" + new Date());\n    }\n\n    //表示每天8时30分0秒执行\n    @Scheduled(cron = \"0 0,30 0,8 ? * ? \")\n    public void cronJob() {\n        System.out.println(new Date() + \" ...>>cron....\");\n    }\n}\n```\n\n*执行结果如下：*\n\n\n\n```css\nfixedRate 每隔3秒Thu Jun 20 20:26:41 CST 2019\nfixedDelay 每隔5秒Thu Jun 20 20:26:43 CST 2019\nfixedRate 每隔3秒Thu Jun 20 20:26:44 CST 2019\nfixedDelay 每隔5秒Thu Jun 20 20:26:48 CST 2019\n```\n\n## 3、总结\n\n> - fixedDelay和fixedRate，单位是毫秒，这里这里就是5秒和3秒，它们的区别就是：fixedRate就是每多次分钟一次，不论你业务执行花费了多少时间。我都是1分钟执行1次，而fixedDelay是当任务执行完毕后1分钟在执行。所以根据实际业务不同，可以选择不同的方式。\n> - cron表达式：比如你要设置每天什么时候执行，就可以用它\n>    cron表达式，有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。\n>    cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：\n\n\n\n```html\n* 第一位，表示秒，取值0-59\n* 第二位，表示分，取值0-59\n* 第三位，表示小时，取值0-23\n* 第四位，日期天/日，取值1-31\n* 第五位，日期月份，取值1-12\n* 第六位，星期，取值1-7，星期一，星期二...，注：不是第1周，第二周的意思\n          另外：1表示星期天，2表示星期一。\n* 第7为，年份，可以留空，取值1970-2099\n```\n\n> cron中，还有一些特殊的符号，含义如下：\n\n\n\n```bash\n(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...\n(?)问号：问号只能出现在日期和星期这两个位置。\n(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12\n(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四\n(/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*/y，等同于0/y\n```\n\n> 下面列举几个例子供大家来验证：\n\n\n\n```bash\n0 0 3 * * ?     每天3点执行\n0 5 3 * * ?     每天3点5分执行\n0 5 3 ? * *     每天3点5分执行，与上面作用相同\n0 5/10 3 * * ?  每天3点的 5分，15分，25分，35分，45分，55分这几个时间点执行\n0 10 3 ? * 1    每周星期天，3点10分 执行，注：1表示星期天    \n0 10 3 ? * 1#3  每个月的第三个星期，星期天 执行，#号只能出现在星期的位置\n```\n\n', 1, '', 0, 0, 1, '2022-02-01 01:31:14', '2022-03-03 01:50:53');
INSERT INTO `t_article` VALUES (58, 1, 335, 'https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg', '个人收藏网站分享', '### 资源不在于多而在于精，分享一些常用的\n\n#### 开源项目：\n\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\n2. [github全球最大的代码托管平台](https://github.com)\n3. [gitee中国最大的托管平台](https://gitee.com)\n4. https://sourceforge.net/\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\n\n#### 疑难杂症解决：\n\n1. [google](https://www.google.com/)\n2. [stackoverflow（解决bug的好去处）](https://www.stackoverflow.com/)\n3. [baidu](https://www.baidu.com/)\n4. [b乎](https://www.zhihu.com/)\n5. [简书质量一直可以](https://www.jianshu.com/)\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\n7. https://www.csdn.net/\n8. [稀土掘金](https://juejin.cn/)\n9. [b站](https://bilibili.com/)\n\n#### 素材:\n\n1. [jQuery插件库](https://www.iconfont.cn/)\n2. https://pixabay.com/zh/\n3. https://unsplash.com/\n4. http://www.pexels.com/\n5. https://gitmind.cn/app/doc/d74790416\n6. https://zhutix.com/ico/gang-chrome/\n\n#### 在线设计类:\n\n1. [在线PS](https://www.uupoop.com/#/old)\n2. [在线音频剪辑](https://www.weixinsyt.com/)\n3. [在线视频剪辑](https://www.kapwing.com/)\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\n\n#### 在线编程:\n\n1. https://jsrun.net/\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\n3. [编程中国](https://www.bccn.net/)\n\n####  学习网站:\n\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\n4. [CodeGym](https://codegym.cc/)\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\n\n', 1, '', 1, 0, 1, '2022-03-06 17:21:54', '2022-03-20 15:28:51');
INSERT INTO `t_article` VALUES (59, 1, 333, 'https://static.jishudaniu.com/articles/29ccc97d96ac3a7abb8d8e13dea450d4.jpg', 'mysql安装配置', '# 部署服务器\n\n## 安装mysql\n\nrpm -qa|grep mysql #无输出说明没有安装\n\n### 下载和安装mysql源\n\nwget [https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm](https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fget%2Fmysql80-community-release-el7-3.noarch.rpm)\n\n### 安装mysql源\n\n``` shell\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\n```\n\n### 查看mysql相关资源\n\n``` shell\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\n```\n\n如果没有安装yum-config-manager 需要安装yum -y install yum-utils\n\n选择mysql版本:\n\n/*使用MySQL Yum Repository安装MySQL，默认会选择当前最新的稳定版本\n\n使用命令：yum repolist all | grep mysql，查看当前yum repolist的所有版本*/\n\n``` shell\nyum repolist all | grep mysql\n```\n\n### 切换版本\n\n``` shell\nsudo yum-config-manager --disable mysql80-community\n\nsudo yum-config-manager --enable mysql57-community\n```\n\n### 安装mysql:\n\n该命令会安装MySQL服务器 (mysql-community-server) 及其所需的依赖、相关组件，包括mysql-community-client、mysql-community-common、mysql-community-libs等。安装时间会比较长\n\n``` shell\nsudo yum install mysql-community-server\n```\n\n### 启动Mysql\n\n``` shell\nsystemctl start mysqld.service\n\nsystemctl status mysqld.service\n```\n\n### 停止Mysql\n\n``` shell\nsystemctl stop mysqld.service\n```\n\n### 重启Mysql\n\n``` shell\nsystemctl restart mysqld.service\n```\n\n### 初始密码\n\nMySQL第一次启动后会创建超级管理员账号root@localhost，初始密码存储在日志文件中：\n\n``` shell\ngrep \'temporary password\' /var/log/mysqld.log\n```\n\n### 进入mysql客户端\n\nmysql -u root  -p\n\n输入上面的临时密码password\n\n### 修改默认密码\n\n``` shell\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'admin123\'\n```\n\n### 设置开机启动\n\n``` shell\nsystemctl enable mysqld\n\nsystemctl daemon-reload\n\n```\n\n### 开放远程连接\n\n``` shell\nmysql>use mysql;\n\nmsyql>update user set user.Host=\'%\' where user.User=\'root\';\n\nmysql>flush privileges;\n```\n\n## 安装JDK\n\n自行百度\n\n推荐清华镜像源jdk8\n\n``` shell\nwget https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_openj9_linuxXL_8u282b08_openj9-0.24.0.tar.gz\n```\n\n### 配置环境变量\n\nvim /etc/profile\n\nshift+G划到底部 添加环境变量\n\n``` shell\nexport JAVA_HOME= **YOUR_JAVA_PATH**\nexport JRE_HOME=$JAVA_HOME/jre\nexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib\nexport PATH=$JAVA_HOME/bin:$PATH\n```\n\n刷新\n\n``` shell\nsource /etc/profile\n\njava -version\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 1, '', 0, 0, 1, '2022-03-07 02:27:49', '2022-03-07 18:05:52');
INSERT INTO `t_article` VALUES (60, 1, 335, 'https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg', 'spring家族注解汇总', '## Springboot注解\n\n### 一. 注解列表\n\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\n\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\n\n@EnableAutoConfiguSuppressWaration 自动配置。\n\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\n\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\n\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\n\n@Autowired自动导入。\n\n@PathVariable获取参数。\n\n@JsonBackReference解决嵌套外链问题。\n\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\n\n### 二. 注解(annotations)详解\n\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\n\n``` java\npackage com.example.myproject;\n\nimport org.springframework.boot.SpringApplication;\n\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n \n\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\n\npublic class Application {\n\npublic static void main(String[] args) {\n\n	SpringApplication.run(Application.class, args);\n\n	}\n\n}\n```\n\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\n\n\n\n ```java\n@RequestMapping(\"/test\")\n\n@ResponseBody\n\npublic String test(){\n\n	return \"OK\";\n\n}\n ```\n\n\n\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\n\n```java\n@Controller\n\n@RequestMapping(“/demoInfo”)\n\npublicclass DemoController {\n\n@Autowired\n\nprivate DemoInfoService demoInfoService;\n\n \n\n@RequestMapping(\"/hello\")\n\npublic String hello(Map<String,Object> map){\n\n  	System.out.println(\"DemoController.hello()\");\n\n  	map.put(\"hello\",\"from TemplateController.helloHtml\");\n\n  	//会使用hello.html或者hello.ftl模板进行渲染显示.\n\n  	return\"/hello\";\n\n	}\n\n}\n\n```\n\n\n\n \n\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\n\n```java\npackage com.kfit.demo.web;\n\n \n\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport org.springframework.web.bind.annotation.RestController;\n\n \n\n \n\n@RestController\n\n@RequestMapping(“/demoInfo2”)\n\npublicclass DemoController2 {\n\n \n\n@RequestMapping(\"/test\")\n\npublic String test(){\n\n  return\"ok\";\n\n}\n\n}\n```\n\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\n\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\n\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\n\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\n\n@Import：用来导入其他配置类。\n\n@ImportResource：用来加载xml配置文件。\n\n@Autowired：自动导入依赖的bean\n\n@Service：一般用于修饰service层的组件\n\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\n\n@Bean：用@Bean标注方法等价于XML中配置的bean。\n\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\n\n@Value(value = “#{message}”)\n\nprivate String message;\n\n \n\n@Inject：等价于默认的@Autowired，只是没有required属性；\n\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\n\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\n\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\n\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\n\n@Autowired\n\n@Qualifier(value = “demoInfoService”)\n\nprivate DemoInfoService demoInfoService;\n\n \n\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\n\n### JPA注解\n\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\n\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\n\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\n\n@Column：如果字段名与列名相同，则可以省略。\n\n@Id：表示该属性为主键。\n\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\n\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\n\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\n\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\n\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\n\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\n\n### springMVC相关注解\n\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \nparams:指定request中必须包含某些参数值是，才让该方法处理。 \nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\n\n@RequestParam：用在方法的参数前面。 \n@RequestParam \nString a =request.getParameter(“a”)。\n\n@PathVariable:路径变量。如\n\nRequestMapping(“user/get/mac/{macAddress}”)\n\npublic String getByMacAddress(@PathVariable String macAddress){\n\n//do something;\n\n}\n\n参数与大括号里的名字一样要相同。\n\n \n\n### 全局异常处理\n\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\n\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\n\n \n\n### Spring注解\n\n@Controller\n@Service\n@Autowired\n@RequestMapping\n@RequestParam\n@ModelAttribute\n@Cacheable\n@CacheFlush\n@Resource\n@PostConstruct\n@PreDestroy\n@Repository\n@Component （不推荐使用）\n@Scope\n@SessionAttributes\n@InitBinder\n@Required\n@Qualifier\n\n\n\n#### @Controller\n\n • 例如\n@Controller\n public class SoftCreateController extends SimpleBaseController {}\n • 或者\n@Controller(\"userController\")\n\n• 说明\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \n\n#### @Service\n\n• 例如\n @Service\n public class SoftCreateServiceImpl implements ISoftCreateService {}\n • 或者\n @Service(\"softCreateServiceImpl\")\n\n • 说明\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\n\n#### @Autowired\n\n• 例如\n @Autowired\nprivate ISoftPMService softPMService;\n• 或者\n@Autowired(required=false)\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\n\n • 说明\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \n\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\n\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\n\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\n\n#### @RequestMapping\n\n• 类\n```java\n@Controller\n@RequestMapping(\"/bbtForum.do\")\npublic class BbtForumController {\n       @RequestMapping(params = \"method=listBoardTopic\")\n 	public String listBoardTopic(int topicId,User user) {}\n}\n```\n • 方法\n```java\n @RequestMapping(\"/softpg/downSoftPg.do\")\n @RequestMapping(value=\"/softpg/ajaxLoadSoftId.do\",method = POST)\n@RequestMapping(value = \"/osu/product/detail.do\", params = { \"modify=false\" }, method =POST)\n```\n\n • 说明\n  @RequestMapping 可以声明到类或方法上\n\n• 参数绑定说明\n如果我们使用以下的 URL 请求：\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\n\n#### @RequestParam\n\n• 参数绑定说明\n@RequestParam(\"id\")\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\nlistBoardTopic(@RequestParam(\"id\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \n@RequestParam(required=false)：参数不是必须的，默认为true\n@RequestParam(value=\"id\",required=false)\n\n请求处理方法入参的可选类型\n• Java 基本数据类型和 String\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\n\n • request/response/session\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \n\n• org.springframework.web.context.request.WebRequest\n      内部包含了 request 对象\n\n• java.util.Locale \n      绑定到 request 对应的 Locale 对象上\n\n• java.io.InputStream/java.io.Reader\n        可以借此访问 request 的内容 \n\n• java.io.OutputStream / java.io.Writer\n      可以借此操作 response 的内容\n\n• 任何标注了 @RequestParam 注解的入参 \n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\n\n• java.util.Map / org.springframework.ui.ModelMap\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\n\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\n\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \n\n• org.springframework.web.bind.support.SessionStatus\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \n\n请求处理方法返回值的可选类型\n\n• void\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\n@RequestMapping(\"/welcome.do\")\npublic void welcomeHandler() {}\n对应的逻辑视图名为 “ welcome ”\n\n• String\n此时逻辑视图名为返回的字符，如以下的方法：\n\n```java\n@RequestMapping(method = RequestMethod.GET)\npublic String setupForm(@RequestParam(\"ownerId\") int ownerId, ModelMap model) {\n\n    Owner owner = this.clinic.loadOwner(ownerId);\n    model.addAttribute(owner);\n    return \"ownerForm\";\n\n}\n```\n\n\n对应的逻辑视图名为 “ ownerForm ”\n\n• org.springframework.ui.ModelMap\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\n@RequestMapping(\"/vets.do\")\npublic ModelMap vetsHandler() { \nreturn new ModelMap(this.clinic.getVets());\n}\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\n\n• ModelAndView\n当然还可以是传统的 ModelAndView 。\n\n#### @ModelAttribute\n\n• 作用域：request\n • 例如\n\n```java\n@RequestMapping(\"/base/userManageCooper/init.do\")\npublic String handleInit(@ModelAttribute(\"queryBean\") ManagedUser sUser,Model model,){}\n```\n\n\n\n• 或者\n\n```java\n@ModelAttribute(\"coopMap\")// 将coopMap 返回到页 面\npublic Map<Long,CooperatorInfo> coopMapItems(){}\n```\n\n\n\n• 说明\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\"queryBean\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 \n\n@ModelAttribute使用大致有有两种：\n\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\n\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\n\n\n#### @Cacheable和@CacheFlush\n\n • @Cacheable ：声明一个方法的返回值应该被缓 存\n 例如：@Cacheable(modelId = \"testCaching\")\n\n• @CacheFlush ：声明一个方法是清空缓存的触发器\n例如：@CacheFlush(modelId = \"testCaching\")\n\n• 说明\n要配合缓存处理器使用\n\n\n#### @Resource\n\n• 例如\n\n```java\n@Resource\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\n```\n\n\n • 或者\n\n```java\n@Resource(name=\"dataSource\")\n@Resource(type=DataSource.class)\n```\n\n• 说明\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \n此时与@Autowired 类 似.\n\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\"\")，否则注入失败；\n\n#### @PostConstruct和@PreDestroy\n\n• @PostConstruct\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\n\n• @PreDestroy\n\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \n\n@Repository\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\n\n#### @Component （不推荐使用）\n\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\n\n#### @Scope\n\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\n• 说明\n\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\n同样可以通过@Scope 注解来完成\n\n@Scope中可以指定如下值：\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\nrequest:定义bean的范围是http请求（springMVC中有效）\nsession:定义bean的范围是http会话（springMVC中有效）\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\n\n#### @SessionAttributes\n\n• 说明\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\n• 例如\n@SessionAttributes(\"currUser\") // 将ModelMap 中属性名为currUser 的属性\n@SessionAttributes({\"attr1\",\"attr2\"})\n@SessionAttributes(types = User.class)\n@SessionAttributes(types = {User.class,Dept.class})\n@SessionAttributes(types = {User.class,Dept.class},value={\"attr1\",\"attr2\"})\n\n#### @InitBinder\n\n• 说明\n如果希望某个属性编辑器仅作用于特定的 Controller ，\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\n可以在该方法中向 Controller 了注册若干个属性编辑器\n\n• 例如\n\n```java\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n    dateFormat.setLenient(false);\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n}\n```\n\n\n（14）@Required • 例如 @required\npublic setName(String name){} • 说明 \n\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\n\n（15）@Qualifier\n\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\n\n下面是其他注解，包括组合注解 （1）@Autowired\n\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\n\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\n\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\n\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\n\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\n\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\n\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\n\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\n\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\n\n（4）@Transactional 事物注解\n\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\n\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\n\n（6）\n\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\n\n### Mybatis\n\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\n\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\"getSql\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\n\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\n\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\n\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\n\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \"getByTestText\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\n\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\n\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\n\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\n\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\n\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\n\n### SpringMVC\n\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\n\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\n\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\n\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\n\n在SpringMVC后台控制层获取参数的方式主要有两种:\n\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\n\n接下来我们看一下@RequestParam注解主要有哪些参数：\n\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\n\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\n\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\n\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\n\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\n\nvalue， method；\n\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\n\nconsumes，produces\n\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\n\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\n\nparams，headers\n\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\n\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\n\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\n\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\n\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\n\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\n\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\n\n@SessionAttributes即将值放到session作用域中，写在class上面。\n\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\n\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\n\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\n\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\n\n(12)@Repository 用于注解dao层，在daoImpl类上面注解', 1, '', 0, 0, 1, '2022-03-15 19:38:48', '2022-03-16 00:47:39');

-- ----------------------------
-- Table structure for t_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_article_tag`;
CREATE TABLE `t_article_tag`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `article_id` int NOT NULL COMMENT '文章id',
  `tag_id` int NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_article_tag_1`(`article_id`) USING BTREE,
  INDEX `fk_article_tag_2`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 556 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article_tag
-- ----------------------------
INSERT INTO `t_article_tag` VALUES (511, 53, 59);
INSERT INTO `t_article_tag` VALUES (513, 54, 31);
INSERT INTO `t_article_tag` VALUES (519, 56, 40);
INSERT INTO `t_article_tag` VALUES (523, 57, 60);
INSERT INTO `t_article_tag` VALUES (524, 55, 44);
INSERT INTO `t_article_tag` VALUES (530, 59, 40);
INSERT INTO `t_article_tag` VALUES (552, 60, 28);
INSERT INTO `t_article_tag` VALUES (553, 60, 29);
INSERT INTO `t_article_tag` VALUES (554, 60, 42);
INSERT INTO `t_article_tag` VALUES (555, 58, 61);

-- ----------------------------
-- Table structure for t_category
-- ----------------------------
DROP TABLE IF EXISTS `t_category`;
CREATE TABLE `t_category`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '分类名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 336 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_category
-- ----------------------------
INSERT INTO `t_category` VALUES (333, '运维', '2022-02-26 16:19:09', NULL);
INSERT INTO `t_category` VALUES (334, 'frontend', '2022-02-26 16:59:41', NULL);
INSERT INTO `t_category` VALUES (335, 'backend', '2022-03-03 01:13:41', NULL);

-- ----------------------------
-- Table structure for t_chat_record
-- ----------------------------
DROP TABLE IF EXISTS `t_chat_record`;
CREATE TABLE `t_chat_record`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int NULL DEFAULT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `content` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '聊天内容',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'ip地址',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'ip来源',
  `type` tinyint NOT NULL COMMENT '类型',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_chat_record
-- ----------------------------

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int NOT NULL COMMENT '评论用户Id',
  `article_id` int NULL DEFAULT NULL COMMENT '评论文章id',
  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论内容',
  `reply_user_id` int NULL DEFAULT NULL COMMENT '回复用户id',
  `parent_id` int NULL DEFAULT NULL COMMENT '父评论id',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除  0否 1是',
  `is_review` tinyint(1) NOT NULL DEFAULT 1 COMMENT '是否审核',
  `create_time` datetime NOT NULL COMMENT '评论时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_comment_user`(`user_id`) USING BTREE,
  INDEX `fk_comment_article`(`article_id`) USING BTREE,
  INDEX `fk_comment_parent`(`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 441 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_comment
-- ----------------------------

-- ----------------------------
-- Table structure for t_friend_link
-- ----------------------------
DROP TABLE IF EXISTS `t_friend_link`;
CREATE TABLE `t_friend_link`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接名',
  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接头像',
  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接地址',
  `link_intro` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接介绍',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_friend_link_user`(`link_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_friend_link
-- ----------------------------
INSERT INTO `t_friend_link` VALUES (21, '测试友链', 'https://bing.ioliu.cn/v1/rand', 'www.baidu.com', '一个有趣的灵魂', '2022-02-13 17:13:15', NULL);

-- ----------------------------
-- Table structure for t_menu
-- ----------------------------
DROP TABLE IF EXISTS `t_menu`;
CREATE TABLE `t_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单名',
  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单路径',
  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '组件',
  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单icon',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `order_num` tinyint(1) NOT NULL COMMENT '排序',
  `parent_id` int NULL DEFAULT NULL COMMENT '父id',
  `is_hidden` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否隐藏  0否1是',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 215 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_menu
-- ----------------------------
INSERT INTO `t_menu` VALUES (1, '首页', '/', '/home/Home.vue', 'el-icon-myshouye', '2021-01-26 17:06:51', '2021-01-26 17:06:53', 1, NULL, 0);
INSERT INTO `t_menu` VALUES (2, '文章管理', '/article-submenu', 'Layout', 'el-icon-mywenzhang-copy', '2021-01-25 20:43:07', '2021-01-25 20:43:09', 2, NULL, 0);
INSERT INTO `t_menu` VALUES (3, '消息管理', '/message-submenu', 'Layout', 'el-icon-myxiaoxi', '2021-01-25 20:44:17', '2021-01-25 20:44:20', 3, NULL, 0);
INSERT INTO `t_menu` VALUES (4, '系统管理', '/system-submenu', 'Layout', 'el-icon-myshezhi', '2021-01-25 20:45:57', '2021-01-25 20:45:59', 5, NULL, 0);
INSERT INTO `t_menu` VALUES (5, '个人中心', '/setting', '/setting/Setting.vue', 'el-icon-myuser', '2021-01-26 17:22:38', '2021-01-26 17:22:41', 7, NULL, 0);
INSERT INTO `t_menu` VALUES (6, '发布文章', '/articles', '/article/Article.vue', 'el-icon-myfabiaowenzhang', '2021-01-26 14:30:48', '2021-01-26 14:30:51', 1, 2, 0);
INSERT INTO `t_menu` VALUES (7, '修改文章', '/articles/*', '/article/Article.vue', 'el-icon-myfabiaowenzhang', '2021-01-26 14:31:32', '2021-01-26 14:31:34', 2, 2, 1);
INSERT INTO `t_menu` VALUES (8, '文章列表', '/article-list', '/article/ArticleList.vue', 'el-icon-mywenzhangliebiao', '2021-01-26 14:32:13', '2021-01-26 14:32:16', 3, 2, 0);
INSERT INTO `t_menu` VALUES (9, '分类管理', '/categories', '/category/Category.vue', 'el-icon-myfenlei', '2021-01-26 14:33:42', '2021-01-26 14:33:43', 4, 2, 0);
INSERT INTO `t_menu` VALUES (10, '标签管理', '/tags', '/tag/Tag.vue', 'el-icon-myicontag', '2021-01-26 14:34:33', '2021-01-26 14:34:36', 5, 2, 0);
INSERT INTO `t_menu` VALUES (11, '评论管理', '/comments', '/comment/Comment.vue', 'el-icon-mypinglunzu', '2021-01-26 14:35:31', '2021-01-26 14:35:34', 1, 3, 0);
INSERT INTO `t_menu` VALUES (12, '留言管理', '/messages', '/message/Message.vue', 'el-icon-myliuyan', '2021-01-26 14:36:09', '2021-01-26 14:36:13', 2, 3, 0);
INSERT INTO `t_menu` VALUES (13, '用户列表', '/users', '/user/User.vue', 'el-icon-myyonghuliebiao', '2021-01-26 14:38:09', '2021-01-26 14:38:12', 1, 202, 0);
INSERT INTO `t_menu` VALUES (14, '角色管理', '/roles', '/role/Role.vue', 'el-icon-myjiaoseliebiao', '2021-01-26 14:39:01', '2021-01-26 14:39:03', 2, 213, 0);
INSERT INTO `t_menu` VALUES (15, '接口管理', '/resources', '/resource/Resource.vue', 'el-icon-myjiekouguanli', '2021-01-26 14:40:14', '2021-08-07 20:00:28', 2, 213, 0);
INSERT INTO `t_menu` VALUES (16, '菜单管理', '/menus', '/menu/Menu.vue', 'el-icon-mycaidan', '2021-01-26 14:40:54', '2021-08-07 10:18:49', 2, 213, 0);
INSERT INTO `t_menu` VALUES (17, '友链管理', '/links', '/friendLink/FriendLink.vue', 'el-icon-mydashujukeshihuaico-', '2021-01-26 14:41:35', '2021-01-26 14:41:37', 3, 4, 0);
INSERT INTO `t_menu` VALUES (18, '关于我', '/about', '/about/About.vue', 'el-icon-myguanyuwo', '2021-01-26 14:42:05', '2021-01-26 14:42:10', 4, 4, 0);
INSERT INTO `t_menu` VALUES (19, '日志管理', '/log-submenu', 'Layout', 'el-icon-myguanyuwo', '2021-01-31 21:33:56', '2021-01-31 21:33:59', 6, NULL, 0);
INSERT INTO `t_menu` VALUES (20, '操作日志', '/operation/log', '/log/Operation.vue', 'el-icon-myguanyuwo', '2021-01-31 15:53:21', '2021-01-31 15:53:25', 1, 19, 0);
INSERT INTO `t_menu` VALUES (201, '在线用户', '/online/users', '/user/Online.vue', 'el-icon-myyonghuliebiao', '2021-02-05 14:59:51', '2021-02-05 14:59:53', 7, 202, 0);
INSERT INTO `t_menu` VALUES (202, '用户管理', '/users-submenu', 'Layout', 'el-icon-myyonghuliebiao', '2021-02-06 23:44:59', '2021-02-06 23:45:03', 4, NULL, 0);
INSERT INTO `t_menu` VALUES (205, '相册管理', '/album-submenu', 'Layout', 'el-icon-myimage-fill', '2021-08-03 15:10:54', '2021-08-07 20:02:06', 5, NULL, 0);
INSERT INTO `t_menu` VALUES (206, '相册列表', '/albums', '/album/Album.vue', 'el-icon-myzhaopian', '2021-08-03 20:29:19', '2021-08-04 11:45:47', 1, 205, 0);
INSERT INTO `t_menu` VALUES (208, '照片管理', '/albums/:albumId', '/album/Photo.vue', 'el-icon-myzhaopian', '2021-08-03 21:37:47', '2021-08-05 10:24:08', 1, 205, 1);
INSERT INTO `t_menu` VALUES (209, '页面管理', '/pages', '/page/Page.vue', 'el-icon-myyemianpeizhi', '2021-08-04 11:36:27', '2021-08-07 20:01:26', 2, 4, 0);
INSERT INTO `t_menu` VALUES (210, '照片回收站', '/photos/delete', '/album/Delete.vue', 'el-icon-myhuishouzhan', '2021-08-05 13:55:19', NULL, 3, 205, 1);
INSERT INTO `t_menu` VALUES (213, '权限管理', '/permission-submenu', 'Layout', 'el-icon-mydaohanglantubiao_quanxianguanli', '2021-08-07 19:56:55', '2021-08-07 19:59:40', 4, NULL, 0);
INSERT INTO `t_menu` VALUES (214, '网站管理', '/website', '/website/Website.vue', 'el-icon-myxitong', '2021-08-07 20:06:41', NULL, 1, 4, 0);

-- ----------------------------
-- Table structure for t_message
-- ----------------------------
DROP TABLE IF EXISTS `t_message`;
CREATE TABLE `t_message`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '留言内容',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户地址',
  `time` tinyint(1) NULL DEFAULT NULL COMMENT '弹幕速度',
  `is_review` tinyint NOT NULL DEFAULT 1 COMMENT '是否审核',
  `create_time` datetime NOT NULL COMMENT '发布时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 23 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_message
-- ----------------------------
INSERT INTO `t_message` VALUES (1, '游客', 'https://static.jishudaniu.com/config/26f83c764cbe7b29e0178192cd0d35b9.jpg', '吼吼吼', '59.55.170.31', '江西省吉安市 电信', 9, 1, '2022-02-26 19:46:31', NULL);
INSERT INTO `t_message` VALUES (19, '游客', 'https://static.jishudaniu.com/config/26f83c764cbe7b29e0178192cd0d35b9.jpg', '哈哈哈', '127.0.0.1', '', 8, 1, '2022-02-26 20:11:04', NULL);
INSERT INTO `t_message` VALUES (21, '游客', 'https://static.jishudaniu.com/config/26f83c764cbe7b29e0178192cd0d35b9.jpg', '66666', '127.0.0.1', '', 7, 1, '2022-02-26 20:12:14', NULL);

-- ----------------------------
-- Table structure for t_operation_log
-- ----------------------------
DROP TABLE IF EXISTS `t_operation_log`;
CREATE TABLE `t_operation_log`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作模块',
  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作类型',
  `opt_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作url',
  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作方法',
  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作描述',
  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求参数',
  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求方式',
  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '返回数据',
  `user_id` int NOT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `ip_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作地址',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 823 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_operation_log
-- ----------------------------
INSERT INTO `t_operation_log` VALUES (766, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1. 常用命令\\n\\n以下命令nginx已经通过apt安装好了，有nginx命令。\\n\\n## 1. 查看版本\\n\\n```shell\\nnginx -v\\n```\\n\\n如果你想同时看到更详细的配置项，使用 -V\\n\\n```shell\\nnginx -V\\n```\\n\\n## 2. 查看 Nginx 配置语法的正确性\\n\\n```shell\\nsudo nginx -t\\n```\\n\\n这里如果用大写 T，效果就是 测试、丢弃并退出\\n\\n```shell\\nsudo nginx -T\\n```\\n\\n## 3. 为Nginx指定一个配置文件\\n\\n```shell\\nnginx -c </path/config> #为Nginx指定一个配置文件，来代替缺省值conf/nginx.conf\\n```\\n\\n## 4. 启动 Nginx 服务\\n\\n```shell\\nsudo systemctl start nginx #systemd\\nOR\\nsudo service nginx start   #sysvinit\\n```\\n\\n## 5. 开机自启动\\n\\n```shell\\nsudo systemctl enable nginx #systemd\\n或\\nsudo service nginx enable   #sysv init\\n```\\n\\n## 6. 重启 Nginx 服务\\n\\n重启的意思是，停止 然后 启动\\n\\n```shell\\nsudo systemctl restart nginx #systemd\\n或\\nsudo service nginx restart   #sysv init\\n```\\n\\n## 7. 查看 Nginx 服务状态\\n\\n这条是看运行时的服务状态信息的。\\n\\n```shell\\nsudo systemctl status nginx #systemd\\n或\\nsudo service nginx status   #sysvinit\\n```\\n\\n## 8. 重载 Nginx 服务\\n\\n重载是重新加载 配置文件，看命令：\\n\\n```shell\\nsudo systemctl reload nginx #systemd\\n或\\nsudo service nginx reload   #sysvinit\\n```\\n\\n## 9. 停止 Nginx 服务\\n\\n不管你是什么原因想停了它，都可以用：\\n\\n```shell\\nsudo systemctl stop nginx #systemd\\nOR\\nsudo service nginx stop   #sysvinit\\n```\\n\\n## 10. 查看命令帮助\\n\\n如果还有什么不懂，或者想知道其他命令，就用这个\\n\\n```shell\\nsystemctl -h nginx\\n```\\n\\n# 2. 配置文件\\n\\nnginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改\\n\\n![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132450.png)\\n\\n## 第一部分：全局块 \\n\\n从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\\n\\n比如上面第一行配置的：\\n\\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132657.png)\\n\\n这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约\\n\\n##  第二部分：events 块\\n\\nevents 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。\\n\\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132920.png)\\n\\n上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\\n\\n## 第三部分：http 块\\n\\n这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\\n\\n需要注意的是：http 块也可以包括 **http** **全局块**、**server** **块**。\\n\\n### 1. http全局块\\n\\nhttp 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\\n\\n**upstream**（上游服务器设置，主要为反向代理、负载均衡相关配置，upstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡\\n\\n### 2. server块\\n\\n这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。\\n\\n每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。\\n\\n而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。\\n\\n#### 1.全局 server 块\\n\\n最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。\\n\\n#### 2. location块\\n\\n一个 server 块可以配置多个 location 块。\\n\\n这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。\\n\\n## nginx.conf 详细的配置文件介绍\\n\\n```properties\\n#定义Nginx运行的用户和用户组\\nuser www www; \\n\\n#nginx进程数，通常设置成和cpu的数量相等\\nworker_processes 4; \\n\\n#全局错误日志定义类型，[debug | info | notice | warn | error | crit]\\n#error_log  logs/error.log;\\n#error_log  logs/error.log  notice;\\n#error_log  logs/error.log  info;\\n\\n\\n#进程pid文件\\n#pid        logs/nginx.pid;\\n\\n\\n#指定进程可以打开的最大描述符：数目\\n#工作模式与连接数上限\\n##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\\nworker_rlimit_nofile 65535;\\n\\n\\nevents {\\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\\n    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。\\n    #补充说明：\\n    #与apache相类，nginx针对不同的操作系统，有不同的事件模型\\n    #A）标准事件模型\\n    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll\\n    #B）高效事件模型\\n    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。\\n    #Epoll：使用于Linux内核2.6版本及以后的系统。\\n    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。\\n    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。\\n    use epoll\\n    \\n    \\n    #单个进程最大连接数（最大连接数=连接数+进程数）\\n    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。\\n    worker_connections  1024;\\n    \\n    #keepalive 超时时间\\n    keepalive_timeout 60;\\n    \\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。\\n    #分页大小可以用命令getconf PAGESIZE 取得。\\n    #[root@web001 ~]# getconf PAGESIZE\\n    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。\\n    client_header_buffer_size 4k;\\n    \\n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\\n    open_file_cache max=65535 inactive=60s;\\n    \\n    \\n    #这个是指多长时间检查一次缓存的有效信息。\\n    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.\\n    open_file_cache_valid 80s;\\n    \\n    \\n    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\\n    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.\\n    open_file_cache_min_uses 1;\\n    \\n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.\\n    open_file_cache_errors on;\\n}\\n\\n\\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\\nhttp{\\n    #文件扩展名与文件类型映射表\\n    include mime.types;\\n    \\n    #默认文件类型\\n    default_type application/octet-stream;\\n    \\n    #默认编码\\n    charset utf-8;\\n    \\n    #服务器名字的hash表大小\\n    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.\\n    server_names_hash_bucket_size 128;\\n    \\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\\n    client_header_buffer_size 32k;\\n    \\n    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。\\n    large_client_header_buffers 4 64k;\\n    \\n    #设定通过nginx上传文件的大小\\n    client_max_body_size 8m;\\n    \\n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\\n    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。\\n    sendfile on;\\n    \\n     #开启目录列表访问，合适下载服务器，默认关闭。\\n    autoindex on;\\n    \\n      #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\\n    tcp_nopush on;\\n     \\n    tcp_nodelay on;\\n    \\n    #长连接超时时间，单位是秒\\n    keepalive_timeout 120;\\n    \\n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\\n    fastcgi_connect_timeout 300;\\n    fastcgi_send_timeout 300;\\n    fastcgi_read_timeout 300;\\n    fastcgi_buffer_size 64k;\\n    fastcgi_buffers 4 64k;\\n    fastcgi_busy_buffers_size 128k;\\n    fastcgi_temp_file_write_size 128k;\\n    \\n    #gzip模块设置\\n    gzip on; #开启gzip压缩输出\\n    gzip_min_length 1k;    #最小压缩文件大小\\n    gzip_buffers 4 16k;    #压缩缓冲区\\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\\n    gzip_comp_level 2;     #压缩等级\\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\\n    gzip_vary on;\\n\\n    #开启限制IP连接数的时候需要使用\\n    #limit_zone crawler $binary_remote_addr 10m;\\n    \\n    \\n    #负载均衡配置\\n    upstream piao.jd.com {\\n     \\n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\\n        server 192.168.80.121:80 weight=3;\\n        server 192.168.80.122:80 weight=2;\\n        server 192.168.80.123:80 weight=3;\\n\\n        #nginx的upstream目前支持4种方式的分配\\n        #1、轮询（默认）\\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\\n        #2、weight\\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\\n        #例如：\\n        #upstream bakend {\\n        #    server 192.168.0.14 weight=10;\\n        #    server 192.168.0.15 weight=10;\\n        #}\\n        #2、ip_hash\\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\\n        #例如：\\n        #upstream bakend {\\n        #    ip_hash;\\n        #    server 192.168.0.14:88;\\n        #    server 192.168.0.15:80;\\n        #}\\n        #3、fair（第三方）\\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\\n        #upstream backend {\\n        #    server server1;\\n        #    server server2;\\n        #    fair;\\n        #}\\n        #4、url_hash（第三方）\\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\\n        #upstream backend {\\n        #    server squid1:3128;\\n        #    server squid2:3128;\\n        #    hash $request_uri;\\n        #    hash_method crc32;\\n        #}\\n\\n        #tips:\\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\\n        #    ip_hash;\\n        #    server 127.0.0.1:9090 down;\\n        #    server 127.0.0.1:8080 weight=2;\\n        #    server 127.0.0.1:6060;\\n        #    server 127.0.0.1:7070 backup;\\n        #}\\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\\n\\n        #每个设备的状态设置为:\\n        #1.down表示单前的server暂时不参与负载\\n        #2.weight为weight越大，负载的权重就越大。\\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\\n\\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\\n    }\\n    \\n    \\n    #虚拟主机的配置\\n    server {\\n        #监听端口\\n        listen 80;\\n\\n        #域名可以有多个，用空格隔开\\n        server_name www.jd.com jd.com;\\n        #默认入口文件名称\\n        index index.html index.htm index.php;\\n        root /data/www/jd;\\n\\n        #对******进行负载均衡\\n        location ~ .*.(php|php5)?$\\n        {\\n            fastcgi_pass 127.0.0.1:9000;\\n            fastcgi_index index.php;\\n            include fastcgi.conf;\\n        }\\n         \\n        #图片缓存时间设置\\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\\n        {\\n            expires 10d;\\n        }\\n         \\n        #JS和CSS缓存时间设置\\n        location ~ .*.(js|css)?$\\n        {\\n            expires 1h;\\n        }\\n         \\n        #日志格式设定\\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\\n        #$remote_user：用来记录客户端用户名称；\\n        #$time_local： 用来记录访问时间与时区；\\n        #$request： 用来记录请求的url与http协议；\\n        #$status： 用来记录请求状态；成功是200，\\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\\n        #$http_referer：用来记录从那个页面链接访问过来的；\\n        #$http_user_agent：记录客户浏览器的相关信息；\\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\\n        log_format access \'$remote_addr - $remote_user [$time_local] \\\"$request\\\" \'\\n        \'$status $body_bytes_sent \\\"$http_referer\\\" \'\\n        \'\\\"$http_user_agent\\\" $http_x_forwarded_for\';\\n         \\n        #定义本虚拟主机的访问日志\\n        access_log  /usr/local/nginx/logs/host.access.log  main;\\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\\n         \\n        #对 \\\"/connect-controller\\\" 启用反向代理\\n        location /connect-controller {\\n            proxy_pass http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）\\n            proxy_redirect off;\\n            proxy_set_header X-Real-IP $remote_addr;\\n             \\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n             \\n            #以下是一些反向代理的配置，可选。\\n            proxy_set_header Host $host;\\n\\n            #允许客户端请求的最大单文件字节数\\n            client_max_body_size 10m;\\n\\n            #缓冲区代理缓冲用户端请求的最大字节数，\\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\\n            client_body_buffer_size 128k;\\n\\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\\n            proxy_intercept_errors on;\\n\\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\\n            #nginx跟后端服务器连接超时时间(代理连接超时)\\n            proxy_connect_timeout 90;\\n\\n            #后端服务器数据回传时间(代理发送超时)\\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\\n            proxy_send_timeout 90;\\n\\n            #连接成功后，后端服务器响应时间(代理接收超时)\\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\\n            proxy_read_timeout 90;\\n\\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\\n            proxy_buffer_size 4k;\\n\\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\\n            proxy_buffers 4 32k;\\n\\n            #高负荷下缓冲大小（proxy_buffers*2）\\n            proxy_busy_buffers_size 64k;\\n\\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\\n            proxy_temp_file_write_size 64k;\\n        }\\n        \\n        #本地动静分离反向代理配置\\n        #所有jsp的页面均交由tomcat或resin处理\\n        location ~ .(jsp|jspx|do)?$ {\\n            proxy_set_header Host $host;\\n            proxy_set_header X-Real-IP $remote_addr;\\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n            proxy_pass http://127.0.0.1:8080;\\n        }\\n    }\\n}\\n```\\n\\n## 总结\\n\\nNginx 配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置）。\\n\\nmain 部分设置的指令影响其他所有部分的设置；\\n\\nserver 部分的指令主要用于制定虚拟主机域名、IP 和端口号；\\n\\nupstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；\\n\\nlocation 部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。\\n\\n他们之间的关系：server 继承 main，location 继承 server；upstream 既不会继承指令也不会被继承。\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/85eee7640539ffe9441828c685acf567.jpg\",\"articleTitle\":\"nginx基本使用\",\"isTop\":1,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:18:55', NULL);
INSERT INTO `t_operation_log` VALUES (767, '分类模块', '新增或修改', '/admin/categories', 'com.jishudaniu.dkblog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"运维\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:19:09', NULL);
INSERT INTO `t_operation_log` VALUES (768, '标签模块', '新增或修改', '/admin/tags', 'com.jishudaniu.dkblog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"nginx\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:19:22', NULL);
INSERT INTO `t_operation_log` VALUES (769, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1. 常用命令\\n\\n以下命令nginx已经通过apt安装好了，有nginx命令。\\n\\n## 1. 查看版本\\n\\n```shell\\nnginx -v\\n```\\n\\n如果你想同时看到更详细的配置项，使用 -V\\n\\n```shell\\nnginx -V\\n```\\n\\n## 2. 查看 Nginx 配置语法的正确性\\n\\n```shell\\nsudo nginx -t\\n```\\n\\n这里如果用大写 T，效果就是 测试、丢弃并退出\\n\\n```shell\\nsudo nginx -T\\n```\\n\\n## 3. 为Nginx指定一个配置文件\\n\\n```shell\\nnginx -c </path/config> #为Nginx指定一个配置文件，来代替缺省值conf/nginx.conf\\n```\\n\\n## 4. 启动 Nginx 服务\\n\\n```shell\\nsudo systemctl start nginx #systemd\\nOR\\nsudo service nginx start   #sysvinit\\n```\\n\\n## 5. 开机自启动\\n\\n```shell\\nsudo systemctl enable nginx #systemd\\n或\\nsudo service nginx enable   #sysv init\\n```\\n\\n## 6. 重启 Nginx 服务\\n\\n重启的意思是，停止 然后 启动\\n\\n```shell\\nsudo systemctl restart nginx #systemd\\n或\\nsudo service nginx restart   #sysv init\\n```\\n\\n## 7. 查看 Nginx 服务状态\\n\\n这条是看运行时的服务状态信息的。\\n\\n```shell\\nsudo systemctl status nginx #systemd\\n或\\nsudo service nginx status   #sysvinit\\n```\\n\\n## 8. 重载 Nginx 服务\\n\\n重载是重新加载 配置文件，看命令：\\n\\n```shell\\nsudo systemctl reload nginx #systemd\\n或\\nsudo service nginx reload   #sysvinit\\n```\\n\\n## 9. 停止 Nginx 服务\\n\\n不管你是什么原因想停了它，都可以用：\\n\\n```shell\\nsudo systemctl stop nginx #systemd\\nOR\\nsudo service nginx stop   #sysvinit\\n```\\n\\n## 10. 查看命令帮助\\n\\n如果还有什么不懂，或者想知道其他命令，就用这个\\n\\n```shell\\nsystemctl -h nginx\\n```\\n\\n# 2. 配置文件\\n\\nnginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改\\n\\n![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132450.png)\\n\\n## 第一部分：全局块 \\n\\n从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\\n\\n比如上面第一行配置的：\\n\\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132657.png)\\n\\n这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约\\n\\n##  第二部分：events 块\\n\\nevents 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。\\n\\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132920.png)\\n\\n上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\\n\\n## 第三部分：http 块\\n\\n这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\\n\\n需要注意的是：http 块也可以包括 **http** **全局块**、**server** **块**。\\n\\n### 1. http全局块\\n\\nhttp 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\\n\\n**upstream**（上游服务器设置，主要为反向代理、负载均衡相关配置，upstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡\\n\\n### 2. server块\\n\\n这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。\\n\\n每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。\\n\\n而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。\\n\\n#### 1.全局 server 块\\n\\n最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。\\n\\n#### 2. location块\\n\\n一个 server 块可以配置多个 location 块。\\n\\n这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。\\n\\n## nginx.conf 详细的配置文件介绍\\n\\n```properties\\n#定义Nginx运行的用户和用户组\\nuser www www; \\n\\n#nginx进程数，通常设置成和cpu的数量相等\\nworker_processes 4; \\n\\n#全局错误日志定义类型，[debug | info | notice | warn | error | crit]\\n#error_log  logs/error.log;\\n#error_log  logs/error.log  notice;\\n#error_log  logs/error.log  info;\\n\\n\\n#进程pid文件\\n#pid        logs/nginx.pid;\\n\\n\\n#指定进程可以打开的最大描述符：数目\\n#工作模式与连接数上限\\n##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\\nworker_rlimit_nofile 65535;\\n\\n\\nevents {\\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\\n    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。\\n    #补充说明：\\n    #与apache相类，nginx针对不同的操作系统，有不同的事件模型\\n    #A）标准事件模型\\n    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll\\n    #B）高效事件模型\\n    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。\\n    #Epoll：使用于Linux内核2.6版本及以后的系统。\\n    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。\\n    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。\\n    use epoll\\n    \\n    \\n    #单个进程最大连接数（最大连接数=连接数+进程数）\\n    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。\\n    worker_connections  1024;\\n    \\n    #keepalive 超时时间\\n    keepalive_timeout 60;\\n    \\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。\\n    #分页大小可以用命令getconf PAGESIZE 取得。\\n    #[root@web001 ~]# getconf PAGESIZE\\n    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。\\n    client_header_buffer_size 4k;\\n    \\n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\\n    open_file_cache max=65535 inactive=60s;\\n    \\n    \\n    #这个是指多长时间检查一次缓存的有效信息。\\n    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.\\n    open_file_cache_valid 80s;\\n    \\n    \\n    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\\n    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.\\n    open_file_cache_min_uses 1;\\n    \\n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.\\n    open_file_cache_errors on;\\n}\\n\\n\\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\\nhttp{\\n    #文件扩展名与文件类型映射表\\n    include mime.types;\\n    \\n    #默认文件类型\\n    default_type application/octet-stream;\\n    \\n    #默认编码\\n    charset utf-8;\\n    \\n    #服务器名字的hash表大小\\n    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.\\n    server_names_hash_bucket_size 128;\\n    \\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\\n    client_header_buffer_size 32k;\\n    \\n    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。\\n    large_client_header_buffers 4 64k;\\n    \\n    #设定通过nginx上传文件的大小\\n    client_max_body_size 8m;\\n    \\n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\\n    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。\\n    sendfile on;\\n    \\n     #开启目录列表访问，合适下载服务器，默认关闭。\\n    autoindex on;\\n    \\n      #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\\n    tcp_nopush on;\\n     \\n    tcp_nodelay on;\\n    \\n    #长连接超时时间，单位是秒\\n    keepalive_timeout 120;\\n    \\n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\\n    fastcgi_connect_timeout 300;\\n    fastcgi_send_timeout 300;\\n    fastcgi_read_timeout 300;\\n    fastcgi_buffer_size 64k;\\n    fastcgi_buffers 4 64k;\\n    fastcgi_busy_buffers_size 128k;\\n    fastcgi_temp_file_write_size 128k;\\n    \\n    #gzip模块设置\\n    gzip on; #开启gzip压缩输出\\n    gzip_min_length 1k;    #最小压缩文件大小\\n    gzip_buffers 4 16k;    #压缩缓冲区\\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\\n    gzip_comp_level 2;     #压缩等级\\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\\n    gzip_vary on;\\n\\n    #开启限制IP连接数的时候需要使用\\n    #limit_zone crawler $binary_remote_addr 10m;\\n    \\n    \\n    #负载均衡配置\\n    upstream piao.jd.com {\\n     \\n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\\n        server 192.168.80.121:80 weight=3;\\n        server 192.168.80.122:80 weight=2;\\n        server 192.168.80.123:80 weight=3;\\n\\n        #nginx的upstream目前支持4种方式的分配\\n        #1、轮询（默认）\\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\\n        #2、weight\\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\\n        #例如：\\n        #upstream bakend {\\n        #    server 192.168.0.14 weight=10;\\n        #    server 192.168.0.15 weight=10;\\n        #}\\n        #2、ip_hash\\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\\n        #例如：\\n        #upstream bakend {\\n        #    ip_hash;\\n        #    server 192.168.0.14:88;\\n        #    server 192.168.0.15:80;\\n        #}\\n        #3、fair（第三方）\\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\\n        #upstream backend {\\n        #    server server1;\\n        #    server server2;\\n        #    fair;\\n        #}\\n        #4、url_hash（第三方）\\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\\n        #upstream backend {\\n        #    server squid1:3128;\\n        #    server squid2:3128;\\n        #    hash $request_uri;\\n        #    hash_method crc32;\\n        #}\\n\\n        #tips:\\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\\n        #    ip_hash;\\n        #    server 127.0.0.1:9090 down;\\n        #    server 127.0.0.1:8080 weight=2;\\n        #    server 127.0.0.1:6060;\\n        #    server 127.0.0.1:7070 backup;\\n        #}\\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\\n\\n        #每个设备的状态设置为:\\n        #1.down表示单前的server暂时不参与负载\\n        #2.weight为weight越大，负载的权重就越大。\\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\\n\\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\\n    }\\n    \\n    \\n    #虚拟主机的配置\\n    server {\\n        #监听端口\\n        listen 80;\\n\\n        #域名可以有多个，用空格隔开\\n        server_name www.jd.com jd.com;\\n        #默认入口文件名称\\n        index index.html index.htm index.php;\\n        root /data/www/jd;\\n\\n        #对******进行负载均衡\\n        location ~ .*.(php|php5)?$\\n        {\\n            fastcgi_pass 127.0.0.1:9000;\\n            fastcgi_index index.php;\\n            include fastcgi.conf;\\n        }\\n         \\n        #图片缓存时间设置\\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\\n        {\\n            expires 10d;\\n        }\\n         \\n        #JS和CSS缓存时间设置\\n        location ~ .*.(js|css)?$\\n        {\\n            expires 1h;\\n        }\\n         \\n        #日志格式设定\\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\\n        #$remote_user：用来记录客户端用户名称；\\n        #$time_local： 用来记录访问时间与时区；\\n        #$request： 用来记录请求的url与http协议；\\n        #$status： 用来记录请求状态；成功是200，\\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\\n        #$http_referer：用来记录从那个页面链接访问过来的；\\n        #$http_user_agent：记录客户浏览器的相关信息；\\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\\n        log_format access \'$remote_addr - $remote_user [$time_local] \\\"$request\\\" \'\\n        \'$status $body_bytes_sent \\\"$http_referer\\\" \'\\n        \'\\\"$http_user_agent\\\" $http_x_forwarded_for\';\\n         \\n        #定义本虚拟主机的访问日志\\n        access_log  /usr/local/nginx/logs/host.access.log  main;\\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\\n         \\n        #对 \\\"/connect-controller\\\" 启用反向代理\\n        location /connect-controller {\\n            proxy_pass http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）\\n            proxy_redirect off;\\n            proxy_set_header X-Real-IP $remote_addr;\\n             \\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n             \\n            #以下是一些反向代理的配置，可选。\\n            proxy_set_header Host $host;\\n\\n            #允许客户端请求的最大单文件字节数\\n            client_max_body_size 10m;\\n\\n            #缓冲区代理缓冲用户端请求的最大字节数，\\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\\n            client_body_buffer_size 128k;\\n\\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\\n            proxy_intercept_errors on;\\n\\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\\n            #nginx跟后端服务器连接超时时间(代理连接超时)\\n            proxy_connect_timeout 90;\\n\\n            #后端服务器数据回传时间(代理发送超时)\\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\\n            proxy_send_timeout 90;\\n\\n            #连接成功后，后端服务器响应时间(代理接收超时)\\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\\n            proxy_read_timeout 90;\\n\\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\\n            proxy_buffer_size 4k;\\n\\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\\n            proxy_buffers 4 32k;\\n\\n            #高负荷下缓冲大小（proxy_buffers*2）\\n            proxy_busy_buffers_size 64k;\\n\\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\\n            proxy_temp_file_write_size 64k;\\n        }\\n        \\n        #本地动静分离反向代理配置\\n        #所有jsp的页面均交由tomcat或resin处理\\n        location ~ .(jsp|jspx|do)?$ {\\n            proxy_set_header Host $host;\\n            proxy_set_header X-Real-IP $remote_addr;\\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n            proxy_pass http://127.0.0.1:8080;\\n        }\\n    }\\n}\\n```\\n\\n## 总结\\n\\nNginx 配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置）。\\n\\nmain 部分设置的指令影响其他所有部分的设置；\\n\\nserver 部分的指令主要用于制定虚拟主机域名、IP 和端口号；\\n\\nupstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；\\n\\nlocation 部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。\\n\\n他们之间的关系：server 继承 main，location 继承 server；upstream 既不会继承指令也不会被继承。\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/85eee7640539ffe9441828c685acf567.jpg\",\"articleTitle\":\"nginx基本使用\",\"categoryName\":\"运维\",\"id\":53,\"isTop\":1,\"originalUrl\":\"https://github.com/krislinzhao/StudyNotes\",\"status\":1,\"tagNameList\":[],\"type\":2}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:23:03', NULL);
INSERT INTO `t_operation_log` VALUES (770, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n```shell\\nattach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像\\n\\nbuild     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像\\n\\ncommit    Create a new image from a container changes   # 提交当前容器为新的镜像\\n\\ncp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中\\n\\ncreate    Create a new container                        # 创建一个新的容器，同 run，但不启动容器\\n\\ndiff      Inspect changes on a container\'s filesystem   # 查看 docker 容器变化\\n\\nevents    Get real time events from the server          # 从 docker 服务获取容器实时事件\\n\\nexec      Run a command in an existing container        # 在已存在的容器上运行命令\\n\\nexport    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\\n\\nhistory   Show the history of an image                  # 展示一个镜像形成历史\\n\\nimages    List images                                   # 列出系统当前镜像\\n\\nimport    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]\\n\\ninfo      Display system-wide information               # 显示系统相关信息\\n\\ninspect   Return low-level information on a container   # 查看容器详细信息\\n\\nkill      Kill a running container                      # kill 指定 docker 容器\\n\\nload      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]\\n\\nlogin     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器\\n\\nlogout    Log out from a Docker registry server          # 从当前 Docker registry 退出\\n\\nlogs      Fetch the logs of a container                 # 输出当前容器日志信息\\n\\nport      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口\\n\\npause     Pause all processes within a container        # 暂停容器\\n\\nps        List containers                               # 列出容器列表\\n\\npull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像\\n\\npush      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器\\n\\nrestart   Restart a running container                   # 重启运行的容器\\n\\nrm        Remove one or more containers                 # 移除一个或者多个容器\\n\\nrmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\\n\\nrun       Run a command in a new container              # 创建一个新的容器并运行一个命令\\n\\nsave      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 \\n\\nload]\\n\\nsearch    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像\\n\\nstart     Start a stopped containers                    # 启动容器\\n\\nstop      Stop a running containers                     # 停止容器\\n\\ntag       Tag an image into a repository                # 给源中镜像打标签\\n\\ntop       Lookup the running processes of a container   # 查看容器中运行的进程信息\\n\\nunpause   Unpause a paused container                    # 取消暂停容器\\n\\nversion   Show the docker version information           # 查看 docker 版本号\\n\\nwait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值\\n```\",\"articleCover\":\"https://static.jishudaniu.com/articles/495b49617f83556109b1dee076c22f31.jpg\",\"articleTitle\":\"Docker常用命令\",\"categoryName\":\"运维\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:42:03', NULL);
INSERT INTO `t_operation_log` VALUES (771, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n```shell\\n\\nattach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像\\n\\nbuild     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像\\n\\ncommit    Create a new image from a container changes   # 提交当前容器为新的镜像\\n\\ncp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中\\n\\ncreate    Create a new container                        # 创建一个新的容器，同 run，但不启动容器\\n\\ndiff      Inspect changes on a container\'s filesystem   # 查看 docker 容器变化\\n\\nevents    Get real time events from the server          # 从 docker 服务获取容器实时事件\\n\\nexec      Run a command in an existing container        # 在已存在的容器上运行命令\\n\\nexport    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\\n\\nhistory   Show the history of an image                  # 展示一个镜像形成历史\\n\\nimages    List images                                   # 列出系统当前镜像\\n\\nimport    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]\\n\\ninfo      Display system-wide information               # 显示系统相关信息\\n\\ninspect   Return low-level information on a container   # 查看容器详细信息\\n\\nkill      Kill a running container                      # kill 指定 docker 容器\\n\\nload      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]\\n\\nlogin     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器\\n\\nlogout    Log out from a Docker registry server          # 从当前 Docker registry 退出\\n\\nlogs      Fetch the logs of a container                 # 输出当前容器日志信息\\n\\nport      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口\\n\\npause     Pause all processes within a container        # 暂停容器\\n\\nps        List containers                               # 列出容器列表\\n\\npull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像\\n\\npush      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器\\n\\nrestart   Restart a running container                   # 重启运行的容器\\n\\nrm        Remove one or more containers                 # 移除一个或者多个容器\\n\\nrmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\\n\\nrun       Run a command in a new container              # 创建一个新的容器并运行一个命令\\n\\nsave      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 \\n\\nload]\\n\\nsearch    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像\\n\\nstart     Start a stopped containers                    # 启动容器\\n\\nstop      Stop a running containers                     # 停止容器\\n\\ntag       Tag an image into a repository                # 给源中镜像打标签\\n\\ntop       Lookup the running processes of a container   # 查看容器中运行的进程信息\\n\\nunpause   Unpause a paused container                    # 取消暂停容器\\n\\nversion   Show the docker version information           # 查看 docker 版本号\\n\\nwait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值\\n```\",\"articleCover\":\"https://static.jishudaniu.com/articles/495b49617f83556109b1dee076c22f31.jpg\",\"articleTitle\":\"Docker常用命令\",\"categoryName\":\"运维\",\"id\":54,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:43:18', NULL);
INSERT INTO `t_operation_log` VALUES (772, '分类模块', '新增或修改', '/admin/categories', 'com.jishudaniu.dkblog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"frontend\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:59:42', NULL);
INSERT INTO `t_operation_log` VALUES (773, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head文件引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```vue\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n</template>\\n\\n<script>\\nexport default {\\n}\\n</script>\\n\\n<style scoped>\\n\\n</style>\\n```\\n不是vue项目用template标签里的就行\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"集成APlayer+Meetingjs音乐播放器插件\",\"categoryName\":\"frontend\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 17:02:01', NULL);
INSERT INTO `t_operation_log` VALUES (774, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head文件引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```html\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n```\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"集成APlayer+Meetingjs音乐播放器插件\",\"categoryName\":\"frontend\",\"id\":55,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 17:04:02', NULL);
INSERT INTO `t_operation_log` VALUES (775, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head文件引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```html\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n```\\n左下角是效果\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"集成APlayer+Meetingjs音乐播放器插件\",\"categoryName\":\"frontend\",\"id\":55,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 17:05:57', NULL);
INSERT INTO `t_operation_log` VALUES (776, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"前段时间在github上面的脚本挂了（ps：打卡接口屏蔽了国外ip）），想着能不能搬到linux上去。然后配上我的学生机就开始了。\\n打卡api以我的自己为例\\n\\n```shell\\nhttps://fxgl.jx.edu.cn/高校id/public/homeQd?loginName=学号id&loginType=0\\n//把高校id和学号替换成自己的\\n```\\n| 学校名称                      | 学校标识码 | 所在地   |\\n| ----------------------------- | ---------- | -------- |\\n| 南昌大学                      | 4136010403 | 南昌市   |\\n| 华东交通大学                  | 4136010404 | 南昌市   |\\n| 东华理工大学                  | 4136010405 | 抚州市   |\\n| 南昌航空大学                  | 4136010406 | 南昌市   |\\n| 江西理工大学                  | 4136010407 | 赣州市   |\\n| 景德镇陶瓷大学                | 4136010408 | 景德镇市 |\\n| 江西农业大学                  | 4136010410 | 南昌市   |\\n| 江西中医药大学                | 4136010412 | 南昌市   |\\n| 赣南医学院                    | 4136010413 | 赣州市   |\\n| 江西师范大学                  | 4136010414 | 南昌市   |\\n| 上饶师范学院                  | 4136010416 | 上饶市   |\\n| 宜春学院                      | 4136010417 | 宜春市   |\\n| 赣南师范大学                  | 4136010418 | 赣州市   |\\n| 井冈山大学                    | 4136010419 | 吉安市   |\\n| 江西财经大学                  | 4136010421 | 南昌市   |\\n| 江西科技学院                  | 4136010846 | 南昌市   |\\n| 景德镇学院                    | 4136010894 | 景德镇市 |\\n| 萍乡学院                      | 4136010895 | 萍乡市   |\\n| 江西科技师范大学              | 4136011318 | 南昌市   |\\n| 南昌工程学院                  | 4136011319 | 南昌市   |\\n| 江西警察学院                  | 4136011504 | 南昌市   |\\n| 新余学院                      | 4136011508 | 新余市   |\\n| 九江学院                      | 4136011843 | 九江市   |\\n| 江西工程学院                  | 4136012766 | 新余市   |\\n| 南昌理工学院                  | 4136012795 | 南昌市   |\\n| 江西应用科技学院              | 4136012938 | 南昌市   |\\n| 江西服装学院                  | 4136013418 | 南昌市   |\\n| 南昌工学院                    | 4136013421 | 南昌市   |\\n| 南昌大学科学技术学院          | 4136013429 | 南昌市   |\\n| 南昌大学共青学院              | 4136013430 | 九江市   |\\n| 华东交通大学理工学院          | 4136013431 | 南昌市   |\\n| 东华理工大学长江学院          | 4136013432 | 抚州市   |\\n| 南昌航空大学科技学院          | 4136013433 | 南昌市   |\\n| 江西理工大学应用科学学院      | 4136013434 | 赣州市   |\\n| 景德镇陶瓷大学科技艺术学院    | 4136013435 | 景德镇市 |\\n| 江西农业大学南昌商学院        | 4136013436 | 南昌市   |\\n| 江西中医药大学科技学院        | 4136013437 | 南昌市   |\\n| 江西师范大学科学技术学院      | 4136013438 | 南昌市   |\\n| 赣南师范大学科技学院          | 4136013439 | 赣州市   |\\n| 江西科技师范大学理工学院      | 4136013440 | 南昌市   |\\n| 江西财经大学现代经济管理 学院 | 4136013441 | 南昌市   |\\n| 豫章师范学院                  | 4136013774 | 南昌市   |\\n| 南昌师范学院                  | 4136014437 | 南昌市   |\\n| 上饶幼儿师范高等专科学校      | 3636000312 | 上饶市   |\\n| 抚州幼儿师范高等专科学校      | 3636000519 | 抚州市   |\\n| 江西工业职业技术学院          | 4136010839 | 南昌市   |\\n| 江西医学高等专科学校          | 4136010888 | 上饶市   |\\n| 九江职业大学                  | 4136011505 | 九江市   |\\n| 九江职业技术学院              | 4136011785 | 九江市   |\\n| 江西司法警官职业学院          | 4136012929 | 南昌市   |\\n| 江西陶瓷工艺美术职业技术 学院 | 4136012930 | 景德镇市 |\\n| 江西旅游商贸职业学院          | 4136012932 | 南昌市   |\\n| 江西电力职业技术学院          | 4136012933 | 南昌市   |\\n| 江西环境工程职业学院          | 4136012934 | 赣州市   |\\n| 江西艺术职业学院              | 4136012936 | 南昌市   |\\n| 鹰潭职业技术学院              | 4136012937 | 鹰潭市   |\\n| 江西信息应用职业技术学院      | 4136012939 | 南昌市   |\\n| 江西交通职业技术学院          | 4136012940 | 南昌市   |\\n| 江西财经职业学院              | 4136012941 | 九江市   |\\n| 江西应用技术职业学院          | 4136012942 | 赣州市   |\\n| 江西现代职业技术学院          | 4136012943 | 南昌市   |\\n| 江西工业工程职业技术学院      | 4136012944 | 萍乡市   |\\n| 江西机电职业技术学院          | 4136012976 | 南昌市   |\\n| 江西科技职业学院              | 4136013419 | 南昌市   |\\n| 南昌职业学院                  | 4136013420 | 南昌市   |\\n| 江西外语外贸职业学院          | 4136013422 | 南昌市   |\\n| 江西工业贸易职业技术学院      | 4136013423 | 南昌市   |\\n| 宜春职业技术学院              | 4136013424 | 宜春市   |\\n| 江西应用工程职业学院          | 4136013425 | 萍乡市   |\\n| 江西生物科技职业学院          | 4136013426 | 南昌市   |\\n| 江西建设职业技术学院          | 4136013427 | 南昌市   |\\n| 抚州职业技术学院              | 4136013428 | 抚州市   |\\n| 江西中医药高等专科学校        | 4136013775 | 抚州市   |\\n| 江西先锋软件职业技术学院      | 4136013776 | 南昌市   |\\n| 江西经济管理职业学院          | 4136013866 | 南昌市   |\\n| 江西制造职业技术学院          | 4136013867 | 南昌市   |\\n| 江西工程职业学院              | 4136013868 | 南昌市   |\\n| 江西青年职业学院              | 4136013869 | 南昌市   |\\n| 上饶职业技术学院              | 4136013870 | 上饶市   |\\n| 江西航空职业技术学院          | 4136013871 | 南昌市   |\\n| 江西农业工程职业学院          | 4136013872 | 宜春市   |\\n| 赣西科技职业学院              | 4136013873 | 新余市   |\\n| 江西卫生职业学院              | 4136013965 | 南昌市   |\\n| 江西新能源科技职业学院        | 4136014166 | 新余市   |\\n| 江西枫林涉外经贸职业学院      | 4136014167 | 九江市   |\\n| 江西泰豪动漫职业学院          | 4136014168 | 南昌市   |\\n| 江西冶金职业技术学院          | 4136014241 | 新余市   |\\n| 江西管理职业学院              | 4136014249 | 南昌市   |\\n| 江西传媒职业学院              | 4136014250 | 南昌市   |\\n| 江西工商职业技术学院          | 4136014321 | 南昌市   |\\n| 景德镇陶瓷职业技术学院        | 4136014402 | 景德镇市 |\\n| 共青科技职业学院              | 4136014403 | 九江市   |\\n| 赣州师范高等专科学校          | 4136014465 | 赣州市   |\\n| 江西水利职业学院              | 4136014476 | 南昌市   |\\n| 宜春幼儿师范高等专科学校      | 4136014494 | 宜春市   |\\n| 吉安职业技术学院              | 4136014504 | 吉安市   |\\n| 江西洪州职业学院              | 4136014505 | 宜春市   |\\n| 江西师范高等专科学校          | 4136014537 | 鹰潭市   |\\n| 南昌影视传播职业学院          | 4136014544 | 南昌市   |\\n| 赣南卫生健康职业学院          | 4136014569 | 赣州市   |\\n\\n这里是江西的其他地区的自己百度，有些学校学号不等于id号。具体要自己查\\n\\n## linux操作\\n用ftp工具把文件上传，文件下载和配置[看这](看这)\\n用到python3和crontab安装:\\n```shell\\nyum install python3\\nyum install python3-pip\\nyum install crontabs\\npython3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py //查看打卡成不成功\\n```\\n\\n文件地址：\\n![](https://static-jsdn.oss-cn-shenzhen.aliyuncs.com/img/20220226174853.png)\\n命令：\\n```shell\\ncrontab –e //crontab脚本编辑文件\\n0 2 * * * python3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py\\n//每天晚上两点自动打卡，我自己的经常不打卡所以多设置几个比较好\\n```\\n\\n```shell\\ncrontab -l //检查\\nservice crond start //启动\\n```\",\"articleCover\":\"https://static.jishudaniu.com/articles/681d5410a7dda848709ac71f7d04ab63.jpg\",\"articleTitle\":\"高校支付宝自动打卡\",\"categoryName\":\"运维\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 18:09:03', NULL);
INSERT INTO `t_operation_log` VALUES (777, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head文件引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```html\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n```\\n左下角是效果\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"APlayer+Meetingjs音乐播放器\",\"categoryName\":\"frontend\",\"id\":55,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 19:20:49', NULL);
INSERT INTO `t_operation_log` VALUES (778, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"前段时间在github上面的脚本挂了（ps：打卡接口屏蔽了国外ip）），想着能不能搬到linux上去。然后配上我的学生机就开始了。\\n**打卡api：**\\n```shell\\nhttps://fxgl.jx.edu.cn/高校id/public/homeQd?loginName=学号id&loginType=0\\n//把高校id和学号替换成自己的\\n```\\n| 学校名称                      | 学校标识码 | 所在地   |\\n| ----------------------------- | ---------- | -------- |\\n| 南昌大学                      | 4136010403 | 南昌市   |\\n| 华东交通大学                  | 4136010404 | 南昌市   |\\n| 东华理工大学                  | 4136010405 | 抚州市   |\\n| 南昌航空大学                  | 4136010406 | 南昌市   |\\n| 江西理工大学                  | 4136010407 | 赣州市   |\\n| 景德镇陶瓷大学                | 4136010408 | 景德镇市 |\\n| 江西农业大学                  | 4136010410 | 南昌市   |\\n| 江西中医药大学                | 4136010412 | 南昌市   |\\n| 赣南医学院                    | 4136010413 | 赣州市   |\\n| 江西师范大学                  | 4136010414 | 南昌市   |\\n| 上饶师范学院                  | 4136010416 | 上饶市   |\\n| 宜春学院                      | 4136010417 | 宜春市   |\\n| 赣南师范大学                  | 4136010418 | 赣州市   |\\n| 井冈山大学                    | 4136010419 | 吉安市   |\\n| 江西财经大学                  | 4136010421 | 南昌市   |\\n| 江西科技学院                  | 4136010846 | 南昌市   |\\n| 景德镇学院                    | 4136010894 | 景德镇市 |\\n| 萍乡学院                      | 4136010895 | 萍乡市   |\\n| 江西科技师范大学              | 4136011318 | 南昌市   |\\n| 南昌工程学院                  | 4136011319 | 南昌市   |\\n| 江西警察学院                  | 4136011504 | 南昌市   |\\n| 新余学院                      | 4136011508 | 新余市   |\\n| 九江学院                      | 4136011843 | 九江市   |\\n| 江西工程学院                  | 4136012766 | 新余市   |\\n| 南昌理工学院                  | 4136012795 | 南昌市   |\\n| 江西应用科技学院              | 4136012938 | 南昌市   |\\n| 江西服装学院                  | 4136013418 | 南昌市   |\\n| 南昌工学院                    | 4136013421 | 南昌市   |\\n| 南昌大学科学技术学院          | 4136013429 | 南昌市   |\\n| 南昌大学共青学院              | 4136013430 | 九江市   |\\n| 华东交通大学理工学院          | 4136013431 | 南昌市   |\\n| 东华理工大学长江学院          | 4136013432 | 抚州市   |\\n| 南昌航空大学科技学院          | 4136013433 | 南昌市   |\\n| 江西理工大学应用科学学院      | 4136013434 | 赣州市   |\\n| 景德镇陶瓷大学科技艺术学院    | 4136013435 | 景德镇市 |\\n| 江西农业大学南昌商学院        | 4136013436 | 南昌市   |\\n| 江西中医药大学科技学院        | 4136013437 | 南昌市   |\\n| 江西师范大学科学技术学院      | 4136013438 | 南昌市   |\\n| 赣南师范大学科技学院          | 4136013439 | 赣州市   |\\n| 江西科技师范大学理工学院      | 4136013440 | 南昌市   |\\n| 江西财经大学现代经济管理 学院 | 4136013441 | 南昌市   |\\n| 豫章师范学院                  | 4136013774 | 南昌市   |\\n| 南昌师范学院                  | 4136014437 | 南昌市   |\\n| 上饶幼儿师范高等专科学校      | 3636000312 | 上饶市   |\\n| 抚州幼儿师范高等专科学校      | 3636000519 | 抚州市   |\\n| 江西工业职业技术学院          | 4136010839 | 南昌市   |\\n| 江西医学高等专科学校          | 4136010888 | 上饶市   |\\n| 九江职业大学                  | 4136011505 | 九江市   |\\n| 九江职业技术学院              | 4136011785 | 九江市   |\\n| 江西司法警官职业学院          | 4136012929 | 南昌市   |\\n| 江西陶瓷工艺美术职业技术 学院 | 4136012930 | 景德镇市 |\\n| 江西旅游商贸职业学院          | 4136012932 | 南昌市   |\\n| 江西电力职业技术学院          | 4136012933 | 南昌市   |\\n| 江西环境工程职业学院          | 4136012934 | 赣州市   |\\n| 江西艺术职业学院              | 4136012936 | 南昌市   |\\n| 鹰潭职业技术学院              | 4136012937 | 鹰潭市   |\\n| 江西信息应用职业技术学院      | 4136012939 | 南昌市   |\\n| 江西交通职业技术学院          | 4136012940 | 南昌市   |\\n| 江西财经职业学院              | 4136012941 | 九江市   |\\n| 江西应用技术职业学院          | 4136012942 | 赣州市   |\\n| 江西现代职业技术学院          | 4136012943 | 南昌市   |\\n| 江西工业工程职业技术学院      | 4136012944 | 萍乡市   |\\n| 江西机电职业技术学院          | 4136012976 | 南昌市   |\\n| 江西科技职业学院              | 4136013419 | 南昌市   |\\n| 南昌职业学院                  | 4136013420 | 南昌市   |\\n| 江西外语外贸职业学院          | 4136013422 | 南昌市   |\\n| 江西工业贸易职业技术学院      | 4136013423 | 南昌市   |\\n| 宜春职业技术学院              | 4136013424 | 宜春市   |\\n| 江西应用工程职业学院          | 4136013425 | 萍乡市   |\\n| 江西生物科技职业学院          | 4136013426 | 南昌市   |\\n| 江西建设职业技术学院          | 4136013427 | 南昌市   |\\n| 抚州职业技术学院              | 4136013428 | 抚州市   |\\n| 江西中医药高等专科学校        | 4136013775 | 抚州市   |\\n| 江西先锋软件职业技术学院      | 4136013776 | 南昌市   |\\n| 江西经济管理职业学院          | 4136013866 | 南昌市   |\\n| 江西制造职业技术学院          | 4136013867 | 南昌市   |\\n| 江西工程职业学院              | 4136013868 | 南昌市   |\\n| 江西青年职业学院              | 4136013869 | 南昌市   |\\n| 上饶职业技术学院              | 4136013870 | 上饶市   |\\n| 江西航空职业技术学院          | 4136013871 | 南昌市   |\\n| 江西农业工程职业学院          | 4136013872 | 宜春市   |\\n| 赣西科技职业学院              | 4136013873 | 新余市   |\\n| 江西卫生职业学院              | 4136013965 | 南昌市   |\\n| 江西新能源科技职业学院        | 4136014166 | 新余市   |\\n| 江西枫林涉外经贸职业学院      | 4136014167 | 九江市   |\\n| 江西泰豪动漫职业学院          | 4136014168 | 南昌市   |\\n| 江西冶金职业技术学院          | 4136014241 | 新余市   |\\n| 江西管理职业学院              | 4136014249 | 南昌市   |\\n| 江西传媒职业学院              | 4136014250 | 南昌市   |\\n| 江西工商职业技术学院          | 4136014321 | 南昌市   |\\n| 景德镇陶瓷职业技术学院        | 4136014402 | 景德镇市 |\\n| 共青科技职业学院              | 4136014403 | 九江市   |\\n| 赣州师范高等专科学校          | 4136014465 | 赣州市   |\\n| 江西水利职业学院              | 4136014476 | 南昌市   |\\n| 宜春幼儿师范高等专科学校      | 4136014494 | 宜春市   |\\n| 吉安职业技术学院              | 4136014504 | 吉安市   |\\n| 江西洪州职业学院              | 4136014505 | 宜春市   |\\n| 江西师范高等专科学校          | 4136014537 | 鹰潭市   |\\n| 南昌影视传播职业学院          | 4136014544 | 南昌市   |\\n| 赣南卫生健康职业学院          | 4136014569 | 赣州市   |\\n\\n这里是江西的其他地区的自己百度，有些学校学号不等于id号。具体要自己查\\n\\n## linux操作\\n用ftp工具把文件上传，文件下载和配置[看这](看这)\\n用到python3和crontab安装:\\n```shell\\nyum install python3\\nyum install python3-pip\\nyum install crontabs\\npython3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py //查看打卡成不成功\\n```\\n\\n**文件地址：**\\n![](https://static-jsdn.oss-cn-shenzhen.aliyuncs.com/img/20220226174853.png)\\n命令：\\n```shell\\ncrontab –e //crontab脚本编辑文件\\n0 2 * * * python3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py\\n//每天晚上两点自动打卡，我自己的经常不打卡所以多设置几个比较好\\n```\\n\\n```shell\\ncrontab -l //检查\\nservice crond start //启动\\n```\",\"articleCover\":\"https://static.jishudaniu.com/articles/681d5410a7dda848709ac71f7d04ab63.jpg\",\"articleTitle\":\"高校支付宝自动打卡\",\"categoryName\":\"运维\",\"id\":56,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 23:52:57', NULL);
INSERT INTO `t_operation_log` VALUES (779, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head中引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```html\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n```\\n左下角是效果\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"APlayer+Meetingjs音乐播放器\",\"categoryName\":\"frontend\",\"id\":55,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 23:54:18', NULL);
INSERT INTO `t_operation_log` VALUES (780, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[16]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:20', NULL);
INSERT INTO `t_operation_log` VALUES (781, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[15]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:22', NULL);
INSERT INTO `t_operation_log` VALUES (782, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[14]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:24', NULL);
INSERT INTO `t_operation_log` VALUES (783, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[13]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:26', NULL);
INSERT INTO `t_operation_log` VALUES (784, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[12]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:27', NULL);
INSERT INTO `t_operation_log` VALUES (785, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[11]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:28', NULL);
INSERT INTO `t_operation_log` VALUES (786, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[10]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:30', NULL);
INSERT INTO `t_operation_log` VALUES (787, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[2]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:35', NULL);
INSERT INTO `t_operation_log` VALUES (788, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[4]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:37', NULL);
INSERT INTO `t_operation_log` VALUES (789, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[5]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:40', NULL);
INSERT INTO `t_operation_log` VALUES (790, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[3]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:41', NULL);
INSERT INTO `t_operation_log` VALUES (791, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[22]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:49', NULL);
INSERT INTO `t_operation_log` VALUES (792, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[20]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:51', NULL);
INSERT INTO `t_operation_log` VALUES (793, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[18]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:54', NULL);
INSERT INTO `t_operation_log` VALUES (794, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[17]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:55', NULL);
INSERT INTO `t_operation_log` VALUES (795, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[9]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:57', NULL);
INSERT INTO `t_operation_log` VALUES (796, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[8]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:59', NULL);
INSERT INTO `t_operation_log` VALUES (797, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[7]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:39:02', NULL);
INSERT INTO `t_operation_log` VALUES (798, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[6]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:39:05', NULL);
INSERT INTO `t_operation_log` VALUES (799, '分类模块', '新增或修改', '/admin/categories', 'com.jishudaniu.dkblog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"backend\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-03 01:13:41', NULL);
INSERT INTO `t_operation_log` VALUES (800, '标签模块', '新增或修改', '/admin/tags', 'com.jishudaniu.dkblog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"SpringBoot\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-03 01:28:16', NULL);
INSERT INTO `t_operation_log` VALUES (801, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"**1、启动类里面使用@EnableScheduling 注解开启功能，自动扫描：**\\n\\n\\n\\n```java\\n@SpringBootApplication\\n@EnableScheduling //开启定时任务\\npublic class MainApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(MainApplication.class, args);\\n    }\\n}\\n```\\n\\n**3、新建一个Job类：**\\n\\n> - 要在任务的类上写@Component\\n> - 要在任务方法上写@Scheduled\\n\\n\\n\\n```java\\nimport org.springframework.scheduling.annotation.Scheduled;\\nimport org.springframework.stereotype.Component;\\n\\nimport java.util.Date;\\n\\n\\n@Component\\npublic class Jobs {\\n    //表示方法执行完成后5秒\\n    @Scheduled(fixedDelay = 5000)\\n    public void fixedDelayJob() throws InterruptedException {\\n        System.out.println(\\\"fixedDelay 每隔5秒\\\" + new Date());\\n    }\\n\\n    //表示每隔3秒\\n    @Scheduled(fixedRate = 3000)\\n    public void fixedRateJob() {\\n\\n        System.out.println(\\\"fixedRate 每隔3秒\\\" + new Date());\\n    }\\n\\n    //表示每天8时30分0秒执行\\n    @Scheduled(cron = \\\"0 0,30 0,8 ? * ? \\\")\\n    public void cronJob() {\\n        System.out.println(new Date() + \\\" ...>>cron....\\\");\\n    }\\n}\\n```\\n\\n*执行结果如下：*\\n\\n\\n\\n```css\\nfixedRate 每隔3秒Thu Jun 20 20:26:41 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:43 CST 2019\\nfixedRate 每隔3秒Thu Jun 20 20:26:44 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:48 CST 2019\\n```\\n\\n## 三、总结\\n\\n> - fixedDelay和fixedRate，单位是毫秒，这里这里就是5秒和3秒，它们的区别就是：fixedRate就是每多次分钟一次，不论你业务执行花费了多少时间。我都是1分钟执行1次，而fixedDelay是当任务执行完毕后1分钟在执行。所以根据实际业务不同，可以选择不同的方式。\\n> - cron表达式：比如你要设置每天什么时候执行，就可以用它\\n>    cron表达式，有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。\\n>    cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：\\n\\n\\n\\n```undefined\\n* 第一位，表示秒，取值0-59\\n* 第二位，表示分，取值0-59\\n* 第三位，表示小时，取值0-23\\n* 第四位，日期天/日，取值1-31\\n* 第五位，日期月份，取值1-12\\n* 第六位，星期，取值1-7，星期一，星期二...，注：不是第1周，第二周的意思\\n          另外：1表示星期天，2表示星期一。\\n* 第7为，年份，可以留空，取值1970-2099\\n```\\n\\n> cron中，还有一些特殊的符号，含义如下：\\n\\n\\n\\n```jsx\\n(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...\\n(?)问号：问号只能出现在日期和星期这两个位置。\\n(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12\\n(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四\\n(/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*/y，等同于0/y\\n```\\n\\n> 下面列举几个例子供大家来验证：\\n\\n\\n\\n```bash\\n0 0 3 * * ?     每天3点执行\\n0 5 3 * * ?     每天3点5分执行\\n0 5 3 ? * *     每天3点5分执行，与上面作用相同\\n0 5/10 3 * * ?  每天3点的 5分，15分，25分，35分，45分，55分这几个时间点执行\\n0 10 3 ? * 1    每周星期天，3点10分 执行，注：1表示星期天    \\n0 10 3 ? * 1#3  每个月的第三个星期，星期天 执行，#号只能出现在星期的位置\\n```\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/193a084cdf280332dd5e156ddd0433d0.jpg\",\"articleTitle\":\"SpringBoot启动定时任务\",\"categoryName\":\"backend\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-03 01:31:14', NULL);
INSERT INTO `t_operation_log` VALUES (802, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"**1、启动类里面使用@EnableScheduling 注解开启功能，自动扫描：**\\n\\n\\n\\n```java\\n@SpringBootApplication\\n@EnableScheduling //开启定时任务\\npublic class MainApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(MainApplication.class, args);\\n    }\\n}\\n```\\n\\n**3、新建一个Job类：**\\n\\n> - 要在任务的类上写@Component\\n> - 要在任务方法上写@Scheduled\\n\\n\\n\\n```java\\nimport org.springframework.scheduling.annotation.Scheduled;\\nimport org.springframework.stereotype.Component;\\n\\nimport java.util.Date;\\n\\n\\n@Component\\npublic class Jobs {\\n    //表示方法执行完成后5秒\\n    @Scheduled(fixedDelay = 5000)\\n    public void fixedDelayJob() throws InterruptedException {\\n        System.out.println(\\\"fixedDelay 每隔5秒\\\" + new Date());\\n    }\\n\\n    //表示每隔3秒\\n    @Scheduled(fixedRate = 3000)\\n    public void fixedRateJob() {\\n\\n        System.out.println(\\\"fixedRate 每隔3秒\\\" + new Date());\\n    }\\n\\n    //表示每天8时30分0秒执行\\n    @Scheduled(cron = \\\"0 0,30 0,8 ? * ? \\\")\\n    public void cronJob() {\\n        System.out.println(new Date() + \\\" ...>>cron....\\\");\\n    }\\n}\\n```\\n\\n*执行结果如下：*\\n\\n\\n\\n```css\\nfixedRate 每隔3秒Thu Jun 20 20:26:41 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:43 CST 2019\\nfixedRate 每隔3秒Thu Jun 20 20:26:44 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:48 CST 2019\\n```\\n\\n## 三、总结\\n\\n> - fixedDelay和fixedRate，单位是毫秒，这里这里就是5秒和3秒，它们的区别就是：fixedRate就是每多次分钟一次，不论你业务执行花费了多少时间。我都是1分钟执行1次，而fixedDelay是当任务执行完毕后1分钟在执行。所以根据实际业务不同，可以选择不同的方式。\\n> - cron表达式：比如你要设置每天什么时候执行，就可以用它\\n>    cron表达式，有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。\\n>    cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：\\n\\n\\n\\n```undefined\\n* 第一位，表示秒，取值0-59\\n* 第二位，表示分，取值0-59\\n* 第三位，表示小时，取值0-23\\n* 第四位，日期天/日，取值1-31\\n* 第五位，日期月份，取值1-12\\n* 第六位，星期，取值1-7，星期一，星期二...，注：不是第1周，第二周的意思\\n          另外：1表示星期天，2表示星期一。\\n* 第7为，年份，可以留空，取值1970-2099\\n```\\n\\n> cron中，还有一些特殊的符号，含义如下：\\n\\n\\n\\n```bash\\n(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...\\n(?)问号：问号只能出现在日期和星期这两个位置。\\n(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12\\n(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四\\n(/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*/y，等同于0/y\\n```\\n\\n> 下面列举几个例子供大家来验证：\\n\\n\\n\\n```bash\\n0 0 3 * * ?     每天3点执行\\n0 5 3 * * ?     每天3点5分执行\\n0 5 3 ? * *     每天3点5分执行，与上面作用相同\\n0 5/10 3 * * ?  每天3点的 5分，15分，25分，35分，45分，55分这几个时间点执行\\n0 10 3 ? * 1    每周星期天，3点10分 执行，注：1表示星期天    \\n0 10 3 ? * 1#3  每个月的第三个星期，星期天 执行，#号只能出现在星期的位置\\n```\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/193a084cdf280332dd5e156ddd0433d0.jpg\",\"articleTitle\":\"SpringBoot启动定时任务\",\"categoryName\":\"backend\",\"id\":57,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-03 01:46:50', NULL);
INSERT INTO `t_operation_log` VALUES (803, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## 1、启动类里面使用@EnableScheduling 注解开启功能，自动扫描：\\n\\n\\n\\n```java\\n@SpringBootApplication\\n@EnableScheduling //开启定时任务\\npublic class MainApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(MainApplication.class, args);\\n    }\\n}\\n```\\n\\n## 2、新建一个Job类：\\n\\n> - 要在任务的类上写@Component\\n> - 要在任务方法上写@Scheduled\\n\\n\\n\\n```java\\nimport org.springframework.scheduling.annotation.Scheduled;\\nimport org.springframework.stereotype.Component;\\n\\nimport java.util.Date;\\n\\n\\n@Component\\npublic class Jobs {\\n    //表示方法执行完成后5秒\\n    @Scheduled(fixedDelay = 5000)\\n    public void fixedDelayJob() throws InterruptedException {\\n        System.out.println(\\\"fixedDelay 每隔5秒\\\" + new Date());\\n    }\\n\\n    //表示每隔3秒\\n    @Scheduled(fixedRate = 3000)\\n    public void fixedRateJob() {\\n\\n        System.out.println(\\\"fixedRate 每隔3秒\\\" + new Date());\\n    }\\n\\n    //表示每天8时30分0秒执行\\n    @Scheduled(cron = \\\"0 0,30 0,8 ? * ? \\\")\\n    public void cronJob() {\\n        System.out.println(new Date() + \\\" ...>>cron....\\\");\\n    }\\n}\\n```\\n\\n*执行结果如下：*\\n\\n\\n\\n```css\\nfixedRate 每隔3秒Thu Jun 20 20:26:41 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:43 CST 2019\\nfixedRate 每隔3秒Thu Jun 20 20:26:44 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:48 CST 2019\\n```\\n\\n## 3、总结\\n\\n> - fixedDelay和fixedRate，单位是毫秒，这里这里就是5秒和3秒，它们的区别就是：fixedRate就是每多次分钟一次，不论你业务执行花费了多少时间。我都是1分钟执行1次，而fixedDelay是当任务执行完毕后1分钟在执行。所以根据实际业务不同，可以选择不同的方式。\\n> - cron表达式：比如你要设置每天什么时候执行，就可以用它\\n>    cron表达式，有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。\\n>    cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：\\n\\n\\n\\n```html\\n* 第一位，表示秒，取值0-59\\n* 第二位，表示分，取值0-59\\n* 第三位，表示小时，取值0-23\\n* 第四位，日期天/日，取值1-31\\n* 第五位，日期月份，取值1-12\\n* 第六位，星期，取值1-7，星期一，星期二...，注：不是第1周，第二周的意思\\n          另外：1表示星期天，2表示星期一。\\n* 第7为，年份，可以留空，取值1970-2099\\n```\\n\\n> cron中，还有一些特殊的符号，含义如下：\\n\\n\\n\\n```bash\\n(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...\\n(?)问号：问号只能出现在日期和星期这两个位置。\\n(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12\\n(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四\\n(/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*/y，等同于0/y\\n```\\n\\n> 下面列举几个例子供大家来验证：\\n\\n\\n\\n```bash\\n0 0 3 * * ?     每天3点执行\\n0 5 3 * * ?     每天3点5分执行\\n0 5 3 ? * *     每天3点5分执行，与上面作用相同\\n0 5/10 3 * * ?  每天3点的 5分，15分，25分，35分，45分，55分这几个时间点执行\\n0 10 3 ? * 1    每周星期天，3点10分 执行，注：1表示星期天    \\n0 10 3 ? * 1#3  每个月的第三个星期，星期天 执行，#号只能出现在星期的位置\\n```\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/193a084cdf280332dd5e156ddd0433d0.jpg\",\"articleTitle\":\"SpringBoot启动定时任务\",\"categoryName\":\"backend\",\"id\":57,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-03 01:50:53', NULL);
INSERT INTO `t_operation_log` VALUES (804, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head中引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```html\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n```\\n左下角是效果\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"APlayer音乐播放器\",\"categoryName\":\"frontend\",\"id\":55,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.173.156', '江西省吉安市 电信', '2022-03-03 12:51:49', NULL);
INSERT INTO `t_operation_log` VALUES (805, '标签模块', '新增或修改', '/admin/tags', 'com.jishudaniu.dkblog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"daily\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.116', '江西省吉安市 电信', '2022-03-06 17:20:05', NULL);
INSERT INTO `t_operation_log` VALUES (806, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"### 资源不在于多而在于精，分享一些常用的\\n\\n#### 开源项目：\\n\\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\\n2. [github全球最大的代码托管平台](https://github.com)\\n3. [gitee中国最大的托管平台](https://gitee.com)\\n4. https://sourceforge.net/\\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\\n\\n#### 疑难杂症解决：\\n\\n1. [google](https://www.google.com/)\\n2. [stackoverflow（一般只要你会搜bug都能解决）](https://www.stackoverflow.com/)\\n3. [baidu](https://www.baidu.com/)\\n4. [b乎（人均985，211）](https://www.zhihu.com/)\\n5. [简书质量一直可以](https://www.jianshu.com/)\\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\\n7. https://www.csdn.net/\\n8. [稀土掘金](https://juejin.cn/)\\n9. [b站](https://bilibili.com/)\\n\\n#### 素材:\\n\\n1. [jQuery插件库](https://www.iconfont.cn/)\\n2. https://pixabay.com/zh/\\n3. https://unsplash.com/\\n4. http://www.pexels.com/\\n5. https://gitmind.cn/app/doc/d74790416\\n6. https://zhutix.com/ico/gang-chrome/\\n\\n#### 在线设计类:\\n\\n1. [在线PS](https://www.uupoop.com/#/old)\\n2. [在线音频剪辑](https://www.weixinsyt.com/)\\n3. [在线视频剪辑](https://www.kapwing.com/)\\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\\n\\n#### 在线编程:\\n\\n1. https://jsrun.net/\\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\\n3. [编程中国](https://www.bccn.net/)\\n\\n####  学习网站:\\n\\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\\n4. [CodeGym](https://codegym.cc/)\\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg\",\"articleTitle\":\"个人收藏网站分享\",\"categoryName\":\"backend\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.116', '江西省吉安市 电信', '2022-03-06 17:21:54', NULL);
INSERT INTO `t_operation_log` VALUES (807, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"### 资源不在于多而在于精，分享一些常用的\\n\\n#### 开源项目：\\n\\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\\n2. [github全球最大的代码托管平台](https://github.com)\\n3. [gitee中国最大的托管平台](https://gitee.com)\\n4. https://sourceforge.net/\\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\\n\\n#### 疑难杂症解决：\\n\\n1. [google](https://www.google.com/)\\n2. [stackoverflow（一般只要你会搜bug都能解决）](https://www.stackoverflow.com/)\\n3. [baidu](https://www.baidu.com/)\\n4. [b乎](https://www.zhihu.com/)\\n5. [简书质量一直可以](https://www.jianshu.com/)\\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\\n7. https://www.csdn.net/\\n8. [稀土掘金](https://juejin.cn/)\\n9. [b站](https://bilibili.com/)\\n\\n#### 素材:\\n\\n1. [jQuery插件库](https://www.iconfont.cn/)\\n2. https://pixabay.com/zh/\\n3. https://unsplash.com/\\n4. http://www.pexels.com/\\n5. https://gitmind.cn/app/doc/d74790416\\n6. https://zhutix.com/ico/gang-chrome/\\n\\n#### 在线设计类:\\n\\n1. [在线PS](https://www.uupoop.com/#/old)\\n2. [在线音频剪辑](https://www.weixinsyt.com/)\\n3. [在线视频剪辑](https://www.kapwing.com/)\\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\\n\\n#### 在线编程:\\n\\n1. https://jsrun.net/\\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\\n3. [编程中国](https://www.bccn.net/)\\n\\n####  学习网站:\\n\\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\\n4. [CodeGym](https://codegym.cc/)\\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg\",\"articleTitle\":\"个人收藏网站分享\",\"categoryName\":\"backend\",\"id\":58,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.116', '江西省吉安市 电信', '2022-03-06 21:35:20', NULL);
INSERT INTO `t_operation_log` VALUES (808, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"### 资源不在于多而在于精，分享一些常用的\\n\\n#### 开源项目：\\n\\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\\n2. [github全球最大的代码托管平台](https://github.com)\\n3. [gitee中国最大的托管平台](https://gitee.com)\\n4. https://sourceforge.net/\\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\\n\\n#### 疑难杂症解决：\\n\\n1. [google](https://www.google.com/)\\n2. [stackoverflow（一般只要你会搜bug都能解决）](https://www.stackoverflow.com/)\\n3. [baidu](https://www.baidu.com/)\\n4. [b乎](https://www.zhihu.com/)\\n5. [简书质量一直可以](https://www.jianshu.com/)\\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\\n7. https://www.csdn.net/\\n8. [稀土掘金](https://juejin.cn/)\\n9. [b站](https://bilibili.com/)\\n\\n#### 素材:\\n\\n1. [jQuery插件库](https://www.iconfont.cn/)\\n2. https://pixabay.com/zh/\\n3. https://unsplash.com/\\n4. http://www.pexels.com/\\n5. https://gitmind.cn/app/doc/d74790416\\n6. https://zhutix.com/ico/gang-chrome/\\n\\n#### 在线设计类:\\n\\n1. [在线PS](https://www.uupoop.com/#/old)\\n2. [在线音频剪辑](https://www.weixinsyt.com/)\\n3. [在线视频剪辑](https://www.kapwing.com/)\\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\\n\\n#### 在线编程:\\n\\n1. https://jsrun.net/\\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\\n3. [编程中国](https://www.bccn.net/)\\n\\n####  学习网站:\\n\\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\\n4. [CodeGym](https://codegym.cc/)\\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg\",\"articleTitle\":\"个人收藏网站分享\",\"categoryName\":\"backend\",\"id\":58,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.116', '江西省吉安市 电信', '2022-03-06 21:35:42', NULL);
INSERT INTO `t_operation_log` VALUES (809, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"### 资源不在于多而在于精，分享一些常用的\\n\\n#### 开源项目：\\n\\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\\n2. [github全球最大的代码托管平台](https://github.com)\\n3. [gitee中国最大的托管平台](https://gitee.com)\\n4. https://sourceforge.net/\\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\\n\\n#### 疑难杂症解决：\\n\\n1. [google](https://www.google.com/)\\n2. [stackoverflow（一般只要你会搜bug都能解决）](https://www.stackoverflow.com/)\\n3. [baidu](https://www.baidu.com/)\\n4. [b乎](https://www.zhihu.com/)\\n5. [简书质量一直可以](https://www.jianshu.com/)\\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\\n7. https://www.csdn.net/\\n8. [稀土掘金](https://juejin.cn/)\\n9. [b站](https://bilibili.com/)\\n\\n#### 素材:\\n\\n1. [jQuery插件库](https://www.iconfont.cn/)\\n2. https://pixabay.com/zh/\\n3. https://unsplash.com/\\n4. http://www.pexels.com/\\n5. https://gitmind.cn/app/doc/d74790416\\n6. https://zhutix.com/ico/gang-chrome/\\n\\n#### 在线设计类:\\n\\n1. [在线PS](https://www.uupoop.com/#/old)\\n2. [在线音频剪辑](https://www.weixinsyt.com/)\\n3. [在线视频剪辑](https://www.kapwing.com/)\\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\\n\\n#### 在线编程:\\n\\n1. https://jsrun.net/\\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\\n3. [编程中国](https://www.bccn.net/)\\n\\n####  学习网站:\\n\\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\\n4. [CodeGym](https://codegym.cc/)\\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg\",\"articleTitle\":\"个人收藏网站分享\",\"categoryName\":\"backend\",\"id\":58,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.168.31', '江西省吉安市 电信', '2022-03-07 01:37:56', NULL);
INSERT INTO `t_operation_log` VALUES (810, '文章模块', '修改', '/admin/articles/top', 'com.jishudaniu.dkblog.controller.ArticleController.updateArticleTop', '修改文章置顶', '[{\"id\":53,\"isTop\":0}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.168.31', '江西省吉安市 电信', '2022-03-07 01:38:16', NULL);
INSERT INTO `t_operation_log` VALUES (811, '文章模块', '修改', '/admin/articles/top', 'com.jishudaniu.dkblog.controller.ArticleController.updateArticleTop', '修改文章置顶', '[{\"id\":58,\"isTop\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.168.31', '江西省吉安市 电信', '2022-03-07 01:38:18', NULL);
INSERT INTO `t_operation_log` VALUES (812, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 部署服务器\\n\\n## 安装mysql\\n\\nrpm -qa|grep mysql #无输出说明没有安装\\n\\n### 下载和安装mysql源\\n\\nwget [https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm](https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fget%2Fmysql80-community-release-el7-3.noarch.rpm)\\n\\n### 安装mysql源\\n\\n```\\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\\n```\\n\\n### 查看mysql相关资源\\n\\n```\\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\\n```\\n\\n如果没有安装yum-config-manager 需要安装yum -y install yum-utils\\n\\n选择mysql版本:\\n\\n/*使用MySQL Yum Repository安装MySQL，默认会选择当前最新的稳定版本\\n\\n使用命令：yum repolist all | grep mysql，查看当前yum repolist的所有版本*/\\n\\n```\\nyum repolist all | grep mysql\\n```\\n\\n### 切换版本\\n\\n```\\nsudo yum-config-manager --disable mysql80-community\\n\\nsudo yum-config-manager --enable mysql57-community\\n```\\n\\n### 安装mysql:\\n\\n该命令会安装MySQL服务器 (mysql-community-server) 及其所需的依赖、相关组件，包括mysql-community-client、mysql-community-common、mysql-community-libs等。安装时间会比较长\\n\\n```\\nsudo yum install mysql-community-server\\n```\\n\\n### 启动Mysql\\n\\n```\\nsystemctl start mysqld.service\\n\\nsystemctl status mysqld.service\\n```\\n\\n### 停止Mysql\\n\\n```\\nsystemctl stop mysqld.service\\n```\\n\\n### 重启Mysql\\n\\n```\\nsystemctl restart mysqld.service\\n```\\n\\n### 初始密码\\n\\nMySQL第一次启动后会创建超级管理员账号root@localhost，初始密码存储在日志文件中：\\n\\n```\\ngrep \'temporary password\' /var/log/mysqld.log\\n```\\n\\n### 进入mysql客户端\\n\\nmysql -u root  -p\\n\\n输入上面的临时密码password\\n\\n### 修改默认密码\\n\\n```\\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'admin123\'\\n```\\n\\n### 设置开机启动\\n\\n```\\nsystemctl enable mysqld\\n\\nsystemctl daemon-reload\\n\\n```\\n\\n### 开放远程连接\\n\\n```\\nmysql>use mysql;\\n\\nmsyql>update user set user.Host=\'%\' where user.User=\'root\';\\n\\nmysql>flush privileges;\\n```\\n\\n## 安装JDK\\n\\n自行百度\\n\\n推荐清华镜像源jdk8\\n\\n```\\nwget https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_openj9_linuxXL_8u282b08_openj9-0.24.0.tar.gz\\n```\\n\\n### 配置环境变量\\n\\nvim /etc/profile\\n\\nshift+G划到底部 添加环境变量\\n\\n```\\nexport JAVA_HOME= **YOUR_JAVA_PATH**\\nexport JRE_HOME=$JAVA_HOME/jre\\nexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib\\nexport PATH=$JAVA_HOME/bin:$PATH\\n```\\n\\n刷新\\n\\n```\\nsource /etc/profile\\n\\njava -version\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/29ccc97d96ac3a7abb8d8e13dea450d4.jpg\",\"articleTitle\":\"mysql安装配置\",\"categoryName\":\"运维\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.168.31', '江西省吉安市 电信', '2022-03-07 02:27:50', NULL);
INSERT INTO `t_operation_log` VALUES (813, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 部署服务器\\n\\n## 安装mysql\\n\\nrpm -qa|grep mysql #无输出说明没有安装\\n\\n### 下载和安装mysql源\\n\\nwget [https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm](https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fget%2Fmysql80-community-release-el7-3.noarch.rpm)\\n\\n### 安装mysql源\\n\\n``` shell\\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\\n```\\n\\n### 查看mysql相关资源\\n\\n``` shell\\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\\n```\\n\\n如果没有安装yum-config-manager 需要安装yum -y install yum-utils\\n\\n选择mysql版本:\\n\\n/*使用MySQL Yum Repository安装MySQL，默认会选择当前最新的稳定版本\\n\\n使用命令：yum repolist all | grep mysql，查看当前yum repolist的所有版本*/\\n\\n``` shell\\nyum repolist all | grep mysql\\n```\\n\\n### 切换版本\\n\\n``` shell\\nsudo yum-config-manager --disable mysql80-community\\n\\nsudo yum-config-manager --enable mysql57-community\\n```\\n\\n### 安装mysql:\\n\\n该命令会安装MySQL服务器 (mysql-community-server) 及其所需的依赖、相关组件，包括mysql-community-client、mysql-community-common、mysql-community-libs等。安装时间会比较长\\n\\n``` shell\\nsudo yum install mysql-community-server\\n```\\n\\n### 启动Mysql\\n\\n``` shell\\nsystemctl start mysqld.service\\n\\nsystemctl status mysqld.service\\n```\\n\\n### 停止Mysql\\n\\n``` shell\\nsystemctl stop mysqld.service\\n```\\n\\n### 重启Mysql\\n\\n``` shell\\nsystemctl restart mysqld.service\\n```\\n\\n### 初始密码\\n\\nMySQL第一次启动后会创建超级管理员账号root@localhost，初始密码存储在日志文件中：\\n\\n``` shell\\ngrep \'temporary password\' /var/log/mysqld.log\\n```\\n\\n### 进入mysql客户端\\n\\nmysql -u root  -p\\n\\n输入上面的临时密码password\\n\\n### 修改默认密码\\n\\n``` shell\\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'admin123\'\\n```\\n\\n### 设置开机启动\\n\\n``` shell\\nsystemctl enable mysqld\\n\\nsystemctl daemon-reload\\n\\n```\\n\\n### 开放远程连接\\n\\n``` shell\\nmysql>use mysql;\\n\\nmsyql>update user set user.Host=\'%\' where user.User=\'root\';\\n\\nmysql>flush privileges;\\n```\\n\\n## 安装JDK\\n\\n自行百度\\n\\n推荐清华镜像源jdk8\\n\\n``` shell\\nwget https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_openj9_linuxXL_8u282b08_openj9-0.24.0.tar.gz\\n```\\n\\n### 配置环境变量\\n\\nvim /etc/profile\\n\\nshift+G划到底部 添加环境变量\\n\\n``` shell\\nexport JAVA_HOME= **YOUR_JAVA_PATH**\\nexport JRE_HOME=$JAVA_HOME/jre\\nexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib\\nexport PATH=$JAVA_HOME/bin:$PATH\\n```\\n\\n刷新\\n\\n``` shell\\nsource /etc/profile\\n\\njava -version\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/29ccc97d96ac3a7abb8d8e13dea450d4.jpg\",\"articleTitle\":\"mysql安装配置\",\"categoryName\":\"运维\",\"id\":59,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.168.31', '江西省吉安市 电信', '2022-03-07 18:05:52', NULL);
INSERT INTO `t_operation_log` VALUES (814, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\nSpringApplication.run(Application.class, args);\\n\\n}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\t\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  System.out.println(\\\"DemoController.hello()\\\");\\n\\n  map.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  //会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  return\\\"/hello\\\";\\n\\n}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### 三. JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### 四. springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 五、全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\nSpring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\n[http://localhost/](http://localhost/bbtForum.do?method=listBoardTopic&topicId=1&userId=10&userName=tom)[itxxzSpring4](http://localhost/bbtForum.do?method=listBoardTopic&id=1&userId=10&userName=tom)method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/itxxzSpring4?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如\\n\\n```java \\n@Scope(\\\"session\\\")\\n@Repository()\\npublic class UserSessionBean implementsSerializable {} \\n```\\n\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n​    @Scope中可以指定如下值：\\n​    singleton:定义bean的范围为每个spring容器一个实例（默认值）\\n​    prototype:定义bean可以被多次实例化（使用一次就创建一次）\\n​    request:定义bean的范围是http请求（springMVC中有效）\\n​    session:定义bean的范围是http会话（springMVC中有效）\\n​    global-session:定义bean的范围是全局http会话（portlet中有效） \\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n\\n#### @Required\\n\\n• 例如\\n\\n```java\\n@required       \\npublic setName(String name){}\\n\\n```\\n\\n\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring全家桶注解汇总\",\"categoryName\":\"backend\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-15 19:38:48', NULL);
INSERT INTO `t_operation_log` VALUES (815, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\nSpring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如\\n\\n```java \\n@Scope(\\\"session\\\")\\n@Repository()\\npublic class UserSessionBean implementsSerializable {} \\n```\\n\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n    @Scope中可以指定如下值：\\n    singleton:定义bean的范围为每个spring容器一个实例（默认值）\\n    prototype:定义bean可以被多次实例化（使用一次就创建一次）\\n    request:定义bean的范围是http请求（springMVC中有效）\\n    session:定义bean的范围是http会话（springMVC中有效）\\n    global-session:定义bean的范围是全局http会话（portlet中有效） \\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n\\n#### @Required\\n\\n• 例如\\n\\n```java\\n@required       \\npublic setName(String name){}\\n\\n```\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring全家桶注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-15 20:32:24', NULL);
INSERT INTO `t_operation_log` VALUES (816, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"Springboot注解\\n\\n一、注解(annotations)列表 @ApiOperation\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n二、注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n\\n\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\nSpringApplication.run(Application.class, args);\\n\\n}\\n\\n}\\n\\n\\n\\n \\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n@RequestMapping(“/test”)\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\nreturn”ok”;\\n\\n}\\n\\n \\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n\\n\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n   System.out.println(\\\"DemoController.hello()\\\");\\n\\n   map.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n   //会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n   return\\\"/hello\\\";\\n\\n}\\n\\n}\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n\\n\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n   return\\\"ok\\\";\\n\\n}\\n\\n}\\n\\n\\n\\n \\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n三、JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。\\n\\n四、springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n五、全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\nSpring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n（1）@Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n（2）@Service\\n\\n• 例如\\n  @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n（3）@Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n（4）@RequestMapping\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\") 本文来自www.itxxz.com \\npublic class BbtForumController {\\n             @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n  • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n  • 说明\\n    @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/itxxzSpring4?method=listBoardTopic&topicId=1&userId=10&userName=tom copyright www.itxxz.com \\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n（5）@RequestParam\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/itxxzSpring4?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n            默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n            既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n            内部包含了 request 对象\\n\\n• java.util.Locale \\n            绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n                可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n            可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n            被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n            它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ） 本文来自www.itxxz.com \\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n             它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n             而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n             为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n            可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\nOwner owner = this.clinic.loadOwner(ownerId);\\nmodel.addAttribute(owner);\\nreturn \\\"ownerForm\\\";\\n\\n}\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n（6）@ModelAttribute\\n• 作用域：request\\n • 例如\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){\\n\\n• 或者\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n（7）@Cacheable 和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n（8）@Resource\\n\\n• 例如\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n • 或者\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n（9）@PostConstruct 和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n\\n（10）@Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式：  @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n（11）@Scope\\n• 例如\\n@Scope(\\\"session\\\")\\n@Repository()\\npublic class UserSessionBean implementsSerializable {} \\n\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n       @Scope中可以指定如下值：\\n       singleton:定义bean的范围为每个spring容器一个实例（默认值）\\n       prototype:定义bean可以被多次实例化（使用一次就创建一次）\\n       request:定义bean的范围是http请求（springMVC中有效）\\n       session:定义bean的范围是http会话（springMVC中有效）\\n       global-session:定义bean的范围是全局http会话（portlet中有效） \\n\\n（12）@SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n（13）@InitBinder \\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n\\nSimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\ndateFormat.setLenient(false);\\nbinder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n\\n（14）@Required\\n• 例如\\n @required             \\npublic  setName(String name){}\\n• 说明 copyright www.itxxz.com \\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如\\n@Autowired\\n @Qualifier(\\\"softService\\\")\\nprivate ISoftPMService softPMService;\\n \\n\\n \\n\\n \\n\\n \\n\\n下面是其他注解，包括组合注解\\n（1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下：\\n@ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码；\\n@ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping   和  @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上；\\n2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态\\n（5）@RequestParam，@PathParam，@PathVariable等注解区别\\n@RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务\\n@PathParam：绑定一个路径段资源的方法参数的值\\n@QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法.\\n@HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数\\n@CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数\\n@MatrixParam：用来绑定包含多个   property (属性)=value(值)   方法参数表达式\\n\\n \\n\\n \\n\\n \\n\\nMybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。 \\n\\n@SelectProvider(type = TestSqlProvider.class, method = \\\"getSql\\\") ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(\\\"select * from ....\\\")注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。 \\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。 \\n\\n@Results(value = { \\n@Result(id = true, property = \\\"id\\\", column = \\\"test_id\\\",javaType = String.class, jdbcType = JdbcType.VARCHAR), \\n@Result(property = \\\"testText\\\", column = \\\"test_text\\\",javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = \\\"id\\\", column =\\\"test_id\\\", javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = \\\"id\\\", column = \\\"test_id\\\")，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。 \\n\\n@Param(\\\"id\\\") ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3....的形式，而是对应名称，该名称就在这里定义。 \\n\\n@ResultMap(value = \\\"getByTestText\\\") ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =\\\"getByTestText\\\"，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = \\\"insertSql\\\") ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。 \\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。 \\n\\n@UpdateProvider(type = TestSqlProvider.class, method = \\\"updateSql\\\") ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。 \\n\\n@Param(\\\"testBean\\\") ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。 \\n\\n@DeleteProvider(type = TestSqlProvider.class, method = \\\"deleteSql\\\") ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。 \\n\\n \\n\\nSpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上\\n*用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中\\n*一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(\\\"name\\\")，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List<EasyUITreeNode> getItemTreeNode(@RequestParam(value=\\\"id\\\",defaultValue=\\\"0\\\")long parentId)\\n\\n(4) @Controller\\n控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示\\n(5) @RequestMapping\\nRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired\\n@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource\\n\\n@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes\\n代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n @SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n \\n\\n(8) @PathVariable\\n用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam\\n@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(\\\"name\\\")，它有三个常用参数：defaultValue = \\\"0\\\", required = false, value = \\\"isApp\\\"；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component\\n相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository\\n用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring全家桶注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-15 20:40:23', NULL);
INSERT INTO `t_operation_log` VALUES (817, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\nSpring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n@Scope中可以指定如下值：\\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\\nrequest:定义bean的范围是http请求（springMVC中有效）\\nsession:定义bean的范围是http会话（springMVC中有效）\\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n（14）@Required • 例如 @required\\npublic setName(String name){} • 说明 copyright www.itxxz.com\\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\\n\\n下面是其他注解，包括组合注解 （1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\\n\\n### Mybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\\n\\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\\n\\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\\n\\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\\n\\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\\n\\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\\n\\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\\n\\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\\n\\n### SpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\\n\\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n@SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository 用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"ssm框架注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-15 23:59:29', NULL);
INSERT INTO `t_operation_log` VALUES (818, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\nSpring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n@Scope中可以指定如下值：\\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\\nrequest:定义bean的范围是http请求（springMVC中有效）\\nsession:定义bean的范围是http会话（springMVC中有效）\\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n（14）@Required • 例如 @required\\npublic setName(String name){} • 说明 copyright www.itxxz.com\\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\\n\\n下面是其他注解，包括组合注解 （1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\\n\\n### Mybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\\n\\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\\n\\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\\n\\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\\n\\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\\n\\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\\n\\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\\n\\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\\n\\n### SpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\\n\\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n@SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository 用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring家族注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-16 00:35:49', NULL);
INSERT INTO `t_operation_log` VALUES (819, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\n### Spring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n@Scope中可以指定如下值：\\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\\nrequest:定义bean的范围是http请求（springMVC中有效）\\nsession:定义bean的范围是http会话（springMVC中有效）\\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n（14）@Required • 例如 @required\\npublic setName(String name){} • 说明 copyright www.itxxz.com\\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\\n\\n下面是其他注解，包括组合注解 （1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\\n\\n### Mybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\\n\\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\\n\\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\\n\\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\\n\\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\\n\\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\\n\\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\\n\\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\\n\\n### SpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\\n\\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n@SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository 用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring家族注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-16 00:39:41', NULL);
INSERT INTO `t_operation_log` VALUES (820, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\n### Spring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n@Scope中可以指定如下值：\\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\\nrequest:定义bean的范围是http请求（springMVC中有效）\\nsession:定义bean的范围是http会话（springMVC中有效）\\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n（14）@Required • 例如 @required\\npublic setName(String name){} • 说明 \\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\\n\\n下面是其他注解，包括组合注解 （1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\\n\\n### Mybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\\n\\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\\n\\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\\n\\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\\n\\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\\n\\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\\n\\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\\n\\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\\n\\n### SpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\\n\\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n@SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository 用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring家族注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-16 00:42:09', NULL);
INSERT INTO `t_operation_log` VALUES (821, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\n### Spring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n```java\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\n \\tpublic String listBoardTopic(int topicId,User user) {}\\n}\\n```\\n • 方法\\n```java\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n```\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n@Scope中可以指定如下值：\\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\\nrequest:定义bean的范围是http请求（springMVC中有效）\\nsession:定义bean的范围是http会话（springMVC中有效）\\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n（14）@Required • 例如 @required\\npublic setName(String name){} • 说明 \\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\\n\\n下面是其他注解，包括组合注解 （1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\\n\\n### Mybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\\n\\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\\n\\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\\n\\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\\n\\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\\n\\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\\n\\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\\n\\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\\n\\n### SpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\\n\\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n@SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository 用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring家族注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-16 00:47:39', NULL);
INSERT INTO `t_operation_log` VALUES (822, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"### 资源不在于多而在于精，分享一些常用的\\n\\n#### 开源项目：\\n\\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\\n2. [github全球最大的代码托管平台](https://github.com)\\n3. [gitee中国最大的托管平台](https://gitee.com)\\n4. https://sourceforge.net/\\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\\n\\n#### 疑难杂症解决：\\n\\n1. [google](https://www.google.com/)\\n2. [stackoverflow（解决bug的好去处）](https://www.stackoverflow.com/)\\n3. [baidu](https://www.baidu.com/)\\n4. [b乎](https://www.zhihu.com/)\\n5. [简书质量一直可以](https://www.jianshu.com/)\\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\\n7. https://www.csdn.net/\\n8. [稀土掘金](https://juejin.cn/)\\n9. [b站](https://bilibili.com/)\\n\\n#### 素材:\\n\\n1. [jQuery插件库](https://www.iconfont.cn/)\\n2. https://pixabay.com/zh/\\n3. https://unsplash.com/\\n4. http://www.pexels.com/\\n5. https://gitmind.cn/app/doc/d74790416\\n6. https://zhutix.com/ico/gang-chrome/\\n\\n#### 在线设计类:\\n\\n1. [在线PS](https://www.uupoop.com/#/old)\\n2. [在线音频剪辑](https://www.weixinsyt.com/)\\n3. [在线视频剪辑](https://www.kapwing.com/)\\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\\n\\n#### 在线编程:\\n\\n1. https://jsrun.net/\\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\\n3. [编程中国](https://www.bccn.net/)\\n\\n####  学习网站:\\n\\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\\n4. [CodeGym](https://codegym.cc/)\\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg\",\"articleTitle\":\"个人收藏网站分享\",\"categoryName\":\"backend\",\"id\":58,\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '119.32.47.238', '广东省广州市 联通', '2022-03-20 15:28:51', NULL);

-- ----------------------------
-- Table structure for t_page
-- ----------------------------
DROP TABLE IF EXISTS `t_page`;
CREATE TABLE `t_page`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '页面id',
  `page_name` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '页面名',
  `page_label` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '页面标签',
  `page_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '页面封面',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 903 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '页面' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_page
-- ----------------------------
INSERT INTO `t_page` VALUES (1, '首页', 'home', '', '2021-08-07 10:32:36', '2021-10-04 15:42:46');
INSERT INTO `t_page` VALUES (2, '归档', 'archive', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:43:14');
INSERT INTO `t_page` VALUES (3, '分类', 'category', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:43:31');
INSERT INTO `t_page` VALUES (4, '标签', 'tag', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:43:38');
INSERT INTO `t_page` VALUES (5, '相册', 'album', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:43:53');
INSERT INTO `t_page` VALUES (6, '友链', 'link', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:44:02');
INSERT INTO `t_page` VALUES (7, '关于', 'about', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:44:08');
INSERT INTO `t_page` VALUES (8, '留言', 'message', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:44:17');
INSERT INTO `t_page` VALUES (9, '个人中心', 'user', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:45:17');
INSERT INTO `t_page` VALUES (10, '文章列表', 'articleList', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-10 15:36:19', '2021-10-04 15:45:45');

-- ----------------------------
-- Table structure for t_photo
-- ----------------------------
DROP TABLE IF EXISTS `t_photo`;
CREATE TABLE `t_photo`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_id` int NOT NULL COMMENT '相册id',
  `photo_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片名',
  `photo_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '照片描述',
  `photo_src` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片地址',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '照片' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_photo
-- ----------------------------

-- ----------------------------
-- Table structure for t_photo_album
-- ----------------------------
DROP TABLE IF EXISTS `t_photo_album`;
CREATE TABLE `t_photo_album`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册名',
  `album_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册描述',
  `album_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册封面',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态值 1公开 2私密',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '相册' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_photo_album
-- ----------------------------

-- ----------------------------
-- Table structure for t_resource
-- ----------------------------
DROP TABLE IF EXISTS `t_resource`;
CREATE TABLE `t_resource`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '资源名',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '权限路径',
  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '请求方式',
  `parent_id` int NULL DEFAULT NULL COMMENT '父权限id',
  `is_anonymous` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否匿名访问 0否 1是',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 280 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_resource
-- ----------------------------
INSERT INTO `t_resource` VALUES (165, '分类模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (166, '博客信息模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (167, '友链模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (168, '文章模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (169, '日志模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (170, '标签模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (171, '照片模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (172, '用户信息模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (173, '用户账号模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (174, '留言模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (175, '相册模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (176, '菜单模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (177, '角色模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (178, '评论模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (179, '资源模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (180, '页面模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (181, '查看博客信息', '/', 'GET', 166, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:29');
INSERT INTO `t_resource` VALUES (182, '查看关于我信息', '/about', 'GET', 166, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:29');
INSERT INTO `t_resource` VALUES (183, '查看后台信息', '/admin', 'GET', 166, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (184, '修改关于我信息', '/admin/about', 'PUT', 166, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (185, '查看后台文章', '/admin/articles', 'GET', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (186, '添加或修改文章', '/admin/articles', 'POST', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (187, '恢复或删除文章', '/admin/articles', 'PUT', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (188, '物理删除文章', '/admin/articles', 'DELETE', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (189, '上传文章图片', '/admin/articles/images', 'POST', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (190, '修改文章置顶', '/admin/articles/top', 'PUT', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (191, '根据id查看后台文章', '/admin/articles/*', 'GET', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (192, '查看后台分类列表', '/admin/categories', 'GET', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (193, '添加或修改分类', '/admin/categories', 'POST', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (194, '删除分类', '/admin/categories', 'DELETE', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (195, '搜索文章分类', '/admin/categories/search', 'GET', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (196, '查询后台评论', '/admin/comments', 'GET', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (197, '删除评论', '/admin/comments', 'DELETE', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (198, '审核评论', '/admin/comments/review', 'PUT', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (199, '查看后台友链列表', '/admin/links', 'GET', 167, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (200, '保存或修改友链', '/admin/links', 'POST', 167, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (201, '删除友链', '/admin/links', 'DELETE', 167, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (202, '查看菜单列表', '/admin/menus', 'GET', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (203, '新增或修改菜单', '/admin/menus', 'POST', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (204, '删除菜单', '/admin/menus/*', 'DELETE', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (205, '查看后台留言列表', '/admin/messages', 'GET', 174, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (206, '删除留言', '/admin/messages', 'DELETE', 174, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (207, '审核留言', '/admin/messages/review', 'PUT', 174, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (208, '查看操作日志', '/admin/operation/logs', 'GET', 169, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (209, '删除操作日志', '/admin/operation/logs', 'DELETE', 169, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (210, '获取页面列表', '/admin/pages', 'GET', 180, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (211, '保存或更新页面', '/admin/pages', 'POST', 180, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (212, '删除页面', '/admin/pages/*', 'DELETE', 180, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (213, '根据相册id获取照片列表', '/admin/photos', 'GET', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (214, '保存照片', '/admin/photos', 'POST', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (215, '更新照片信息', '/admin/photos', 'PUT', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (216, '删除照片', '/admin/photos', 'DELETE', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (217, '移动照片相册', '/admin/photos/album', 'PUT', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (218, '查看后台相册列表', '/admin/photos/albums', 'GET', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (219, '保存或更新相册', '/admin/photos/albums', 'POST', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (220, '上传相册封面', '/admin/photos/albums/cover', 'POST', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (221, '获取后台相册列表信息', '/admin/photos/albums/info', 'GET', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (222, '根据id删除相册', '/admin/photos/albums/*', 'DELETE', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (223, '根据id获取后台相册信息', '/admin/photos/albums/*/info', 'GET', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (224, '更新照片删除状态', '/admin/photos/delete', 'PUT', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (225, '查看资源列表', '/admin/resources', 'GET', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (226, '新增或修改资源', '/admin/resources', 'POST', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (227, '导入swagger接口', '/admin/resources/import/swagger', 'GET', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (228, '删除资源', '/admin/resources/*', 'DELETE', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (229, '保存或更新角色', '/admin/role', 'POST', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (230, '查看角色菜单选项', '/admin/role/menus', 'GET', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (231, '查看角色资源选项', '/admin/role/resources', 'GET', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (232, '查询角色列表', '/admin/roles', 'GET', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (233, '删除角色', '/admin/roles', 'DELETE', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (234, '查询后台标签列表', '/admin/tags', 'GET', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (235, '添加或修改标签', '/admin/tags', 'POST', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (236, '删除标签', '/admin/tags', 'DELETE', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (237, '搜索文章标签', '/admin/tags/search', 'GET', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (238, '查看当前用户菜单', '/admin/user/menus', 'GET', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (239, '查询后台用户列表', '/admin/users', 'GET', 173, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (240, '修改用户禁用状态', '/admin/users/disable', 'PUT', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (241, '查看在线用户', '/admin/users/online', 'GET', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (242, '修改管理员密码', '/admin/users/password', 'PUT', 173, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (243, '查询用户角色选项', '/admin/users/role', 'GET', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (244, '修改用户角色', '/admin/users/role', 'PUT', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (245, '下线用户', '/admin/users/*/online', 'DELETE', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (246, '获取网站配置', '/admin/website/config', 'GET', 166, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (247, '更新网站配置', '/admin/website/config', 'PUT', 166, 0, '2021-08-11 21:04:22', '2022-02-21 21:49:14');
INSERT INTO `t_resource` VALUES (248, '根据相册id查看照片列表', '/albums/*/photos', 'GET', 171, 1, '2021-08-11 21:04:22', '2021-08-11 21:06:35');
INSERT INTO `t_resource` VALUES (249, '查看首页文章', '/articles', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:45');
INSERT INTO `t_resource` VALUES (250, '查看文章归档', '/articles/archives', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:47');
INSERT INTO `t_resource` VALUES (251, '根据条件查询文章', '/articles/condition', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:47');
INSERT INTO `t_resource` VALUES (252, '搜索文章', '/articles/search', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:48');
INSERT INTO `t_resource` VALUES (253, '根据id查看文章', '/articles/*', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:49');
INSERT INTO `t_resource` VALUES (254, '点赞文章', '/articles/*/like', 'POST', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (255, '查看分类列表', '/categories', 'GET', 165, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:26');
INSERT INTO `t_resource` VALUES (256, '查询评论', '/comments', 'GET', 178, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:33');
INSERT INTO `t_resource` VALUES (257, '添加评论', '/comments', 'POST', 178, 0, '2021-08-11 21:04:22', '2021-08-11 21:10:05');
INSERT INTO `t_resource` VALUES (258, '评论点赞', '/comments/*/like', 'POST', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (259, '查询评论下的回复', '/comments/*/replies', 'GET', 178, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:30');
INSERT INTO `t_resource` VALUES (260, '查看友链列表', '/links', 'GET', 167, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:41');
INSERT INTO `t_resource` VALUES (261, '查看留言列表', '/messages', 'GET', 174, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:14');
INSERT INTO `t_resource` VALUES (262, '添加留言', '/messages', 'POST', 174, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:15');
INSERT INTO `t_resource` VALUES (263, '获取相册列表', '/photos/albums', 'GET', 175, 0, '2021-08-11 21:04:22', '2022-02-21 21:48:50');
INSERT INTO `t_resource` VALUES (264, '用户注册', '/register', 'POST', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:01');
INSERT INTO `t_resource` VALUES (265, '查询标签列表', '/tags', 'GET', 170, 1, '2021-08-11 21:04:22', '2021-08-11 21:06:30');
INSERT INTO `t_resource` VALUES (267, '更新用户头像', '/users/avatar', 'POST', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (268, '发送邮箱验证码', '/users/code', 'GET', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:02');
INSERT INTO `t_resource` VALUES (269, '绑定用户邮箱', '/users/email', 'POST', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (270, '更新用户信息', '/users/info', 'PUT', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (271, 'qq登录', '/users/oauth/qq', 'POST', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:06');
INSERT INTO `t_resource` VALUES (272, '微博登录', '/users/oauth/weibo', 'POST', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:06');
INSERT INTO `t_resource` VALUES (273, '修改密码', '/users/password', 'PUT', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:09');
INSERT INTO `t_resource` VALUES (274, '上传语音', '/voice', 'POST', 166, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:33');
INSERT INTO `t_resource` VALUES (275, '上传访客信息', '/report', 'POST', 166, 1, '2021-08-24 11:24:08', '2021-08-24 11:24:10');
INSERT INTO `t_resource` VALUES (276, '获取用户区域分布', '/admin/users/area', 'GET', 173, 0, '2021-08-24 11:24:33', NULL);
INSERT INTO `t_resource` VALUES (277, '获取最新文章', '/newest/articlelist', 'GET', 168, 1, '2022-02-05 01:51:31', '2022-02-11 22:10:50');
INSERT INTO `t_resource` VALUES (279, '获取最热文章', '/hottest/articlelist', 'GET', 168, 1, '2022-02-11 22:11:49', '2022-02-11 22:12:06');

-- ----------------------------
-- Table structure for t_role
-- ----------------------------
DROP TABLE IF EXISTS `t_role`;
CREATE TABLE `t_role`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色名',
  `role_label` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色描述',
  `is_disable` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否禁用  0否 1是',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_role
-- ----------------------------
INSERT INTO `t_role` VALUES (1, '管理员', 'admin', 0, '2021-03-22 14:10:21', '2021-08-24 11:25:30');
INSERT INTO `t_role` VALUES (2, '用户', 'user', 0, '2021-03-22 14:25:25', '2021-08-11 21:12:21');
INSERT INTO `t_role` VALUES (3, '测试', 'test', 0, '2021-03-22 14:42:23', '2021-08-24 11:25:39');

-- ----------------------------
-- Table structure for t_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `t_role_menu`;
CREATE TABLE `t_role_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  `menu_id` int NULL DEFAULT NULL COMMENT '菜单id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2310 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_role_menu
-- ----------------------------
INSERT INTO `t_role_menu` VALUES (1397, 8, 1);
INSERT INTO `t_role_menu` VALUES (1398, 8, 2);
INSERT INTO `t_role_menu` VALUES (1399, 8, 6);
INSERT INTO `t_role_menu` VALUES (1400, 8, 7);
INSERT INTO `t_role_menu` VALUES (1401, 8, 8);
INSERT INTO `t_role_menu` VALUES (1402, 8, 9);
INSERT INTO `t_role_menu` VALUES (1403, 8, 10);
INSERT INTO `t_role_menu` VALUES (1404, 8, 3);
INSERT INTO `t_role_menu` VALUES (1405, 8, 11);
INSERT INTO `t_role_menu` VALUES (1406, 8, 12);
INSERT INTO `t_role_menu` VALUES (1407, 8, 202);
INSERT INTO `t_role_menu` VALUES (1408, 8, 13);
INSERT INTO `t_role_menu` VALUES (1409, 8, 14);
INSERT INTO `t_role_menu` VALUES (1410, 8, 201);
INSERT INTO `t_role_menu` VALUES (1411, 8, 4);
INSERT INTO `t_role_menu` VALUES (1412, 8, 16);
INSERT INTO `t_role_menu` VALUES (1413, 8, 15);
INSERT INTO `t_role_menu` VALUES (1414, 8, 17);
INSERT INTO `t_role_menu` VALUES (1415, 8, 18);
INSERT INTO `t_role_menu` VALUES (1416, 8, 19);
INSERT INTO `t_role_menu` VALUES (1417, 8, 20);
INSERT INTO `t_role_menu` VALUES (1418, 8, 5);
INSERT INTO `t_role_menu` VALUES (1595, 9, 1);
INSERT INTO `t_role_menu` VALUES (1596, 9, 2);
INSERT INTO `t_role_menu` VALUES (1597, 9, 6);
INSERT INTO `t_role_menu` VALUES (1598, 9, 7);
INSERT INTO `t_role_menu` VALUES (1599, 9, 8);
INSERT INTO `t_role_menu` VALUES (1600, 9, 9);
INSERT INTO `t_role_menu` VALUES (1601, 9, 10);
INSERT INTO `t_role_menu` VALUES (1602, 9, 3);
INSERT INTO `t_role_menu` VALUES (1603, 9, 11);
INSERT INTO `t_role_menu` VALUES (1604, 9, 12);
INSERT INTO `t_role_menu` VALUES (1605, 9, 202);
INSERT INTO `t_role_menu` VALUES (1606, 9, 13);
INSERT INTO `t_role_menu` VALUES (1607, 9, 14);
INSERT INTO `t_role_menu` VALUES (1608, 9, 201);
INSERT INTO `t_role_menu` VALUES (1609, 9, 4);
INSERT INTO `t_role_menu` VALUES (1610, 9, 16);
INSERT INTO `t_role_menu` VALUES (1611, 9, 15);
INSERT INTO `t_role_menu` VALUES (1612, 9, 17);
INSERT INTO `t_role_menu` VALUES (1613, 9, 18);
INSERT INTO `t_role_menu` VALUES (1614, 9, 19);
INSERT INTO `t_role_menu` VALUES (1615, 9, 20);
INSERT INTO `t_role_menu` VALUES (1616, 9, 5);
INSERT INTO `t_role_menu` VALUES (1639, 13, 2);
INSERT INTO `t_role_menu` VALUES (1640, 13, 6);
INSERT INTO `t_role_menu` VALUES (1641, 13, 7);
INSERT INTO `t_role_menu` VALUES (1642, 13, 8);
INSERT INTO `t_role_menu` VALUES (1643, 13, 9);
INSERT INTO `t_role_menu` VALUES (1644, 13, 10);
INSERT INTO `t_role_menu` VALUES (1645, 13, 3);
INSERT INTO `t_role_menu` VALUES (1646, 13, 11);
INSERT INTO `t_role_menu` VALUES (1647, 13, 12);
INSERT INTO `t_role_menu` VALUES (2252, 1, 1);
INSERT INTO `t_role_menu` VALUES (2253, 1, 2);
INSERT INTO `t_role_menu` VALUES (2254, 1, 6);
INSERT INTO `t_role_menu` VALUES (2255, 1, 7);
INSERT INTO `t_role_menu` VALUES (2256, 1, 8);
INSERT INTO `t_role_menu` VALUES (2257, 1, 9);
INSERT INTO `t_role_menu` VALUES (2258, 1, 10);
INSERT INTO `t_role_menu` VALUES (2259, 1, 3);
INSERT INTO `t_role_menu` VALUES (2260, 1, 11);
INSERT INTO `t_role_menu` VALUES (2261, 1, 12);
INSERT INTO `t_role_menu` VALUES (2262, 1, 202);
INSERT INTO `t_role_menu` VALUES (2263, 1, 13);
INSERT INTO `t_role_menu` VALUES (2264, 1, 201);
INSERT INTO `t_role_menu` VALUES (2265, 1, 213);
INSERT INTO `t_role_menu` VALUES (2266, 1, 14);
INSERT INTO `t_role_menu` VALUES (2267, 1, 15);
INSERT INTO `t_role_menu` VALUES (2268, 1, 16);
INSERT INTO `t_role_menu` VALUES (2269, 1, 4);
INSERT INTO `t_role_menu` VALUES (2270, 1, 214);
INSERT INTO `t_role_menu` VALUES (2271, 1, 209);
INSERT INTO `t_role_menu` VALUES (2272, 1, 17);
INSERT INTO `t_role_menu` VALUES (2273, 1, 18);
INSERT INTO `t_role_menu` VALUES (2274, 1, 205);
INSERT INTO `t_role_menu` VALUES (2275, 1, 206);
INSERT INTO `t_role_menu` VALUES (2276, 1, 208);
INSERT INTO `t_role_menu` VALUES (2277, 1, 210);
INSERT INTO `t_role_menu` VALUES (2278, 1, 19);
INSERT INTO `t_role_menu` VALUES (2279, 1, 20);
INSERT INTO `t_role_menu` VALUES (2280, 1, 5);
INSERT INTO `t_role_menu` VALUES (2281, 3, 1);
INSERT INTO `t_role_menu` VALUES (2282, 3, 2);
INSERT INTO `t_role_menu` VALUES (2283, 3, 6);
INSERT INTO `t_role_menu` VALUES (2284, 3, 7);
INSERT INTO `t_role_menu` VALUES (2285, 3, 8);
INSERT INTO `t_role_menu` VALUES (2286, 3, 9);
INSERT INTO `t_role_menu` VALUES (2287, 3, 10);
INSERT INTO `t_role_menu` VALUES (2288, 3, 3);
INSERT INTO `t_role_menu` VALUES (2289, 3, 11);
INSERT INTO `t_role_menu` VALUES (2290, 3, 12);
INSERT INTO `t_role_menu` VALUES (2291, 3, 202);
INSERT INTO `t_role_menu` VALUES (2292, 3, 13);
INSERT INTO `t_role_menu` VALUES (2293, 3, 201);
INSERT INTO `t_role_menu` VALUES (2294, 3, 213);
INSERT INTO `t_role_menu` VALUES (2295, 3, 14);
INSERT INTO `t_role_menu` VALUES (2296, 3, 15);
INSERT INTO `t_role_menu` VALUES (2297, 3, 16);
INSERT INTO `t_role_menu` VALUES (2298, 3, 4);
INSERT INTO `t_role_menu` VALUES (2299, 3, 214);
INSERT INTO `t_role_menu` VALUES (2300, 3, 209);
INSERT INTO `t_role_menu` VALUES (2301, 3, 17);
INSERT INTO `t_role_menu` VALUES (2302, 3, 18);
INSERT INTO `t_role_menu` VALUES (2303, 3, 205);
INSERT INTO `t_role_menu` VALUES (2304, 3, 206);
INSERT INTO `t_role_menu` VALUES (2305, 3, 208);
INSERT INTO `t_role_menu` VALUES (2306, 3, 210);
INSERT INTO `t_role_menu` VALUES (2307, 3, 19);
INSERT INTO `t_role_menu` VALUES (2308, 3, 20);
INSERT INTO `t_role_menu` VALUES (2309, 3, 5);

-- ----------------------------
-- Table structure for t_role_resource
-- ----------------------------
DROP TABLE IF EXISTS `t_role_resource`;
CREATE TABLE `t_role_resource`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  `resource_id` int NULL DEFAULT NULL COMMENT '权限id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4193 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_role_resource
-- ----------------------------
INSERT INTO `t_role_resource` VALUES (4011, 2, 254);
INSERT INTO `t_role_resource` VALUES (4012, 2, 267);
INSERT INTO `t_role_resource` VALUES (4013, 2, 269);
INSERT INTO `t_role_resource` VALUES (4014, 2, 270);
INSERT INTO `t_role_resource` VALUES (4015, 2, 257);
INSERT INTO `t_role_resource` VALUES (4016, 2, 258);
INSERT INTO `t_role_resource` VALUES (4076, 1, 165);
INSERT INTO `t_role_resource` VALUES (4077, 1, 192);
INSERT INTO `t_role_resource` VALUES (4078, 1, 193);
INSERT INTO `t_role_resource` VALUES (4079, 1, 194);
INSERT INTO `t_role_resource` VALUES (4080, 1, 195);
INSERT INTO `t_role_resource` VALUES (4081, 1, 166);
INSERT INTO `t_role_resource` VALUES (4082, 1, 183);
INSERT INTO `t_role_resource` VALUES (4083, 1, 184);
INSERT INTO `t_role_resource` VALUES (4084, 1, 246);
INSERT INTO `t_role_resource` VALUES (4085, 1, 247);
INSERT INTO `t_role_resource` VALUES (4086, 1, 167);
INSERT INTO `t_role_resource` VALUES (4087, 1, 199);
INSERT INTO `t_role_resource` VALUES (4088, 1, 200);
INSERT INTO `t_role_resource` VALUES (4089, 1, 201);
INSERT INTO `t_role_resource` VALUES (4090, 1, 168);
INSERT INTO `t_role_resource` VALUES (4091, 1, 185);
INSERT INTO `t_role_resource` VALUES (4092, 1, 186);
INSERT INTO `t_role_resource` VALUES (4093, 1, 187);
INSERT INTO `t_role_resource` VALUES (4094, 1, 188);
INSERT INTO `t_role_resource` VALUES (4095, 1, 189);
INSERT INTO `t_role_resource` VALUES (4096, 1, 190);
INSERT INTO `t_role_resource` VALUES (4097, 1, 191);
INSERT INTO `t_role_resource` VALUES (4098, 1, 254);
INSERT INTO `t_role_resource` VALUES (4099, 1, 169);
INSERT INTO `t_role_resource` VALUES (4100, 1, 208);
INSERT INTO `t_role_resource` VALUES (4101, 1, 209);
INSERT INTO `t_role_resource` VALUES (4102, 1, 170);
INSERT INTO `t_role_resource` VALUES (4103, 1, 234);
INSERT INTO `t_role_resource` VALUES (4104, 1, 235);
INSERT INTO `t_role_resource` VALUES (4105, 1, 236);
INSERT INTO `t_role_resource` VALUES (4106, 1, 237);
INSERT INTO `t_role_resource` VALUES (4107, 1, 171);
INSERT INTO `t_role_resource` VALUES (4108, 1, 213);
INSERT INTO `t_role_resource` VALUES (4109, 1, 214);
INSERT INTO `t_role_resource` VALUES (4110, 1, 215);
INSERT INTO `t_role_resource` VALUES (4111, 1, 216);
INSERT INTO `t_role_resource` VALUES (4112, 1, 217);
INSERT INTO `t_role_resource` VALUES (4113, 1, 224);
INSERT INTO `t_role_resource` VALUES (4114, 1, 172);
INSERT INTO `t_role_resource` VALUES (4115, 1, 240);
INSERT INTO `t_role_resource` VALUES (4116, 1, 241);
INSERT INTO `t_role_resource` VALUES (4117, 1, 244);
INSERT INTO `t_role_resource` VALUES (4118, 1, 245);
INSERT INTO `t_role_resource` VALUES (4119, 1, 267);
INSERT INTO `t_role_resource` VALUES (4120, 1, 269);
INSERT INTO `t_role_resource` VALUES (4121, 1, 270);
INSERT INTO `t_role_resource` VALUES (4122, 1, 173);
INSERT INTO `t_role_resource` VALUES (4123, 1, 239);
INSERT INTO `t_role_resource` VALUES (4124, 1, 242);
INSERT INTO `t_role_resource` VALUES (4125, 1, 276);
INSERT INTO `t_role_resource` VALUES (4126, 1, 174);
INSERT INTO `t_role_resource` VALUES (4127, 1, 205);
INSERT INTO `t_role_resource` VALUES (4128, 1, 206);
INSERT INTO `t_role_resource` VALUES (4129, 1, 207);
INSERT INTO `t_role_resource` VALUES (4130, 1, 175);
INSERT INTO `t_role_resource` VALUES (4131, 1, 218);
INSERT INTO `t_role_resource` VALUES (4132, 1, 219);
INSERT INTO `t_role_resource` VALUES (4133, 1, 220);
INSERT INTO `t_role_resource` VALUES (4134, 1, 221);
INSERT INTO `t_role_resource` VALUES (4135, 1, 222);
INSERT INTO `t_role_resource` VALUES (4136, 1, 223);
INSERT INTO `t_role_resource` VALUES (4137, 1, 176);
INSERT INTO `t_role_resource` VALUES (4138, 1, 202);
INSERT INTO `t_role_resource` VALUES (4139, 1, 203);
INSERT INTO `t_role_resource` VALUES (4140, 1, 204);
INSERT INTO `t_role_resource` VALUES (4141, 1, 230);
INSERT INTO `t_role_resource` VALUES (4142, 1, 238);
INSERT INTO `t_role_resource` VALUES (4143, 1, 177);
INSERT INTO `t_role_resource` VALUES (4144, 1, 229);
INSERT INTO `t_role_resource` VALUES (4145, 1, 232);
INSERT INTO `t_role_resource` VALUES (4146, 1, 233);
INSERT INTO `t_role_resource` VALUES (4147, 1, 243);
INSERT INTO `t_role_resource` VALUES (4148, 1, 178);
INSERT INTO `t_role_resource` VALUES (4149, 1, 196);
INSERT INTO `t_role_resource` VALUES (4150, 1, 197);
INSERT INTO `t_role_resource` VALUES (4151, 1, 198);
INSERT INTO `t_role_resource` VALUES (4152, 1, 257);
INSERT INTO `t_role_resource` VALUES (4153, 1, 258);
INSERT INTO `t_role_resource` VALUES (4154, 1, 179);
INSERT INTO `t_role_resource` VALUES (4155, 1, 225);
INSERT INTO `t_role_resource` VALUES (4156, 1, 226);
INSERT INTO `t_role_resource` VALUES (4157, 1, 227);
INSERT INTO `t_role_resource` VALUES (4158, 1, 228);
INSERT INTO `t_role_resource` VALUES (4159, 1, 231);
INSERT INTO `t_role_resource` VALUES (4160, 1, 180);
INSERT INTO `t_role_resource` VALUES (4161, 1, 210);
INSERT INTO `t_role_resource` VALUES (4162, 1, 211);
INSERT INTO `t_role_resource` VALUES (4163, 1, 212);
INSERT INTO `t_role_resource` VALUES (4164, 3, 192);
INSERT INTO `t_role_resource` VALUES (4165, 3, 195);
INSERT INTO `t_role_resource` VALUES (4166, 3, 183);
INSERT INTO `t_role_resource` VALUES (4167, 3, 246);
INSERT INTO `t_role_resource` VALUES (4168, 3, 199);
INSERT INTO `t_role_resource` VALUES (4169, 3, 185);
INSERT INTO `t_role_resource` VALUES (4170, 3, 191);
INSERT INTO `t_role_resource` VALUES (4171, 3, 254);
INSERT INTO `t_role_resource` VALUES (4172, 3, 208);
INSERT INTO `t_role_resource` VALUES (4173, 3, 234);
INSERT INTO `t_role_resource` VALUES (4174, 3, 237);
INSERT INTO `t_role_resource` VALUES (4175, 3, 213);
INSERT INTO `t_role_resource` VALUES (4176, 3, 241);
INSERT INTO `t_role_resource` VALUES (4177, 3, 239);
INSERT INTO `t_role_resource` VALUES (4178, 3, 276);
INSERT INTO `t_role_resource` VALUES (4179, 3, 205);
INSERT INTO `t_role_resource` VALUES (4180, 3, 218);
INSERT INTO `t_role_resource` VALUES (4181, 3, 223);
INSERT INTO `t_role_resource` VALUES (4182, 3, 202);
INSERT INTO `t_role_resource` VALUES (4183, 3, 230);
INSERT INTO `t_role_resource` VALUES (4184, 3, 238);
INSERT INTO `t_role_resource` VALUES (4185, 3, 232);
INSERT INTO `t_role_resource` VALUES (4186, 3, 243);
INSERT INTO `t_role_resource` VALUES (4187, 3, 196);
INSERT INTO `t_role_resource` VALUES (4188, 3, 257);
INSERT INTO `t_role_resource` VALUES (4189, 3, 258);
INSERT INTO `t_role_resource` VALUES (4190, 3, 225);
INSERT INTO `t_role_resource` VALUES (4191, 3, 231);
INSERT INTO `t_role_resource` VALUES (4192, 3, 210);

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标签名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 62 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (28, 'Spring', '2022-02-06 16:39:40', NULL);
INSERT INTO `t_tag` VALUES (29, 'Spring Mvc', '2022-02-06 16:39:50', NULL);
INSERT INTO `t_tag` VALUES (30, 'Vue', '2022-02-06 16:39:55', NULL);
INSERT INTO `t_tag` VALUES (31, 'Docker', '2022-02-06 16:39:59', NULL);
INSERT INTO `t_tag` VALUES (32, 'thymeleaf', '2022-02-06 16:40:16', NULL);
INSERT INTO `t_tag` VALUES (33, 'aliyun', '2022-02-06 16:40:26', NULL);
INSERT INTO `t_tag` VALUES (34, 'big data', '2022-02-06 16:40:52', NULL);
INSERT INTO `t_tag` VALUES (35, 'C++', '2022-02-06 16:41:31', NULL);
INSERT INTO `t_tag` VALUES (36, 'Python', '2022-02-06 16:41:41', NULL);
INSERT INTO `t_tag` VALUES (37, 'JavaScript', '2022-02-06 16:41:48', NULL);
INSERT INTO `t_tag` VALUES (38, 'Jquery', '2022-02-06 16:41:54', NULL);
INSERT INTO `t_tag` VALUES (39, 'SpringCloud', '2022-02-06 16:42:02', NULL);
INSERT INTO `t_tag` VALUES (40, 'linux', '2022-02-06 16:42:43', NULL);
INSERT INTO `t_tag` VALUES (41, 'vuetify', '2022-02-06 16:43:01', NULL);
INSERT INTO `t_tag` VALUES (42, 'mybatis', '2022-02-06 16:43:08', NULL);
INSERT INTO `t_tag` VALUES (43, 'mybatis plus', '2022-02-06 16:43:15', NULL);
INSERT INTO `t_tag` VALUES (44, 'Html+Css', '2022-02-06 16:43:33', NULL);
INSERT INTO `t_tag` VALUES (45, 'Go', '2022-02-06 16:43:42', NULL);
INSERT INTO `t_tag` VALUES (58, '面试', '2022-02-07 16:09:54', NULL);
INSERT INTO `t_tag` VALUES (59, 'nginx', '2022-02-26 16:19:22', NULL);
INSERT INTO `t_tag` VALUES (60, 'SpringBoot', '2022-03-03 01:28:15', NULL);
INSERT INTO `t_tag` VALUES (61, 'daily', '2022-03-06 17:20:04', NULL);

-- ----------------------------
-- Table structure for t_unique_view
-- ----------------------------
DROP TABLE IF EXISTS `t_unique_view`;
CREATE TABLE `t_unique_view`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `create_time` datetime NOT NULL COMMENT '时间',
  `views_count` int NOT NULL COMMENT '访问量',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 77 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_unique_view
-- ----------------------------
INSERT INTO `t_unique_view` VALUES (1, '2021-12-29 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (2, '2021-12-30 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (3, '2021-12-31 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (4, '2022-01-01 00:00:00', 3);
INSERT INTO `t_unique_view` VALUES (5, '2022-01-02 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (6, '2022-01-03 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (7, '2022-01-08 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (8, '2022-01-10 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (9, '2022-01-11 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (10, '2022-01-11 23:59:58', 2);
INSERT INTO `t_unique_view` VALUES (11, '2022-01-14 22:06:42', 0);
INSERT INTO `t_unique_view` VALUES (12, '2022-01-16 17:56:22', 0);
INSERT INTO `t_unique_view` VALUES (13, '2022-01-17 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (14, '2022-01-18 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (15, '2022-01-19 23:59:58', 0);
INSERT INTO `t_unique_view` VALUES (16, '2022-01-24 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (17, '2022-01-25 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (18, '2022-01-31 12:03:14', 1);
INSERT INTO `t_unique_view` VALUES (19, '2022-02-01 16:03:18', 2);
INSERT INTO `t_unique_view` VALUES (20, '2022-02-02 22:54:39', 1);
INSERT INTO `t_unique_view` VALUES (21, '2022-02-03 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (22, '2022-02-04 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (23, '2022-02-05 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (24, '2022-02-06 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (25, '2022-02-07 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (26, '2022-02-08 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (27, '2022-02-09 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (28, '2022-02-10 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (29, '2022-02-11 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (30, '2022-02-12 15:00:35', 2);
INSERT INTO `t_unique_view` VALUES (31, '2022-02-13 11:29:03', 1);
INSERT INTO `t_unique_view` VALUES (32, '2022-02-13 23:59:58', 1);
INSERT INTO `t_unique_view` VALUES (33, '2022-02-15 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (34, '2022-02-16 15:25:48', 0);
INSERT INTO `t_unique_view` VALUES (35, '2022-02-17 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (36, '2022-02-18 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (37, '2022-02-19 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (38, '2022-02-20 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (39, '2022-02-22 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (40, '2022-02-23 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (41, '2022-02-24 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (42, '2022-02-25 00:00:00', 6);
INSERT INTO `t_unique_view` VALUES (43, '2022-02-26 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (44, '2022-02-27 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (45, '2022-02-28 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (46, '2022-03-01 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (47, '2022-03-02 00:00:00', 7);
INSERT INTO `t_unique_view` VALUES (48, '2022-03-03 00:00:00', 7);
INSERT INTO `t_unique_view` VALUES (49, '2022-03-04 00:00:00', 3);
INSERT INTO `t_unique_view` VALUES (50, '2022-03-05 00:00:00', 10);
INSERT INTO `t_unique_view` VALUES (51, '2022-03-06 00:00:00', 7);
INSERT INTO `t_unique_view` VALUES (52, '2022-03-07 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (53, '2022-03-08 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (54, '2022-03-09 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (55, '2022-03-10 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (56, '2022-03-11 00:00:00', 3);
INSERT INTO `t_unique_view` VALUES (57, '2022-03-12 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (58, '2022-03-13 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (59, '2022-03-14 00:00:00', 4);
INSERT INTO `t_unique_view` VALUES (60, '2022-03-15 00:00:00', 70);
INSERT INTO `t_unique_view` VALUES (61, '2022-03-16 00:00:00', 18);
INSERT INTO `t_unique_view` VALUES (62, '2022-03-17 00:00:00', 4);
INSERT INTO `t_unique_view` VALUES (63, '2022-03-18 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (64, '2022-03-19 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (65, '2022-03-20 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (66, '2022-03-21 00:00:00', 6);
INSERT INTO `t_unique_view` VALUES (67, '2022-03-22 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (68, '2022-03-23 00:00:00', 17);
INSERT INTO `t_unique_view` VALUES (69, '2022-03-24 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (70, '2022-03-25 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (71, '2022-03-26 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (72, '2022-03-27 00:00:00', 6);
INSERT INTO `t_unique_view` VALUES (73, '2022-03-28 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (74, '2022-03-29 00:00:00', 7);
INSERT INTO `t_unique_view` VALUES (75, '2022-03-30 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (76, '2022-03-31 00:00:00', 6);

-- ----------------------------
-- Table structure for t_user_auth
-- ----------------------------
DROP TABLE IF EXISTS `t_user_auth`;
CREATE TABLE `t_user_auth`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_info_id` int NOT NULL COMMENT '用户信息id',
  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户名',
  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '密码',
  `login_type` tinyint(1) NOT NULL COMMENT '登录类型',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户登录ip',
  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `last_login_time` datetime NULL DEFAULT NULL COMMENT '上次登录时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_auth
-- ----------------------------
INSERT INTO `t_user_auth` VALUES (1, 1, 'admin', '$2a$10$c7vv1iHEw.2q2FVBZ9YYJ.MRtayoQeNcLUTjXNzuYifXFzVHkHapy', 1, '116.199.36.224', '广东省广州市 联通', '2021-08-12 15:43:18', '2022-04-01 03:33:31', '2022-04-01 03:33:31');
INSERT INTO `t_user_auth` VALUES (2, 2, '18970465384@163.com', '$2a$10$aGcpH1710aa/6b6c2ah70eyJKp8ok74UkG8rmlYgUP4S6fyVeh4Tq', 1, '59.55.171.152', '江西省吉安市 电信', '2022-02-13 16:38:54', '2022-03-06 01:49:16', '2022-03-06 01:49:16');
INSERT INTO `t_user_auth` VALUES (3, 3, 'C7F398D7A35111FCDABC9BECEC09E32A', '358C665C184007A427CA6F87E8CB52DD', 2, '59.55.171.163', '江西省吉安市 电信', '2022-02-28 16:18:46', NULL, '2022-02-28 16:18:46');

-- ----------------------------
-- Table structure for t_user_info
-- ----------------------------
DROP TABLE IF EXISTS `t_user_info`;
CREATE TABLE `t_user_info`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱号',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '用户头像',
  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户简介',
  `web_site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '个人网站',
  `is_disable` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否禁用',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_info
-- ----------------------------
INSERT INTO `t_user_info` VALUES (1, 'admin@qq.com', 'DarkChen', 'https://static.jishudaniu.com/avatar/59d30ad4e3895aac2bf43ac9f4f1d848.gif', '随便写写', 'www.jishudaniu.com', 0, '2021-08-12 15:43:17', '2022-02-26 15:58:39');
INSERT INTO `t_user_info` VALUES (2, '18970465384@163.com', '用户1492780303010516993', 'https://static.jishudaniu.com/avatar/9f3d55d92b72395244fb3142e2db3720.jpg', NULL, '', 0, '2022-02-13 16:38:53', '2022-02-13 16:40:02');
INSERT INTO `t_user_info` VALUES (3, NULL, 'Dark Chen', 'http://thirdqq.qlogo.cn/g?b=oidb&k=ia4hLzFsWTUIUQzWvpNtiaPw&s=40&t=1629015718', NULL, NULL, 0, '2022-02-28 16:18:46', NULL);

-- ----------------------------
-- Table structure for t_user_role
-- ----------------------------
DROP TABLE IF EXISTS `t_user_role`;
CREATE TABLE `t_user_role`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NULL DEFAULT NULL COMMENT '用户id',
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 580 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_role
-- ----------------------------
INSERT INTO `t_user_role` VALUES (577, 1, 1);
INSERT INTO `t_user_role` VALUES (578, 2, 2);
INSERT INTO `t_user_role` VALUES (579, 3, 2);

-- ----------------------------
-- Table structure for t_website_config
-- ----------------------------
DROP TABLE IF EXISTS `t_website_config`;
CREATE TABLE `t_website_config`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `config` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '配置信息',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_website_config
-- ----------------------------
INSERT INTO `t_website_config` VALUES (1, '{\"alipayQRCode\":\"https://static.jishudaniu.com/config/a8a1c0b3b104d7a3efada67a1e018f05.png\",\"gitee\":\"https://gitee.com/ShitError\",\"github\":\"https://github.com/ShitError\",\"isChatRoom\":0,\"isCommentReview\":0,\"isEmailNotice\":1,\"isMessageReview\":0,\"isMusicPlayer\":0,\"isReward\":1,\"qq\":\"1938976625\",\"socialLoginList\":[\"qq\"],\"socialUrlList\":[\"qq\",\"github\",\"gitee\"],\"touristAvatar\":\"https://static.jishudaniu.com/config/26f83c764cbe7b29e0178192cd0d35b9.jpg\",\"userAvatar\":\"https://static.jishudaniu.com/config/ad7a39d6afe97ec03d31e6eff69f5a87.jpg\",\"websiteAuthor\":\"DarkChen\",\"websiteAvatar\":\"https://static.jishudaniu.com/config/59d30ad4e3895aac2bf43ac9f4f1d848.gif\",\"websiteCreateTime\":\"2021-11-06\",\"websiteIntro\":\"与恶龙缠斗过久,自身亦成为恶龙。凝视深渊过久,深渊将回以凝视。\",\"websiteName\":\"DK-BLOG\",\"websiteNotice\":\"\",\"websiteRecordNo\":\"赣ICP备2021003856号\",\"websocketUrl\":\"ws://127.0.0.1:8080/websocket\",\"weiXinQRCode\":\"https://static.jishudaniu.com/config/7e6d510c2f91f48fbf23147b0de44251.png\"}', '2021-08-09 19:37:30', '2022-03-25 15:40:27');

SET FOREIGN_KEY_CHECKS = 1;
=======
/*
 Navicat Premium Data Transfer

 Source Server         : www.jishudaniu.com
 Source Server Type    : MySQL
 Source Server Version : 80028
 Source Host           : 121.40.238.163:3306
 Source Schema         : dkblog

 Target Server Type    : MySQL
 Target Server Version : 80028
 File Encoding         : 65001

 Date: 01/04/2022 03:38:41
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_article
-- ----------------------------
DROP TABLE IF EXISTS `t_article`;
CREATE TABLE `t_article`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL COMMENT '作者',
  `category_id` int NULL DEFAULT NULL COMMENT '文章分类',
  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章缩略图',
  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标题',
  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '内容',
  `type` tinyint(1) NOT NULL DEFAULT 0 COMMENT '文章类型 1原创 2转载 3翻译',
  `original_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '原文链接',
  `is_top` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否置顶 0否 1是',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除  0否 1是',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态值 1公开 2私密 3评论可见',
  `create_time` datetime NOT NULL COMMENT '发表时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  FULLTEXT INDEX `ft_search`(`article_content`)
) ENGINE = InnoDB AUTO_INCREMENT = 61 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article
-- ----------------------------
INSERT INTO `t_article` VALUES (53, 1, 333, 'https://static.jishudaniu.com/articles/85eee7640539ffe9441828c685acf567.jpg', 'nginx基本使用', '# 1. 常用命令\n\n以下命令nginx已经通过apt安装好了，有nginx命令。\n\n## 1. 查看版本\n\n```shell\nnginx -v\n```\n\n如果你想同时看到更详细的配置项，使用 -V\n\n```shell\nnginx -V\n```\n\n## 2. 查看 Nginx 配置语法的正确性\n\n```shell\nsudo nginx -t\n```\n\n这里如果用大写 T，效果就是 测试、丢弃并退出\n\n```shell\nsudo nginx -T\n```\n\n## 3. 为Nginx指定一个配置文件\n\n```shell\nnginx -c </path/config> #为Nginx指定一个配置文件，来代替缺省值conf/nginx.conf\n```\n\n## 4. 启动 Nginx 服务\n\n```shell\nsudo systemctl start nginx #systemd\nOR\nsudo service nginx start   #sysvinit\n```\n\n## 5. 开机自启动\n\n```shell\nsudo systemctl enable nginx #systemd\n或\nsudo service nginx enable   #sysv init\n```\n\n## 6. 重启 Nginx 服务\n\n重启的意思是，停止 然后 启动\n\n```shell\nsudo systemctl restart nginx #systemd\n或\nsudo service nginx restart   #sysv init\n```\n\n## 7. 查看 Nginx 服务状态\n\n这条是看运行时的服务状态信息的。\n\n```shell\nsudo systemctl status nginx #systemd\n或\nsudo service nginx status   #sysvinit\n```\n\n## 8. 重载 Nginx 服务\n\n重载是重新加载 配置文件，看命令：\n\n```shell\nsudo systemctl reload nginx #systemd\n或\nsudo service nginx reload   #sysvinit\n```\n\n## 9. 停止 Nginx 服务\n\n不管你是什么原因想停了它，都可以用：\n\n```shell\nsudo systemctl stop nginx #systemd\nOR\nsudo service nginx stop   #sysvinit\n```\n\n## 10. 查看命令帮助\n\n如果还有什么不懂，或者想知道其他命令，就用这个\n\n```shell\nsystemctl -h nginx\n```\n\n# 2. 配置文件\n\nnginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改\n\n![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132450.png)\n\n## 第一部分：全局块 \n\n从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\n\n比如上面第一行配置的：\n\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132657.png)\n\n这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约\n\n##  第二部分：events 块\n\nevents 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。\n\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132920.png)\n\n上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\n\n## 第三部分：http 块\n\n这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\n\n需要注意的是：http 块也可以包括 **http** **全局块**、**server** **块**。\n\n### 1. http全局块\n\nhttp 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\n\n**upstream**（上游服务器设置，主要为反向代理、负载均衡相关配置，upstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡\n\n### 2. server块\n\n这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。\n\n每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。\n\n而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。\n\n#### 1.全局 server 块\n\n最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。\n\n#### 2. location块\n\n一个 server 块可以配置多个 location 块。\n\n这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。\n\n## nginx.conf 详细的配置文件介绍\n\n```properties\n#定义Nginx运行的用户和用户组\nuser www www; \n\n#nginx进程数，通常设置成和cpu的数量相等\nworker_processes 4; \n\n#全局错误日志定义类型，[debug | info | notice | warn | error | crit]\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n\n#进程pid文件\n#pid        logs/nginx.pid;\n\n\n#指定进程可以打开的最大描述符：数目\n#工作模式与连接数上限\n##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\nworker_rlimit_nofile 65535;\n\n\nevents {\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\n    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。\n    #补充说明：\n    #与apache相类，nginx针对不同的操作系统，有不同的事件模型\n    #A）标准事件模型\n    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll\n    #B）高效事件模型\n    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。\n    #Epoll：使用于Linux内核2.6版本及以后的系统。\n    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。\n    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。\n    use epoll\n    \n    \n    #单个进程最大连接数（最大连接数=连接数+进程数）\n    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。\n    worker_connections  1024;\n    \n    #keepalive 超时时间\n    keepalive_timeout 60;\n    \n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。\n    #分页大小可以用命令getconf PAGESIZE 取得。\n    #[root@web001 ~]# getconf PAGESIZE\n    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。\n    client_header_buffer_size 4k;\n    \n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\n    open_file_cache max=65535 inactive=60s;\n    \n    \n    #这个是指多长时间检查一次缓存的有效信息。\n    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.\n    open_file_cache_valid 80s;\n    \n    \n    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\n    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.\n    open_file_cache_min_uses 1;\n    \n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.\n    open_file_cache_errors on;\n}\n\n\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp{\n    #文件扩展名与文件类型映射表\n    include mime.types;\n    \n    #默认文件类型\n    default_type application/octet-stream;\n    \n    #默认编码\n    charset utf-8;\n    \n    #服务器名字的hash表大小\n    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.\n    server_names_hash_bucket_size 128;\n    \n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\n    client_header_buffer_size 32k;\n    \n    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。\n    large_client_header_buffers 4 64k;\n    \n    #设定通过nginx上传文件的大小\n    client_max_body_size 8m;\n    \n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。\n    sendfile on;\n    \n     #开启目录列表访问，合适下载服务器，默认关闭。\n    autoindex on;\n    \n      #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\n    tcp_nopush on;\n     \n    tcp_nodelay on;\n    \n    #长连接超时时间，单位是秒\n    keepalive_timeout 120;\n    \n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\n    fastcgi_connect_timeout 300;\n    fastcgi_send_timeout 300;\n    fastcgi_read_timeout 300;\n    fastcgi_buffer_size 64k;\n    fastcgi_buffers 4 64k;\n    fastcgi_busy_buffers_size 128k;\n    fastcgi_temp_file_write_size 128k;\n    \n    #gzip模块设置\n    gzip on; #开启gzip压缩输出\n    gzip_min_length 1k;    #最小压缩文件大小\n    gzip_buffers 4 16k;    #压缩缓冲区\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n    gzip_comp_level 2;     #压缩等级\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\n    gzip_vary on;\n\n    #开启限制IP连接数的时候需要使用\n    #limit_zone crawler $binary_remote_addr 10m;\n    \n    \n    #负载均衡配置\n    upstream piao.jd.com {\n     \n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\n        server 192.168.80.121:80 weight=3;\n        server 192.168.80.122:80 weight=2;\n        server 192.168.80.123:80 weight=3;\n\n        #nginx的upstream目前支持4种方式的分配\n        #1、轮询（默认）\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n        #2、weight\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n        #例如：\n        #upstream bakend {\n        #    server 192.168.0.14 weight=10;\n        #    server 192.168.0.15 weight=10;\n        #}\n        #2、ip_hash\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n        #例如：\n        #upstream bakend {\n        #    ip_hash;\n        #    server 192.168.0.14:88;\n        #    server 192.168.0.15:80;\n        #}\n        #3、fair（第三方）\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n        #upstream backend {\n        #    server server1;\n        #    server server2;\n        #    fair;\n        #}\n        #4、url_hash（第三方）\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n        #upstream backend {\n        #    server squid1:3128;\n        #    server squid2:3128;\n        #    hash $request_uri;\n        #    hash_method crc32;\n        #}\n\n        #tips:\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\n        #    ip_hash;\n        #    server 127.0.0.1:9090 down;\n        #    server 127.0.0.1:8080 weight=2;\n        #    server 127.0.0.1:6060;\n        #    server 127.0.0.1:7070 backup;\n        #}\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\n\n        #每个设备的状态设置为:\n        #1.down表示单前的server暂时不参与负载\n        #2.weight为weight越大，负载的权重就越大。\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\n    }\n    \n    \n    #虚拟主机的配置\n    server {\n        #监听端口\n        listen 80;\n\n        #域名可以有多个，用空格隔开\n        server_name www.jd.com jd.com;\n        #默认入口文件名称\n        index index.html index.htm index.php;\n        root /data/www/jd;\n\n        #对******进行负载均衡\n        location ~ .*.(php|php5)?$\n        {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            include fastcgi.conf;\n        }\n         \n        #图片缓存时间设置\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n            expires 10d;\n        }\n         \n        #JS和CSS缓存时间设置\n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n         \n        #日志格式设定\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\n        #$remote_user：用来记录客户端用户名称；\n        #$time_local： 用来记录访问时间与时区；\n        #$request： 用来记录请求的url与http协议；\n        #$status： 用来记录请求状态；成功是200，\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\n        #$http_referer：用来记录从那个页面链接访问过来的；\n        #$http_user_agent：记录客户浏览器的相关信息；\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\n        log_format access \'$remote_addr - $remote_user [$time_local] \"$request\" \'\n        \'$status $body_bytes_sent \"$http_referer\" \'\n        \'\"$http_user_agent\" $http_x_forwarded_for\';\n         \n        #定义本虚拟主机的访问日志\n        access_log  /usr/local/nginx/logs/host.access.log  main;\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\n         \n        #对 \"/connect-controller\" 启用反向代理\n        location /connect-controller {\n            proxy_pass http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n             \n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n             \n            #以下是一些反向代理的配置，可选。\n            proxy_set_header Host $host;\n\n            #允许客户端请求的最大单文件字节数\n            client_max_body_size 10m;\n\n            #缓冲区代理缓冲用户端请求的最大字节数，\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\n            client_body_buffer_size 128k;\n\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\n            proxy_intercept_errors on;\n\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\n            #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_connect_timeout 90;\n\n            #后端服务器数据回传时间(代理发送超时)\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\n            proxy_send_timeout 90;\n\n            #连接成功后，后端服务器响应时间(代理接收超时)\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\n            proxy_read_timeout 90;\n\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\n            proxy_buffer_size 4k;\n\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\n            proxy_buffers 4 32k;\n\n            #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_busy_buffers_size 64k;\n\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n            proxy_temp_file_write_size 64k;\n        }\n        \n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat或resin处理\n        location ~ .(jsp|jspx|do)?$ {\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        }\n    }\n}\n```\n\n## 总结\n\nNginx 配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置）。\n\nmain 部分设置的指令影响其他所有部分的设置；\n\nserver 部分的指令主要用于制定虚拟主机域名、IP 和端口号；\n\nupstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；\n\nlocation 部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。\n\n他们之间的关系：server 继承 main，location 继承 server；upstream 既不会继承指令也不会被继承。\n\n', 2, 'https://github.com/krislinzhao/StudyNotes', 0, 0, 1, '2021-12-28 16:18:55', '2022-03-07 01:38:16');
INSERT INTO `t_article` VALUES (54, 1, 333, 'https://static.jishudaniu.com/articles/495b49617f83556109b1dee076c22f31.jpg', 'Docker常用命令', '\n```shell\n\nattach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像\n\nbuild     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像\n\ncommit    Create a new image from a container changes   # 提交当前容器为新的镜像\n\ncp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中\n\ncreate    Create a new container                        # 创建一个新的容器，同 run，但不启动容器\n\ndiff      Inspect changes on a container\'s filesystem   # 查看 docker 容器变化\n\nevents    Get real time events from the server          # 从 docker 服务获取容器实时事件\n\nexec      Run a command in an existing container        # 在已存在的容器上运行命令\n\nexport    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\n\nhistory   Show the history of an image                  # 展示一个镜像形成历史\n\nimages    List images                                   # 列出系统当前镜像\n\nimport    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]\n\ninfo      Display system-wide information               # 显示系统相关信息\n\ninspect   Return low-level information on a container   # 查看容器详细信息\n\nkill      Kill a running container                      # kill 指定 docker 容器\n\nload      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]\n\nlogin     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器\n\nlogout    Log out from a Docker registry server          # 从当前 Docker registry 退出\n\nlogs      Fetch the logs of a container                 # 输出当前容器日志信息\n\nport      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口\n\npause     Pause all processes within a container        # 暂停容器\n\nps        List containers                               # 列出容器列表\n\npull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像\n\npush      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器\n\nrestart   Restart a running container                   # 重启运行的容器\n\nrm        Remove one or more containers                 # 移除一个或者多个容器\n\nrmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n\nrun       Run a command in a new container              # 创建一个新的容器并运行一个命令\n\nsave      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 \n\nload]\n\nsearch    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像\n\nstart     Start a stopped containers                    # 启动容器\n\nstop      Stop a running containers                     # 停止容器\n\ntag       Tag an image into a repository                # 给源中镜像打标签\n\ntop       Lookup the running processes of a container   # 查看容器中运行的进程信息\n\nunpause   Unpause a paused container                    # 取消暂停容器\n\nversion   Show the docker version information           # 查看 docker 版本号\n\nwait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值\n```', 1, '', 0, 0, 1, '2021-12-31 16:42:03', '2022-02-26 16:43:18');
INSERT INTO `t_article` VALUES (55, 1, 334, 'https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg', 'APlayer音乐播放器', '##### 1.首先在head中引入样式\n```html\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\">\n```\n##### 2.引入js文件\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\"></script>\n<!-- require MetingJS -->\n<script src=\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\"></script>\n```\n##### 3.下面帖代码\n```html\n<template>\n  <meting-js server=\"netease\"\n             type=\"playlist\"\n             id=\"7052482444\"\n             fixed=\"true\"\n             autoplay=\"true\"\n             loop=\"all\"\n             order=\"random\"\n             preload=\"auto\"\n             list-folded=\"ture\"\n             list-max-height=\"500px\"\n></meting-js>\n```\n左下角是效果', 1, '', 0, 0, 1, '2022-01-24 17:02:01', '2022-03-03 12:51:49');
INSERT INTO `t_article` VALUES (56, 1, 333, 'https://static.jishudaniu.com/articles/681d5410a7dda848709ac71f7d04ab63.jpg', '高校支付宝自动打卡', '前段时间在github上面的脚本挂了（ps：打卡接口屏蔽了国外ip）），想着能不能搬到linux上去。然后配上我的学生机就开始了。\n**打卡api：**\n```shell\nhttps://fxgl.jx.edu.cn/高校id/public/homeQd?loginName=学号id&loginType=0\n//把高校id和学号替换成自己的\n```\n| 学校名称                      | 学校标识码 | 所在地   |\n| ----------------------------- | ---------- | -------- |\n| 南昌大学                      | 4136010403 | 南昌市   |\n| 华东交通大学                  | 4136010404 | 南昌市   |\n| 东华理工大学                  | 4136010405 | 抚州市   |\n| 南昌航空大学                  | 4136010406 | 南昌市   |\n| 江西理工大学                  | 4136010407 | 赣州市   |\n| 景德镇陶瓷大学                | 4136010408 | 景德镇市 |\n| 江西农业大学                  | 4136010410 | 南昌市   |\n| 江西中医药大学                | 4136010412 | 南昌市   |\n| 赣南医学院                    | 4136010413 | 赣州市   |\n| 江西师范大学                  | 4136010414 | 南昌市   |\n| 上饶师范学院                  | 4136010416 | 上饶市   |\n| 宜春学院                      | 4136010417 | 宜春市   |\n| 赣南师范大学                  | 4136010418 | 赣州市   |\n| 井冈山大学                    | 4136010419 | 吉安市   |\n| 江西财经大学                  | 4136010421 | 南昌市   |\n| 江西科技学院                  | 4136010846 | 南昌市   |\n| 景德镇学院                    | 4136010894 | 景德镇市 |\n| 萍乡学院                      | 4136010895 | 萍乡市   |\n| 江西科技师范大学              | 4136011318 | 南昌市   |\n| 南昌工程学院                  | 4136011319 | 南昌市   |\n| 江西警察学院                  | 4136011504 | 南昌市   |\n| 新余学院                      | 4136011508 | 新余市   |\n| 九江学院                      | 4136011843 | 九江市   |\n| 江西工程学院                  | 4136012766 | 新余市   |\n| 南昌理工学院                  | 4136012795 | 南昌市   |\n| 江西应用科技学院              | 4136012938 | 南昌市   |\n| 江西服装学院                  | 4136013418 | 南昌市   |\n| 南昌工学院                    | 4136013421 | 南昌市   |\n| 南昌大学科学技术学院          | 4136013429 | 南昌市   |\n| 南昌大学共青学院              | 4136013430 | 九江市   |\n| 华东交通大学理工学院          | 4136013431 | 南昌市   |\n| 东华理工大学长江学院          | 4136013432 | 抚州市   |\n| 南昌航空大学科技学院          | 4136013433 | 南昌市   |\n| 江西理工大学应用科学学院      | 4136013434 | 赣州市   |\n| 景德镇陶瓷大学科技艺术学院    | 4136013435 | 景德镇市 |\n| 江西农业大学南昌商学院        | 4136013436 | 南昌市   |\n| 江西中医药大学科技学院        | 4136013437 | 南昌市   |\n| 江西师范大学科学技术学院      | 4136013438 | 南昌市   |\n| 赣南师范大学科技学院          | 4136013439 | 赣州市   |\n| 江西科技师范大学理工学院      | 4136013440 | 南昌市   |\n| 江西财经大学现代经济管理 学院 | 4136013441 | 南昌市   |\n| 豫章师范学院                  | 4136013774 | 南昌市   |\n| 南昌师范学院                  | 4136014437 | 南昌市   |\n| 上饶幼儿师范高等专科学校      | 3636000312 | 上饶市   |\n| 抚州幼儿师范高等专科学校      | 3636000519 | 抚州市   |\n| 江西工业职业技术学院          | 4136010839 | 南昌市   |\n| 江西医学高等专科学校          | 4136010888 | 上饶市   |\n| 九江职业大学                  | 4136011505 | 九江市   |\n| 九江职业技术学院              | 4136011785 | 九江市   |\n| 江西司法警官职业学院          | 4136012929 | 南昌市   |\n| 江西陶瓷工艺美术职业技术 学院 | 4136012930 | 景德镇市 |\n| 江西旅游商贸职业学院          | 4136012932 | 南昌市   |\n| 江西电力职业技术学院          | 4136012933 | 南昌市   |\n| 江西环境工程职业学院          | 4136012934 | 赣州市   |\n| 江西艺术职业学院              | 4136012936 | 南昌市   |\n| 鹰潭职业技术学院              | 4136012937 | 鹰潭市   |\n| 江西信息应用职业技术学院      | 4136012939 | 南昌市   |\n| 江西交通职业技术学院          | 4136012940 | 南昌市   |\n| 江西财经职业学院              | 4136012941 | 九江市   |\n| 江西应用技术职业学院          | 4136012942 | 赣州市   |\n| 江西现代职业技术学院          | 4136012943 | 南昌市   |\n| 江西工业工程职业技术学院      | 4136012944 | 萍乡市   |\n| 江西机电职业技术学院          | 4136012976 | 南昌市   |\n| 江西科技职业学院              | 4136013419 | 南昌市   |\n| 南昌职业学院                  | 4136013420 | 南昌市   |\n| 江西外语外贸职业学院          | 4136013422 | 南昌市   |\n| 江西工业贸易职业技术学院      | 4136013423 | 南昌市   |\n| 宜春职业技术学院              | 4136013424 | 宜春市   |\n| 江西应用工程职业学院          | 4136013425 | 萍乡市   |\n| 江西生物科技职业学院          | 4136013426 | 南昌市   |\n| 江西建设职业技术学院          | 4136013427 | 南昌市   |\n| 抚州职业技术学院              | 4136013428 | 抚州市   |\n| 江西中医药高等专科学校        | 4136013775 | 抚州市   |\n| 江西先锋软件职业技术学院      | 4136013776 | 南昌市   |\n| 江西经济管理职业学院          | 4136013866 | 南昌市   |\n| 江西制造职业技术学院          | 4136013867 | 南昌市   |\n| 江西工程职业学院              | 4136013868 | 南昌市   |\n| 江西青年职业学院              | 4136013869 | 南昌市   |\n| 上饶职业技术学院              | 4136013870 | 上饶市   |\n| 江西航空职业技术学院          | 4136013871 | 南昌市   |\n| 江西农业工程职业学院          | 4136013872 | 宜春市   |\n| 赣西科技职业学院              | 4136013873 | 新余市   |\n| 江西卫生职业学院              | 4136013965 | 南昌市   |\n| 江西新能源科技职业学院        | 4136014166 | 新余市   |\n| 江西枫林涉外经贸职业学院      | 4136014167 | 九江市   |\n| 江西泰豪动漫职业学院          | 4136014168 | 南昌市   |\n| 江西冶金职业技术学院          | 4136014241 | 新余市   |\n| 江西管理职业学院              | 4136014249 | 南昌市   |\n| 江西传媒职业学院              | 4136014250 | 南昌市   |\n| 江西工商职业技术学院          | 4136014321 | 南昌市   |\n| 景德镇陶瓷职业技术学院        | 4136014402 | 景德镇市 |\n| 共青科技职业学院              | 4136014403 | 九江市   |\n| 赣州师范高等专科学校          | 4136014465 | 赣州市   |\n| 江西水利职业学院              | 4136014476 | 南昌市   |\n| 宜春幼儿师范高等专科学校      | 4136014494 | 宜春市   |\n| 吉安职业技术学院              | 4136014504 | 吉安市   |\n| 江西洪州职业学院              | 4136014505 | 宜春市   |\n| 江西师范高等专科学校          | 4136014537 | 鹰潭市   |\n| 南昌影视传播职业学院          | 4136014544 | 南昌市   |\n| 赣南卫生健康职业学院          | 4136014569 | 赣州市   |\n\n这里是江西的其他地区的自己百度，有些学校学号不等于id号。具体要自己查\n\n## linux操作\n用ftp工具把文件上传，文件下载和配置[看这](看这)\n用到python3和crontab安装:\n```shell\nyum install python3\nyum install python3-pip\nyum install crontabs\npython3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py //查看打卡成不成功\n```\n\n**文件地址：**\n![](https://static-jsdn.oss-cn-shenzhen.aliyuncs.com/img/20220226174853.png)\n命令：\n```shell\ncrontab –e //crontab脚本编辑文件\n0 2 * * * python3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py\n//每天晚上两点自动打卡，我自己的经常不打卡所以多设置几个比较好\n```\n\n```shell\ncrontab -l //检查\nservice crond start //启动\n```', 1, '', 0, 0, 1, '2021-11-06 18:09:03', '2022-02-26 23:52:57');
INSERT INTO `t_article` VALUES (57, 1, 335, 'https://static.jishudaniu.com/articles/193a084cdf280332dd5e156ddd0433d0.jpg', 'SpringBoot启动定时任务', '## 1、启动类里面使用@EnableScheduling 注解开启功能，自动扫描：\n\n\n\n```java\n@SpringBootApplication\n@EnableScheduling //开启定时任务\npublic class MainApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MainApplication.class, args);\n    }\n}\n```\n\n## 2、新建一个Job类：\n\n> - 要在任务的类上写@Component\n> - 要在任务方法上写@Scheduled\n\n\n\n```java\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\n\n\n@Component\npublic class Jobs {\n    //表示方法执行完成后5秒\n    @Scheduled(fixedDelay = 5000)\n    public void fixedDelayJob() throws InterruptedException {\n        System.out.println(\"fixedDelay 每隔5秒\" + new Date());\n    }\n\n    //表示每隔3秒\n    @Scheduled(fixedRate = 3000)\n    public void fixedRateJob() {\n\n        System.out.println(\"fixedRate 每隔3秒\" + new Date());\n    }\n\n    //表示每天8时30分0秒执行\n    @Scheduled(cron = \"0 0,30 0,8 ? * ? \")\n    public void cronJob() {\n        System.out.println(new Date() + \" ...>>cron....\");\n    }\n}\n```\n\n*执行结果如下：*\n\n\n\n```css\nfixedRate 每隔3秒Thu Jun 20 20:26:41 CST 2019\nfixedDelay 每隔5秒Thu Jun 20 20:26:43 CST 2019\nfixedRate 每隔3秒Thu Jun 20 20:26:44 CST 2019\nfixedDelay 每隔5秒Thu Jun 20 20:26:48 CST 2019\n```\n\n## 3、总结\n\n> - fixedDelay和fixedRate，单位是毫秒，这里这里就是5秒和3秒，它们的区别就是：fixedRate就是每多次分钟一次，不论你业务执行花费了多少时间。我都是1分钟执行1次，而fixedDelay是当任务执行完毕后1分钟在执行。所以根据实际业务不同，可以选择不同的方式。\n> - cron表达式：比如你要设置每天什么时候执行，就可以用它\n>    cron表达式，有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。\n>    cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：\n\n\n\n```html\n* 第一位，表示秒，取值0-59\n* 第二位，表示分，取值0-59\n* 第三位，表示小时，取值0-23\n* 第四位，日期天/日，取值1-31\n* 第五位，日期月份，取值1-12\n* 第六位，星期，取值1-7，星期一，星期二...，注：不是第1周，第二周的意思\n          另外：1表示星期天，2表示星期一。\n* 第7为，年份，可以留空，取值1970-2099\n```\n\n> cron中，还有一些特殊的符号，含义如下：\n\n\n\n```bash\n(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...\n(?)问号：问号只能出现在日期和星期这两个位置。\n(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12\n(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四\n(/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*/y，等同于0/y\n```\n\n> 下面列举几个例子供大家来验证：\n\n\n\n```bash\n0 0 3 * * ?     每天3点执行\n0 5 3 * * ?     每天3点5分执行\n0 5 3 ? * *     每天3点5分执行，与上面作用相同\n0 5/10 3 * * ?  每天3点的 5分，15分，25分，35分，45分，55分这几个时间点执行\n0 10 3 ? * 1    每周星期天，3点10分 执行，注：1表示星期天    \n0 10 3 ? * 1#3  每个月的第三个星期，星期天 执行，#号只能出现在星期的位置\n```\n\n', 1, '', 0, 0, 1, '2022-02-01 01:31:14', '2022-03-03 01:50:53');
INSERT INTO `t_article` VALUES (58, 1, 335, 'https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg', '个人收藏网站分享', '### 资源不在于多而在于精，分享一些常用的\n\n#### 开源项目：\n\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\n2. [github全球最大的代码托管平台](https://github.com)\n3. [gitee中国最大的托管平台](https://gitee.com)\n4. https://sourceforge.net/\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\n\n#### 疑难杂症解决：\n\n1. [google](https://www.google.com/)\n2. [stackoverflow（解决bug的好去处）](https://www.stackoverflow.com/)\n3. [baidu](https://www.baidu.com/)\n4. [b乎](https://www.zhihu.com/)\n5. [简书质量一直可以](https://www.jianshu.com/)\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\n7. https://www.csdn.net/\n8. [稀土掘金](https://juejin.cn/)\n9. [b站](https://bilibili.com/)\n\n#### 素材:\n\n1. [jQuery插件库](https://www.iconfont.cn/)\n2. https://pixabay.com/zh/\n3. https://unsplash.com/\n4. http://www.pexels.com/\n5. https://gitmind.cn/app/doc/d74790416\n6. https://zhutix.com/ico/gang-chrome/\n\n#### 在线设计类:\n\n1. [在线PS](https://www.uupoop.com/#/old)\n2. [在线音频剪辑](https://www.weixinsyt.com/)\n3. [在线视频剪辑](https://www.kapwing.com/)\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\n\n#### 在线编程:\n\n1. https://jsrun.net/\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\n3. [编程中国](https://www.bccn.net/)\n\n####  学习网站:\n\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\n4. [CodeGym](https://codegym.cc/)\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\n\n', 1, '', 1, 0, 1, '2022-03-06 17:21:54', '2022-03-20 15:28:51');
INSERT INTO `t_article` VALUES (59, 1, 333, 'https://static.jishudaniu.com/articles/29ccc97d96ac3a7abb8d8e13dea450d4.jpg', 'mysql安装配置', '# 部署服务器\n\n## 安装mysql\n\nrpm -qa|grep mysql #无输出说明没有安装\n\n### 下载和安装mysql源\n\nwget [https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm](https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fget%2Fmysql80-community-release-el7-3.noarch.rpm)\n\n### 安装mysql源\n\n``` shell\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\n```\n\n### 查看mysql相关资源\n\n``` shell\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\n```\n\n如果没有安装yum-config-manager 需要安装yum -y install yum-utils\n\n选择mysql版本:\n\n/*使用MySQL Yum Repository安装MySQL，默认会选择当前最新的稳定版本\n\n使用命令：yum repolist all | grep mysql，查看当前yum repolist的所有版本*/\n\n``` shell\nyum repolist all | grep mysql\n```\n\n### 切换版本\n\n``` shell\nsudo yum-config-manager --disable mysql80-community\n\nsudo yum-config-manager --enable mysql57-community\n```\n\n### 安装mysql:\n\n该命令会安装MySQL服务器 (mysql-community-server) 及其所需的依赖、相关组件，包括mysql-community-client、mysql-community-common、mysql-community-libs等。安装时间会比较长\n\n``` shell\nsudo yum install mysql-community-server\n```\n\n### 启动Mysql\n\n``` shell\nsystemctl start mysqld.service\n\nsystemctl status mysqld.service\n```\n\n### 停止Mysql\n\n``` shell\nsystemctl stop mysqld.service\n```\n\n### 重启Mysql\n\n``` shell\nsystemctl restart mysqld.service\n```\n\n### 初始密码\n\nMySQL第一次启动后会创建超级管理员账号root@localhost，初始密码存储在日志文件中：\n\n``` shell\ngrep \'temporary password\' /var/log/mysqld.log\n```\n\n### 进入mysql客户端\n\nmysql -u root  -p\n\n输入上面的临时密码password\n\n### 修改默认密码\n\n``` shell\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'admin123\'\n```\n\n### 设置开机启动\n\n``` shell\nsystemctl enable mysqld\n\nsystemctl daemon-reload\n\n```\n\n### 开放远程连接\n\n``` shell\nmysql>use mysql;\n\nmsyql>update user set user.Host=\'%\' where user.User=\'root\';\n\nmysql>flush privileges;\n```\n\n## 安装JDK\n\n自行百度\n\n推荐清华镜像源jdk8\n\n``` shell\nwget https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_openj9_linuxXL_8u282b08_openj9-0.24.0.tar.gz\n```\n\n### 配置环境变量\n\nvim /etc/profile\n\nshift+G划到底部 添加环境变量\n\n``` shell\nexport JAVA_HOME= **YOUR_JAVA_PATH**\nexport JRE_HOME=$JAVA_HOME/jre\nexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib\nexport PATH=$JAVA_HOME/bin:$PATH\n```\n\n刷新\n\n``` shell\nsource /etc/profile\n\njava -version\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 1, '', 0, 0, 1, '2022-03-07 02:27:49', '2022-03-07 18:05:52');
INSERT INTO `t_article` VALUES (60, 1, 335, 'https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg', 'spring家族注解汇总', '## Springboot注解\n\n### 一. 注解列表\n\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\n\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\n\n@EnableAutoConfiguSuppressWaration 自动配置。\n\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\n\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\n\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\n\n@Autowired自动导入。\n\n@PathVariable获取参数。\n\n@JsonBackReference解决嵌套外链问题。\n\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\n\n### 二. 注解(annotations)详解\n\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\n\n``` java\npackage com.example.myproject;\n\nimport org.springframework.boot.SpringApplication;\n\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n \n\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\n\npublic class Application {\n\npublic static void main(String[] args) {\n\n	SpringApplication.run(Application.class, args);\n\n	}\n\n}\n```\n\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\n\n\n\n ```java\n@RequestMapping(\"/test\")\n\n@ResponseBody\n\npublic String test(){\n\n	return \"OK\";\n\n}\n ```\n\n\n\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\n\n```java\n@Controller\n\n@RequestMapping(“/demoInfo”)\n\npublicclass DemoController {\n\n@Autowired\n\nprivate DemoInfoService demoInfoService;\n\n \n\n@RequestMapping(\"/hello\")\n\npublic String hello(Map<String,Object> map){\n\n  	System.out.println(\"DemoController.hello()\");\n\n  	map.put(\"hello\",\"from TemplateController.helloHtml\");\n\n  	//会使用hello.html或者hello.ftl模板进行渲染显示.\n\n  	return\"/hello\";\n\n	}\n\n}\n\n```\n\n\n\n \n\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\n\n```java\npackage com.kfit.demo.web;\n\n \n\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport org.springframework.web.bind.annotation.RestController;\n\n \n\n \n\n@RestController\n\n@RequestMapping(“/demoInfo2”)\n\npublicclass DemoController2 {\n\n \n\n@RequestMapping(\"/test\")\n\npublic String test(){\n\n  return\"ok\";\n\n}\n\n}\n```\n\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\n\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\n\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\n\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\n\n@Import：用来导入其他配置类。\n\n@ImportResource：用来加载xml配置文件。\n\n@Autowired：自动导入依赖的bean\n\n@Service：一般用于修饰service层的组件\n\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\n\n@Bean：用@Bean标注方法等价于XML中配置的bean。\n\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\n\n@Value(value = “#{message}”)\n\nprivate String message;\n\n \n\n@Inject：等价于默认的@Autowired，只是没有required属性；\n\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\n\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\n\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\n\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\n\n@Autowired\n\n@Qualifier(value = “demoInfoService”)\n\nprivate DemoInfoService demoInfoService;\n\n \n\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\n\n### JPA注解\n\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\n\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\n\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\n\n@Column：如果字段名与列名相同，则可以省略。\n\n@Id：表示该属性为主键。\n\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\n\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\n\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\n\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\n\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\n\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\n\n### springMVC相关注解\n\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \nparams:指定request中必须包含某些参数值是，才让该方法处理。 \nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\n\n@RequestParam：用在方法的参数前面。 \n@RequestParam \nString a =request.getParameter(“a”)。\n\n@PathVariable:路径变量。如\n\nRequestMapping(“user/get/mac/{macAddress}”)\n\npublic String getByMacAddress(@PathVariable String macAddress){\n\n//do something;\n\n}\n\n参数与大括号里的名字一样要相同。\n\n \n\n### 全局异常处理\n\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\n\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\n\n \n\n### Spring注解\n\n@Controller\n@Service\n@Autowired\n@RequestMapping\n@RequestParam\n@ModelAttribute\n@Cacheable\n@CacheFlush\n@Resource\n@PostConstruct\n@PreDestroy\n@Repository\n@Component （不推荐使用）\n@Scope\n@SessionAttributes\n@InitBinder\n@Required\n@Qualifier\n\n\n\n#### @Controller\n\n • 例如\n@Controller\n public class SoftCreateController extends SimpleBaseController {}\n • 或者\n@Controller(\"userController\")\n\n• 说明\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \n\n#### @Service\n\n• 例如\n @Service\n public class SoftCreateServiceImpl implements ISoftCreateService {}\n • 或者\n @Service(\"softCreateServiceImpl\")\n\n • 说明\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\n\n#### @Autowired\n\n• 例如\n @Autowired\nprivate ISoftPMService softPMService;\n• 或者\n@Autowired(required=false)\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\n\n • 说明\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \n\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\n\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\n\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\n\n#### @RequestMapping\n\n• 类\n```java\n@Controller\n@RequestMapping(\"/bbtForum.do\")\npublic class BbtForumController {\n       @RequestMapping(params = \"method=listBoardTopic\")\n 	public String listBoardTopic(int topicId,User user) {}\n}\n```\n • 方法\n```java\n @RequestMapping(\"/softpg/downSoftPg.do\")\n @RequestMapping(value=\"/softpg/ajaxLoadSoftId.do\",method = POST)\n@RequestMapping(value = \"/osu/product/detail.do\", params = { \"modify=false\" }, method =POST)\n```\n\n • 说明\n  @RequestMapping 可以声明到类或方法上\n\n• 参数绑定说明\n如果我们使用以下的 URL 请求：\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\n\n#### @RequestParam\n\n• 参数绑定说明\n@RequestParam(\"id\")\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\nlistBoardTopic(@RequestParam(\"id\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \n@RequestParam(required=false)：参数不是必须的，默认为true\n@RequestParam(value=\"id\",required=false)\n\n请求处理方法入参的可选类型\n• Java 基本数据类型和 String\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\n\n • request/response/session\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \n\n• org.springframework.web.context.request.WebRequest\n      内部包含了 request 对象\n\n• java.util.Locale \n      绑定到 request 对应的 Locale 对象上\n\n• java.io.InputStream/java.io.Reader\n        可以借此访问 request 的内容 \n\n• java.io.OutputStream / java.io.Writer\n      可以借此操作 response 的内容\n\n• 任何标注了 @RequestParam 注解的入参 \n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\n\n• java.util.Map / org.springframework.ui.ModelMap\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\n\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\n\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \n\n• org.springframework.web.bind.support.SessionStatus\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \n\n请求处理方法返回值的可选类型\n\n• void\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\n@RequestMapping(\"/welcome.do\")\npublic void welcomeHandler() {}\n对应的逻辑视图名为 “ welcome ”\n\n• String\n此时逻辑视图名为返回的字符，如以下的方法：\n\n```java\n@RequestMapping(method = RequestMethod.GET)\npublic String setupForm(@RequestParam(\"ownerId\") int ownerId, ModelMap model) {\n\n    Owner owner = this.clinic.loadOwner(ownerId);\n    model.addAttribute(owner);\n    return \"ownerForm\";\n\n}\n```\n\n\n对应的逻辑视图名为 “ ownerForm ”\n\n• org.springframework.ui.ModelMap\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\n@RequestMapping(\"/vets.do\")\npublic ModelMap vetsHandler() { \nreturn new ModelMap(this.clinic.getVets());\n}\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\n\n• ModelAndView\n当然还可以是传统的 ModelAndView 。\n\n#### @ModelAttribute\n\n• 作用域：request\n • 例如\n\n```java\n@RequestMapping(\"/base/userManageCooper/init.do\")\npublic String handleInit(@ModelAttribute(\"queryBean\") ManagedUser sUser,Model model,){}\n```\n\n\n\n• 或者\n\n```java\n@ModelAttribute(\"coopMap\")// 将coopMap 返回到页 面\npublic Map<Long,CooperatorInfo> coopMapItems(){}\n```\n\n\n\n• 说明\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\"queryBean\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 \n\n@ModelAttribute使用大致有有两种：\n\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\n\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\n\n\n#### @Cacheable和@CacheFlush\n\n • @Cacheable ：声明一个方法的返回值应该被缓 存\n 例如：@Cacheable(modelId = \"testCaching\")\n\n• @CacheFlush ：声明一个方法是清空缓存的触发器\n例如：@CacheFlush(modelId = \"testCaching\")\n\n• 说明\n要配合缓存处理器使用\n\n\n#### @Resource\n\n• 例如\n\n```java\n@Resource\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\n```\n\n\n • 或者\n\n```java\n@Resource(name=\"dataSource\")\n@Resource(type=DataSource.class)\n```\n\n• 说明\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \n此时与@Autowired 类 似.\n\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\"\")，否则注入失败；\n\n#### @PostConstruct和@PreDestroy\n\n• @PostConstruct\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\n\n• @PreDestroy\n\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \n\n@Repository\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\n\n#### @Component （不推荐使用）\n\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\n\n#### @Scope\n\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\n• 说明\n\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\n同样可以通过@Scope 注解来完成\n\n@Scope中可以指定如下值：\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\nrequest:定义bean的范围是http请求（springMVC中有效）\nsession:定义bean的范围是http会话（springMVC中有效）\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\n\n#### @SessionAttributes\n\n• 说明\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\n• 例如\n@SessionAttributes(\"currUser\") // 将ModelMap 中属性名为currUser 的属性\n@SessionAttributes({\"attr1\",\"attr2\"})\n@SessionAttributes(types = User.class)\n@SessionAttributes(types = {User.class,Dept.class})\n@SessionAttributes(types = {User.class,Dept.class},value={\"attr1\",\"attr2\"})\n\n#### @InitBinder\n\n• 说明\n如果希望某个属性编辑器仅作用于特定的 Controller ，\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\n可以在该方法中向 Controller 了注册若干个属性编辑器\n\n• 例如\n\n```java\n@InitBinder\npublic void initBinder(WebDataBinder binder) {\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n    dateFormat.setLenient(false);\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n}\n```\n\n\n（14）@Required • 例如 @required\npublic setName(String name){} • 说明 \n\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\n\n（15）@Qualifier\n\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\n\n下面是其他注解，包括组合注解 （1）@Autowired\n\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\n\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\n\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\n\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\n\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\n\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\n\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\n\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\n\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\n\n（4）@Transactional 事物注解\n\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\n\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\n\n（6）\n\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\n\n### Mybatis\n\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\n\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\"getSql\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\n\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\n\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\n\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\n\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \"getByTestText\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\n\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\n\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\n\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\n\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\n\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\n\n### SpringMVC\n\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\n\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\n\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\n\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\n\n在SpringMVC后台控制层获取参数的方式主要有两种:\n\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\n\n接下来我们看一下@RequestParam注解主要有哪些参数：\n\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\n\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\n\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\n\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\n\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\n\nvalue， method；\n\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\n\nconsumes，produces\n\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\n\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\n\nparams，headers\n\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\n\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\n\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\n\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\n\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\n\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\n\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\n\n@SessionAttributes即将值放到session作用域中，写在class上面。\n\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\n\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\n\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\n\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\n\n(12)@Repository 用于注解dao层，在daoImpl类上面注解', 1, '', 0, 0, 1, '2022-03-15 19:38:48', '2022-03-16 00:47:39');

-- ----------------------------
-- Table structure for t_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_article_tag`;
CREATE TABLE `t_article_tag`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `article_id` int NOT NULL COMMENT '文章id',
  `tag_id` int NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_article_tag_1`(`article_id`) USING BTREE,
  INDEX `fk_article_tag_2`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 556 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article_tag
-- ----------------------------
INSERT INTO `t_article_tag` VALUES (511, 53, 59);
INSERT INTO `t_article_tag` VALUES (513, 54, 31);
INSERT INTO `t_article_tag` VALUES (519, 56, 40);
INSERT INTO `t_article_tag` VALUES (523, 57, 60);
INSERT INTO `t_article_tag` VALUES (524, 55, 44);
INSERT INTO `t_article_tag` VALUES (530, 59, 40);
INSERT INTO `t_article_tag` VALUES (552, 60, 28);
INSERT INTO `t_article_tag` VALUES (553, 60, 29);
INSERT INTO `t_article_tag` VALUES (554, 60, 42);
INSERT INTO `t_article_tag` VALUES (555, 58, 61);

-- ----------------------------
-- Table structure for t_category
-- ----------------------------
DROP TABLE IF EXISTS `t_category`;
CREATE TABLE `t_category`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '分类名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 336 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_category
-- ----------------------------
INSERT INTO `t_category` VALUES (333, '运维', '2022-02-26 16:19:09', NULL);
INSERT INTO `t_category` VALUES (334, 'frontend', '2022-02-26 16:59:41', NULL);
INSERT INTO `t_category` VALUES (335, 'backend', '2022-03-03 01:13:41', NULL);

-- ----------------------------
-- Table structure for t_chat_record
-- ----------------------------
DROP TABLE IF EXISTS `t_chat_record`;
CREATE TABLE `t_chat_record`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int NULL DEFAULT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `content` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '聊天内容',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'ip地址',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'ip来源',
  `type` tinyint NOT NULL COMMENT '类型',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_chat_record
-- ----------------------------

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int NOT NULL COMMENT '评论用户Id',
  `article_id` int NULL DEFAULT NULL COMMENT '评论文章id',
  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论内容',
  `reply_user_id` int NULL DEFAULT NULL COMMENT '回复用户id',
  `parent_id` int NULL DEFAULT NULL COMMENT '父评论id',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除  0否 1是',
  `is_review` tinyint(1) NOT NULL DEFAULT 1 COMMENT '是否审核',
  `create_time` datetime NOT NULL COMMENT '评论时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_comment_user`(`user_id`) USING BTREE,
  INDEX `fk_comment_article`(`article_id`) USING BTREE,
  INDEX `fk_comment_parent`(`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 441 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_comment
-- ----------------------------

-- ----------------------------
-- Table structure for t_friend_link
-- ----------------------------
DROP TABLE IF EXISTS `t_friend_link`;
CREATE TABLE `t_friend_link`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接名',
  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接头像',
  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接地址',
  `link_intro` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接介绍',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_friend_link_user`(`link_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_friend_link
-- ----------------------------
INSERT INTO `t_friend_link` VALUES (21, '测试友链', 'https://bing.ioliu.cn/v1/rand', 'www.baidu.com', '一个有趣的灵魂', '2022-02-13 17:13:15', NULL);

-- ----------------------------
-- Table structure for t_menu
-- ----------------------------
DROP TABLE IF EXISTS `t_menu`;
CREATE TABLE `t_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单名',
  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单路径',
  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '组件',
  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单icon',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `order_num` tinyint(1) NOT NULL COMMENT '排序',
  `parent_id` int NULL DEFAULT NULL COMMENT '父id',
  `is_hidden` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否隐藏  0否1是',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 215 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_menu
-- ----------------------------
INSERT INTO `t_menu` VALUES (1, '首页', '/', '/home/Home.vue', 'el-icon-myshouye', '2021-01-26 17:06:51', '2021-01-26 17:06:53', 1, NULL, 0);
INSERT INTO `t_menu` VALUES (2, '文章管理', '/article-submenu', 'Layout', 'el-icon-mywenzhang-copy', '2021-01-25 20:43:07', '2021-01-25 20:43:09', 2, NULL, 0);
INSERT INTO `t_menu` VALUES (3, '消息管理', '/message-submenu', 'Layout', 'el-icon-myxiaoxi', '2021-01-25 20:44:17', '2021-01-25 20:44:20', 3, NULL, 0);
INSERT INTO `t_menu` VALUES (4, '系统管理', '/system-submenu', 'Layout', 'el-icon-myshezhi', '2021-01-25 20:45:57', '2021-01-25 20:45:59', 5, NULL, 0);
INSERT INTO `t_menu` VALUES (5, '个人中心', '/setting', '/setting/Setting.vue', 'el-icon-myuser', '2021-01-26 17:22:38', '2021-01-26 17:22:41', 7, NULL, 0);
INSERT INTO `t_menu` VALUES (6, '发布文章', '/articles', '/article/Article.vue', 'el-icon-myfabiaowenzhang', '2021-01-26 14:30:48', '2021-01-26 14:30:51', 1, 2, 0);
INSERT INTO `t_menu` VALUES (7, '修改文章', '/articles/*', '/article/Article.vue', 'el-icon-myfabiaowenzhang', '2021-01-26 14:31:32', '2021-01-26 14:31:34', 2, 2, 1);
INSERT INTO `t_menu` VALUES (8, '文章列表', '/article-list', '/article/ArticleList.vue', 'el-icon-mywenzhangliebiao', '2021-01-26 14:32:13', '2021-01-26 14:32:16', 3, 2, 0);
INSERT INTO `t_menu` VALUES (9, '分类管理', '/categories', '/category/Category.vue', 'el-icon-myfenlei', '2021-01-26 14:33:42', '2021-01-26 14:33:43', 4, 2, 0);
INSERT INTO `t_menu` VALUES (10, '标签管理', '/tags', '/tag/Tag.vue', 'el-icon-myicontag', '2021-01-26 14:34:33', '2021-01-26 14:34:36', 5, 2, 0);
INSERT INTO `t_menu` VALUES (11, '评论管理', '/comments', '/comment/Comment.vue', 'el-icon-mypinglunzu', '2021-01-26 14:35:31', '2021-01-26 14:35:34', 1, 3, 0);
INSERT INTO `t_menu` VALUES (12, '留言管理', '/messages', '/message/Message.vue', 'el-icon-myliuyan', '2021-01-26 14:36:09', '2021-01-26 14:36:13', 2, 3, 0);
INSERT INTO `t_menu` VALUES (13, '用户列表', '/users', '/user/User.vue', 'el-icon-myyonghuliebiao', '2021-01-26 14:38:09', '2021-01-26 14:38:12', 1, 202, 0);
INSERT INTO `t_menu` VALUES (14, '角色管理', '/roles', '/role/Role.vue', 'el-icon-myjiaoseliebiao', '2021-01-26 14:39:01', '2021-01-26 14:39:03', 2, 213, 0);
INSERT INTO `t_menu` VALUES (15, '接口管理', '/resources', '/resource/Resource.vue', 'el-icon-myjiekouguanli', '2021-01-26 14:40:14', '2021-08-07 20:00:28', 2, 213, 0);
INSERT INTO `t_menu` VALUES (16, '菜单管理', '/menus', '/menu/Menu.vue', 'el-icon-mycaidan', '2021-01-26 14:40:54', '2021-08-07 10:18:49', 2, 213, 0);
INSERT INTO `t_menu` VALUES (17, '友链管理', '/links', '/friendLink/FriendLink.vue', 'el-icon-mydashujukeshihuaico-', '2021-01-26 14:41:35', '2021-01-26 14:41:37', 3, 4, 0);
INSERT INTO `t_menu` VALUES (18, '关于我', '/about', '/about/About.vue', 'el-icon-myguanyuwo', '2021-01-26 14:42:05', '2021-01-26 14:42:10', 4, 4, 0);
INSERT INTO `t_menu` VALUES (19, '日志管理', '/log-submenu', 'Layout', 'el-icon-myguanyuwo', '2021-01-31 21:33:56', '2021-01-31 21:33:59', 6, NULL, 0);
INSERT INTO `t_menu` VALUES (20, '操作日志', '/operation/log', '/log/Operation.vue', 'el-icon-myguanyuwo', '2021-01-31 15:53:21', '2021-01-31 15:53:25', 1, 19, 0);
INSERT INTO `t_menu` VALUES (201, '在线用户', '/online/users', '/user/Online.vue', 'el-icon-myyonghuliebiao', '2021-02-05 14:59:51', '2021-02-05 14:59:53', 7, 202, 0);
INSERT INTO `t_menu` VALUES (202, '用户管理', '/users-submenu', 'Layout', 'el-icon-myyonghuliebiao', '2021-02-06 23:44:59', '2021-02-06 23:45:03', 4, NULL, 0);
INSERT INTO `t_menu` VALUES (205, '相册管理', '/album-submenu', 'Layout', 'el-icon-myimage-fill', '2021-08-03 15:10:54', '2021-08-07 20:02:06', 5, NULL, 0);
INSERT INTO `t_menu` VALUES (206, '相册列表', '/albums', '/album/Album.vue', 'el-icon-myzhaopian', '2021-08-03 20:29:19', '2021-08-04 11:45:47', 1, 205, 0);
INSERT INTO `t_menu` VALUES (208, '照片管理', '/albums/:albumId', '/album/Photo.vue', 'el-icon-myzhaopian', '2021-08-03 21:37:47', '2021-08-05 10:24:08', 1, 205, 1);
INSERT INTO `t_menu` VALUES (209, '页面管理', '/pages', '/page/Page.vue', 'el-icon-myyemianpeizhi', '2021-08-04 11:36:27', '2021-08-07 20:01:26', 2, 4, 0);
INSERT INTO `t_menu` VALUES (210, '照片回收站', '/photos/delete', '/album/Delete.vue', 'el-icon-myhuishouzhan', '2021-08-05 13:55:19', NULL, 3, 205, 1);
INSERT INTO `t_menu` VALUES (213, '权限管理', '/permission-submenu', 'Layout', 'el-icon-mydaohanglantubiao_quanxianguanli', '2021-08-07 19:56:55', '2021-08-07 19:59:40', 4, NULL, 0);
INSERT INTO `t_menu` VALUES (214, '网站管理', '/website', '/website/Website.vue', 'el-icon-myxitong', '2021-08-07 20:06:41', NULL, 1, 4, 0);

-- ----------------------------
-- Table structure for t_message
-- ----------------------------
DROP TABLE IF EXISTS `t_message`;
CREATE TABLE `t_message`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '留言内容',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户地址',
  `time` tinyint(1) NULL DEFAULT NULL COMMENT '弹幕速度',
  `is_review` tinyint NOT NULL DEFAULT 1 COMMENT '是否审核',
  `create_time` datetime NOT NULL COMMENT '发布时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 23 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_message
-- ----------------------------
INSERT INTO `t_message` VALUES (1, '游客', 'https://static.jishudaniu.com/config/26f83c764cbe7b29e0178192cd0d35b9.jpg', '吼吼吼', '59.55.170.31', '江西省吉安市 电信', 9, 1, '2022-02-26 19:46:31', NULL);
INSERT INTO `t_message` VALUES (19, '游客', 'https://static.jishudaniu.com/config/26f83c764cbe7b29e0178192cd0d35b9.jpg', '哈哈哈', '127.0.0.1', '', 8, 1, '2022-02-26 20:11:04', NULL);
INSERT INTO `t_message` VALUES (21, '游客', 'https://static.jishudaniu.com/config/26f83c764cbe7b29e0178192cd0d35b9.jpg', '66666', '127.0.0.1', '', 7, 1, '2022-02-26 20:12:14', NULL);

-- ----------------------------
-- Table structure for t_operation_log
-- ----------------------------
DROP TABLE IF EXISTS `t_operation_log`;
CREATE TABLE `t_operation_log`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作模块',
  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作类型',
  `opt_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作url',
  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作方法',
  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作描述',
  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求参数',
  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求方式',
  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '返回数据',
  `user_id` int NOT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `ip_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作地址',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 823 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_operation_log
-- ----------------------------
INSERT INTO `t_operation_log` VALUES (766, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1. 常用命令\\n\\n以下命令nginx已经通过apt安装好了，有nginx命令。\\n\\n## 1. 查看版本\\n\\n```shell\\nnginx -v\\n```\\n\\n如果你想同时看到更详细的配置项，使用 -V\\n\\n```shell\\nnginx -V\\n```\\n\\n## 2. 查看 Nginx 配置语法的正确性\\n\\n```shell\\nsudo nginx -t\\n```\\n\\n这里如果用大写 T，效果就是 测试、丢弃并退出\\n\\n```shell\\nsudo nginx -T\\n```\\n\\n## 3. 为Nginx指定一个配置文件\\n\\n```shell\\nnginx -c </path/config> #为Nginx指定一个配置文件，来代替缺省值conf/nginx.conf\\n```\\n\\n## 4. 启动 Nginx 服务\\n\\n```shell\\nsudo systemctl start nginx #systemd\\nOR\\nsudo service nginx start   #sysvinit\\n```\\n\\n## 5. 开机自启动\\n\\n```shell\\nsudo systemctl enable nginx #systemd\\n或\\nsudo service nginx enable   #sysv init\\n```\\n\\n## 6. 重启 Nginx 服务\\n\\n重启的意思是，停止 然后 启动\\n\\n```shell\\nsudo systemctl restart nginx #systemd\\n或\\nsudo service nginx restart   #sysv init\\n```\\n\\n## 7. 查看 Nginx 服务状态\\n\\n这条是看运行时的服务状态信息的。\\n\\n```shell\\nsudo systemctl status nginx #systemd\\n或\\nsudo service nginx status   #sysvinit\\n```\\n\\n## 8. 重载 Nginx 服务\\n\\n重载是重新加载 配置文件，看命令：\\n\\n```shell\\nsudo systemctl reload nginx #systemd\\n或\\nsudo service nginx reload   #sysvinit\\n```\\n\\n## 9. 停止 Nginx 服务\\n\\n不管你是什么原因想停了它，都可以用：\\n\\n```shell\\nsudo systemctl stop nginx #systemd\\nOR\\nsudo service nginx stop   #sysvinit\\n```\\n\\n## 10. 查看命令帮助\\n\\n如果还有什么不懂，或者想知道其他命令，就用这个\\n\\n```shell\\nsystemctl -h nginx\\n```\\n\\n# 2. 配置文件\\n\\nnginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改\\n\\n![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132450.png)\\n\\n## 第一部分：全局块 \\n\\n从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\\n\\n比如上面第一行配置的：\\n\\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132657.png)\\n\\n这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约\\n\\n##  第二部分：events 块\\n\\nevents 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。\\n\\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132920.png)\\n\\n上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\\n\\n## 第三部分：http 块\\n\\n这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\\n\\n需要注意的是：http 块也可以包括 **http** **全局块**、**server** **块**。\\n\\n### 1. http全局块\\n\\nhttp 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\\n\\n**upstream**（上游服务器设置，主要为反向代理、负载均衡相关配置，upstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡\\n\\n### 2. server块\\n\\n这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。\\n\\n每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。\\n\\n而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。\\n\\n#### 1.全局 server 块\\n\\n最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。\\n\\n#### 2. location块\\n\\n一个 server 块可以配置多个 location 块。\\n\\n这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。\\n\\n## nginx.conf 详细的配置文件介绍\\n\\n```properties\\n#定义Nginx运行的用户和用户组\\nuser www www; \\n\\n#nginx进程数，通常设置成和cpu的数量相等\\nworker_processes 4; \\n\\n#全局错误日志定义类型，[debug | info | notice | warn | error | crit]\\n#error_log  logs/error.log;\\n#error_log  logs/error.log  notice;\\n#error_log  logs/error.log  info;\\n\\n\\n#进程pid文件\\n#pid        logs/nginx.pid;\\n\\n\\n#指定进程可以打开的最大描述符：数目\\n#工作模式与连接数上限\\n##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\\nworker_rlimit_nofile 65535;\\n\\n\\nevents {\\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\\n    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。\\n    #补充说明：\\n    #与apache相类，nginx针对不同的操作系统，有不同的事件模型\\n    #A）标准事件模型\\n    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll\\n    #B）高效事件模型\\n    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。\\n    #Epoll：使用于Linux内核2.6版本及以后的系统。\\n    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。\\n    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。\\n    use epoll\\n    \\n    \\n    #单个进程最大连接数（最大连接数=连接数+进程数）\\n    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。\\n    worker_connections  1024;\\n    \\n    #keepalive 超时时间\\n    keepalive_timeout 60;\\n    \\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。\\n    #分页大小可以用命令getconf PAGESIZE 取得。\\n    #[root@web001 ~]# getconf PAGESIZE\\n    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。\\n    client_header_buffer_size 4k;\\n    \\n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\\n    open_file_cache max=65535 inactive=60s;\\n    \\n    \\n    #这个是指多长时间检查一次缓存的有效信息。\\n    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.\\n    open_file_cache_valid 80s;\\n    \\n    \\n    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\\n    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.\\n    open_file_cache_min_uses 1;\\n    \\n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.\\n    open_file_cache_errors on;\\n}\\n\\n\\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\\nhttp{\\n    #文件扩展名与文件类型映射表\\n    include mime.types;\\n    \\n    #默认文件类型\\n    default_type application/octet-stream;\\n    \\n    #默认编码\\n    charset utf-8;\\n    \\n    #服务器名字的hash表大小\\n    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.\\n    server_names_hash_bucket_size 128;\\n    \\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\\n    client_header_buffer_size 32k;\\n    \\n    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。\\n    large_client_header_buffers 4 64k;\\n    \\n    #设定通过nginx上传文件的大小\\n    client_max_body_size 8m;\\n    \\n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\\n    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。\\n    sendfile on;\\n    \\n     #开启目录列表访问，合适下载服务器，默认关闭。\\n    autoindex on;\\n    \\n      #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\\n    tcp_nopush on;\\n     \\n    tcp_nodelay on;\\n    \\n    #长连接超时时间，单位是秒\\n    keepalive_timeout 120;\\n    \\n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\\n    fastcgi_connect_timeout 300;\\n    fastcgi_send_timeout 300;\\n    fastcgi_read_timeout 300;\\n    fastcgi_buffer_size 64k;\\n    fastcgi_buffers 4 64k;\\n    fastcgi_busy_buffers_size 128k;\\n    fastcgi_temp_file_write_size 128k;\\n    \\n    #gzip模块设置\\n    gzip on; #开启gzip压缩输出\\n    gzip_min_length 1k;    #最小压缩文件大小\\n    gzip_buffers 4 16k;    #压缩缓冲区\\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\\n    gzip_comp_level 2;     #压缩等级\\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\\n    gzip_vary on;\\n\\n    #开启限制IP连接数的时候需要使用\\n    #limit_zone crawler $binary_remote_addr 10m;\\n    \\n    \\n    #负载均衡配置\\n    upstream piao.jd.com {\\n     \\n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\\n        server 192.168.80.121:80 weight=3;\\n        server 192.168.80.122:80 weight=2;\\n        server 192.168.80.123:80 weight=3;\\n\\n        #nginx的upstream目前支持4种方式的分配\\n        #1、轮询（默认）\\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\\n        #2、weight\\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\\n        #例如：\\n        #upstream bakend {\\n        #    server 192.168.0.14 weight=10;\\n        #    server 192.168.0.15 weight=10;\\n        #}\\n        #2、ip_hash\\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\\n        #例如：\\n        #upstream bakend {\\n        #    ip_hash;\\n        #    server 192.168.0.14:88;\\n        #    server 192.168.0.15:80;\\n        #}\\n        #3、fair（第三方）\\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\\n        #upstream backend {\\n        #    server server1;\\n        #    server server2;\\n        #    fair;\\n        #}\\n        #4、url_hash（第三方）\\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\\n        #upstream backend {\\n        #    server squid1:3128;\\n        #    server squid2:3128;\\n        #    hash $request_uri;\\n        #    hash_method crc32;\\n        #}\\n\\n        #tips:\\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\\n        #    ip_hash;\\n        #    server 127.0.0.1:9090 down;\\n        #    server 127.0.0.1:8080 weight=2;\\n        #    server 127.0.0.1:6060;\\n        #    server 127.0.0.1:7070 backup;\\n        #}\\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\\n\\n        #每个设备的状态设置为:\\n        #1.down表示单前的server暂时不参与负载\\n        #2.weight为weight越大，负载的权重就越大。\\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\\n\\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\\n    }\\n    \\n    \\n    #虚拟主机的配置\\n    server {\\n        #监听端口\\n        listen 80;\\n\\n        #域名可以有多个，用空格隔开\\n        server_name www.jd.com jd.com;\\n        #默认入口文件名称\\n        index index.html index.htm index.php;\\n        root /data/www/jd;\\n\\n        #对******进行负载均衡\\n        location ~ .*.(php|php5)?$\\n        {\\n            fastcgi_pass 127.0.0.1:9000;\\n            fastcgi_index index.php;\\n            include fastcgi.conf;\\n        }\\n         \\n        #图片缓存时间设置\\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\\n        {\\n            expires 10d;\\n        }\\n         \\n        #JS和CSS缓存时间设置\\n        location ~ .*.(js|css)?$\\n        {\\n            expires 1h;\\n        }\\n         \\n        #日志格式设定\\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\\n        #$remote_user：用来记录客户端用户名称；\\n        #$time_local： 用来记录访问时间与时区；\\n        #$request： 用来记录请求的url与http协议；\\n        #$status： 用来记录请求状态；成功是200，\\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\\n        #$http_referer：用来记录从那个页面链接访问过来的；\\n        #$http_user_agent：记录客户浏览器的相关信息；\\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\\n        log_format access \'$remote_addr - $remote_user [$time_local] \\\"$request\\\" \'\\n        \'$status $body_bytes_sent \\\"$http_referer\\\" \'\\n        \'\\\"$http_user_agent\\\" $http_x_forwarded_for\';\\n         \\n        #定义本虚拟主机的访问日志\\n        access_log  /usr/local/nginx/logs/host.access.log  main;\\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\\n         \\n        #对 \\\"/connect-controller\\\" 启用反向代理\\n        location /connect-controller {\\n            proxy_pass http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）\\n            proxy_redirect off;\\n            proxy_set_header X-Real-IP $remote_addr;\\n             \\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n             \\n            #以下是一些反向代理的配置，可选。\\n            proxy_set_header Host $host;\\n\\n            #允许客户端请求的最大单文件字节数\\n            client_max_body_size 10m;\\n\\n            #缓冲区代理缓冲用户端请求的最大字节数，\\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\\n            client_body_buffer_size 128k;\\n\\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\\n            proxy_intercept_errors on;\\n\\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\\n            #nginx跟后端服务器连接超时时间(代理连接超时)\\n            proxy_connect_timeout 90;\\n\\n            #后端服务器数据回传时间(代理发送超时)\\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\\n            proxy_send_timeout 90;\\n\\n            #连接成功后，后端服务器响应时间(代理接收超时)\\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\\n            proxy_read_timeout 90;\\n\\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\\n            proxy_buffer_size 4k;\\n\\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\\n            proxy_buffers 4 32k;\\n\\n            #高负荷下缓冲大小（proxy_buffers*2）\\n            proxy_busy_buffers_size 64k;\\n\\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\\n            proxy_temp_file_write_size 64k;\\n        }\\n        \\n        #本地动静分离反向代理配置\\n        #所有jsp的页面均交由tomcat或resin处理\\n        location ~ .(jsp|jspx|do)?$ {\\n            proxy_set_header Host $host;\\n            proxy_set_header X-Real-IP $remote_addr;\\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n            proxy_pass http://127.0.0.1:8080;\\n        }\\n    }\\n}\\n```\\n\\n## 总结\\n\\nNginx 配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置）。\\n\\nmain 部分设置的指令影响其他所有部分的设置；\\n\\nserver 部分的指令主要用于制定虚拟主机域名、IP 和端口号；\\n\\nupstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；\\n\\nlocation 部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。\\n\\n他们之间的关系：server 继承 main，location 继承 server；upstream 既不会继承指令也不会被继承。\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/85eee7640539ffe9441828c685acf567.jpg\",\"articleTitle\":\"nginx基本使用\",\"isTop\":1,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:18:55', NULL);
INSERT INTO `t_operation_log` VALUES (767, '分类模块', '新增或修改', '/admin/categories', 'com.jishudaniu.dkblog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"运维\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:19:09', NULL);
INSERT INTO `t_operation_log` VALUES (768, '标签模块', '新增或修改', '/admin/tags', 'com.jishudaniu.dkblog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"nginx\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:19:22', NULL);
INSERT INTO `t_operation_log` VALUES (769, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 1. 常用命令\\n\\n以下命令nginx已经通过apt安装好了，有nginx命令。\\n\\n## 1. 查看版本\\n\\n```shell\\nnginx -v\\n```\\n\\n如果你想同时看到更详细的配置项，使用 -V\\n\\n```shell\\nnginx -V\\n```\\n\\n## 2. 查看 Nginx 配置语法的正确性\\n\\n```shell\\nsudo nginx -t\\n```\\n\\n这里如果用大写 T，效果就是 测试、丢弃并退出\\n\\n```shell\\nsudo nginx -T\\n```\\n\\n## 3. 为Nginx指定一个配置文件\\n\\n```shell\\nnginx -c </path/config> #为Nginx指定一个配置文件，来代替缺省值conf/nginx.conf\\n```\\n\\n## 4. 启动 Nginx 服务\\n\\n```shell\\nsudo systemctl start nginx #systemd\\nOR\\nsudo service nginx start   #sysvinit\\n```\\n\\n## 5. 开机自启动\\n\\n```shell\\nsudo systemctl enable nginx #systemd\\n或\\nsudo service nginx enable   #sysv init\\n```\\n\\n## 6. 重启 Nginx 服务\\n\\n重启的意思是，停止 然后 启动\\n\\n```shell\\nsudo systemctl restart nginx #systemd\\n或\\nsudo service nginx restart   #sysv init\\n```\\n\\n## 7. 查看 Nginx 服务状态\\n\\n这条是看运行时的服务状态信息的。\\n\\n```shell\\nsudo systemctl status nginx #systemd\\n或\\nsudo service nginx status   #sysvinit\\n```\\n\\n## 8. 重载 Nginx 服务\\n\\n重载是重新加载 配置文件，看命令：\\n\\n```shell\\nsudo systemctl reload nginx #systemd\\n或\\nsudo service nginx reload   #sysvinit\\n```\\n\\n## 9. 停止 Nginx 服务\\n\\n不管你是什么原因想停了它，都可以用：\\n\\n```shell\\nsudo systemctl stop nginx #systemd\\nOR\\nsudo service nginx stop   #sysvinit\\n```\\n\\n## 10. 查看命令帮助\\n\\n如果还有什么不懂，或者想知道其他命令，就用这个\\n\\n```shell\\nsystemctl -h nginx\\n```\\n\\n# 2. 配置文件\\n\\nnginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改\\n\\n![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132450.png)\\n\\n## 第一部分：全局块 \\n\\n从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\\n\\n比如上面第一行配置的：\\n\\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132657.png)\\n\\n这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约\\n\\n##  第二部分：events 块\\n\\nevents 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。\\n\\n ![](https://gitee.com/krislin_zhao/IMGcloud/raw/master/img/20200519132920.png)\\n\\n上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\\n\\n## 第三部分：http 块\\n\\n这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\\n\\n需要注意的是：http 块也可以包括 **http** **全局块**、**server** **块**。\\n\\n### 1. http全局块\\n\\nhttp 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\\n\\n**upstream**（上游服务器设置，主要为反向代理、负载均衡相关配置，upstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡\\n\\n### 2. server块\\n\\n这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。\\n\\n每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。\\n\\n而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。\\n\\n#### 1.全局 server 块\\n\\n最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。\\n\\n#### 2. location块\\n\\n一个 server 块可以配置多个 location 块。\\n\\n这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。\\n\\n## nginx.conf 详细的配置文件介绍\\n\\n```properties\\n#定义Nginx运行的用户和用户组\\nuser www www; \\n\\n#nginx进程数，通常设置成和cpu的数量相等\\nworker_processes 4; \\n\\n#全局错误日志定义类型，[debug | info | notice | warn | error | crit]\\n#error_log  logs/error.log;\\n#error_log  logs/error.log  notice;\\n#error_log  logs/error.log  info;\\n\\n\\n#进程pid文件\\n#pid        logs/nginx.pid;\\n\\n\\n#指定进程可以打开的最大描述符：数目\\n#工作模式与连接数上限\\n##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\\nworker_rlimit_nofile 65535;\\n\\n\\nevents {\\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\\n    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。\\n    #补充说明：\\n    #与apache相类，nginx针对不同的操作系统，有不同的事件模型\\n    #A）标准事件模型\\n    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll\\n    #B）高效事件模型\\n    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。\\n    #Epoll：使用于Linux内核2.6版本及以后的系统。\\n    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。\\n    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。\\n    use epoll\\n    \\n    \\n    #单个进程最大连接数（最大连接数=连接数+进程数）\\n    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。\\n    worker_connections  1024;\\n    \\n    #keepalive 超时时间\\n    keepalive_timeout 60;\\n    \\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。\\n    #分页大小可以用命令getconf PAGESIZE 取得。\\n    #[root@web001 ~]# getconf PAGESIZE\\n    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。\\n    client_header_buffer_size 4k;\\n    \\n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\\n    open_file_cache max=65535 inactive=60s;\\n    \\n    \\n    #这个是指多长时间检查一次缓存的有效信息。\\n    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.\\n    open_file_cache_valid 80s;\\n    \\n    \\n    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\\n    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.\\n    open_file_cache_min_uses 1;\\n    \\n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.\\n    open_file_cache_errors on;\\n}\\n\\n\\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\\nhttp{\\n    #文件扩展名与文件类型映射表\\n    include mime.types;\\n    \\n    #默认文件类型\\n    default_type application/octet-stream;\\n    \\n    #默认编码\\n    charset utf-8;\\n    \\n    #服务器名字的hash表大小\\n    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.\\n    server_names_hash_bucket_size 128;\\n    \\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\\n    client_header_buffer_size 32k;\\n    \\n    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。\\n    large_client_header_buffers 4 64k;\\n    \\n    #设定通过nginx上传文件的大小\\n    client_max_body_size 8m;\\n    \\n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\\n    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。\\n    sendfile on;\\n    \\n     #开启目录列表访问，合适下载服务器，默认关闭。\\n    autoindex on;\\n    \\n      #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\\n    tcp_nopush on;\\n     \\n    tcp_nodelay on;\\n    \\n    #长连接超时时间，单位是秒\\n    keepalive_timeout 120;\\n    \\n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\\n    fastcgi_connect_timeout 300;\\n    fastcgi_send_timeout 300;\\n    fastcgi_read_timeout 300;\\n    fastcgi_buffer_size 64k;\\n    fastcgi_buffers 4 64k;\\n    fastcgi_busy_buffers_size 128k;\\n    fastcgi_temp_file_write_size 128k;\\n    \\n    #gzip模块设置\\n    gzip on; #开启gzip压缩输出\\n    gzip_min_length 1k;    #最小压缩文件大小\\n    gzip_buffers 4 16k;    #压缩缓冲区\\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\\n    gzip_comp_level 2;     #压缩等级\\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\\n    gzip_vary on;\\n\\n    #开启限制IP连接数的时候需要使用\\n    #limit_zone crawler $binary_remote_addr 10m;\\n    \\n    \\n    #负载均衡配置\\n    upstream piao.jd.com {\\n     \\n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\\n        server 192.168.80.121:80 weight=3;\\n        server 192.168.80.122:80 weight=2;\\n        server 192.168.80.123:80 weight=3;\\n\\n        #nginx的upstream目前支持4种方式的分配\\n        #1、轮询（默认）\\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\\n        #2、weight\\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\\n        #例如：\\n        #upstream bakend {\\n        #    server 192.168.0.14 weight=10;\\n        #    server 192.168.0.15 weight=10;\\n        #}\\n        #2、ip_hash\\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\\n        #例如：\\n        #upstream bakend {\\n        #    ip_hash;\\n        #    server 192.168.0.14:88;\\n        #    server 192.168.0.15:80;\\n        #}\\n        #3、fair（第三方）\\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\\n        #upstream backend {\\n        #    server server1;\\n        #    server server2;\\n        #    fair;\\n        #}\\n        #4、url_hash（第三方）\\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\\n        #upstream backend {\\n        #    server squid1:3128;\\n        #    server squid2:3128;\\n        #    hash $request_uri;\\n        #    hash_method crc32;\\n        #}\\n\\n        #tips:\\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\\n        #    ip_hash;\\n        #    server 127.0.0.1:9090 down;\\n        #    server 127.0.0.1:8080 weight=2;\\n        #    server 127.0.0.1:6060;\\n        #    server 127.0.0.1:7070 backup;\\n        #}\\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\\n\\n        #每个设备的状态设置为:\\n        #1.down表示单前的server暂时不参与负载\\n        #2.weight为weight越大，负载的权重就越大。\\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\\n\\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\\n    }\\n    \\n    \\n    #虚拟主机的配置\\n    server {\\n        #监听端口\\n        listen 80;\\n\\n        #域名可以有多个，用空格隔开\\n        server_name www.jd.com jd.com;\\n        #默认入口文件名称\\n        index index.html index.htm index.php;\\n        root /data/www/jd;\\n\\n        #对******进行负载均衡\\n        location ~ .*.(php|php5)?$\\n        {\\n            fastcgi_pass 127.0.0.1:9000;\\n            fastcgi_index index.php;\\n            include fastcgi.conf;\\n        }\\n         \\n        #图片缓存时间设置\\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\\n        {\\n            expires 10d;\\n        }\\n         \\n        #JS和CSS缓存时间设置\\n        location ~ .*.(js|css)?$\\n        {\\n            expires 1h;\\n        }\\n         \\n        #日志格式设定\\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\\n        #$remote_user：用来记录客户端用户名称；\\n        #$time_local： 用来记录访问时间与时区；\\n        #$request： 用来记录请求的url与http协议；\\n        #$status： 用来记录请求状态；成功是200，\\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\\n        #$http_referer：用来记录从那个页面链接访问过来的；\\n        #$http_user_agent：记录客户浏览器的相关信息；\\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\\n        log_format access \'$remote_addr - $remote_user [$time_local] \\\"$request\\\" \'\\n        \'$status $body_bytes_sent \\\"$http_referer\\\" \'\\n        \'\\\"$http_user_agent\\\" $http_x_forwarded_for\';\\n         \\n        #定义本虚拟主机的访问日志\\n        access_log  /usr/local/nginx/logs/host.access.log  main;\\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\\n         \\n        #对 \\\"/connect-controller\\\" 启用反向代理\\n        location /connect-controller {\\n            proxy_pass http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）\\n            proxy_redirect off;\\n            proxy_set_header X-Real-IP $remote_addr;\\n             \\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n             \\n            #以下是一些反向代理的配置，可选。\\n            proxy_set_header Host $host;\\n\\n            #允许客户端请求的最大单文件字节数\\n            client_max_body_size 10m;\\n\\n            #缓冲区代理缓冲用户端请求的最大字节数，\\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\\n            client_body_buffer_size 128k;\\n\\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\\n            proxy_intercept_errors on;\\n\\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\\n            #nginx跟后端服务器连接超时时间(代理连接超时)\\n            proxy_connect_timeout 90;\\n\\n            #后端服务器数据回传时间(代理发送超时)\\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\\n            proxy_send_timeout 90;\\n\\n            #连接成功后，后端服务器响应时间(代理接收超时)\\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\\n            proxy_read_timeout 90;\\n\\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\\n            proxy_buffer_size 4k;\\n\\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\\n            proxy_buffers 4 32k;\\n\\n            #高负荷下缓冲大小（proxy_buffers*2）\\n            proxy_busy_buffers_size 64k;\\n\\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\\n            proxy_temp_file_write_size 64k;\\n        }\\n        \\n        #本地动静分离反向代理配置\\n        #所有jsp的页面均交由tomcat或resin处理\\n        location ~ .(jsp|jspx|do)?$ {\\n            proxy_set_header Host $host;\\n            proxy_set_header X-Real-IP $remote_addr;\\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n            proxy_pass http://127.0.0.1:8080;\\n        }\\n    }\\n}\\n```\\n\\n## 总结\\n\\nNginx 配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置）。\\n\\nmain 部分设置的指令影响其他所有部分的设置；\\n\\nserver 部分的指令主要用于制定虚拟主机域名、IP 和端口号；\\n\\nupstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；\\n\\nlocation 部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。\\n\\n他们之间的关系：server 继承 main，location 继承 server；upstream 既不会继承指令也不会被继承。\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/85eee7640539ffe9441828c685acf567.jpg\",\"articleTitle\":\"nginx基本使用\",\"categoryName\":\"运维\",\"id\":53,\"isTop\":1,\"originalUrl\":\"https://github.com/krislinzhao/StudyNotes\",\"status\":1,\"tagNameList\":[],\"type\":2}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '管理员', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:23:03', NULL);
INSERT INTO `t_operation_log` VALUES (770, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n```shell\\nattach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像\\n\\nbuild     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像\\n\\ncommit    Create a new image from a container changes   # 提交当前容器为新的镜像\\n\\ncp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中\\n\\ncreate    Create a new container                        # 创建一个新的容器，同 run，但不启动容器\\n\\ndiff      Inspect changes on a container\'s filesystem   # 查看 docker 容器变化\\n\\nevents    Get real time events from the server          # 从 docker 服务获取容器实时事件\\n\\nexec      Run a command in an existing container        # 在已存在的容器上运行命令\\n\\nexport    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\\n\\nhistory   Show the history of an image                  # 展示一个镜像形成历史\\n\\nimages    List images                                   # 列出系统当前镜像\\n\\nimport    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]\\n\\ninfo      Display system-wide information               # 显示系统相关信息\\n\\ninspect   Return low-level information on a container   # 查看容器详细信息\\n\\nkill      Kill a running container                      # kill 指定 docker 容器\\n\\nload      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]\\n\\nlogin     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器\\n\\nlogout    Log out from a Docker registry server          # 从当前 Docker registry 退出\\n\\nlogs      Fetch the logs of a container                 # 输出当前容器日志信息\\n\\nport      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口\\n\\npause     Pause all processes within a container        # 暂停容器\\n\\nps        List containers                               # 列出容器列表\\n\\npull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像\\n\\npush      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器\\n\\nrestart   Restart a running container                   # 重启运行的容器\\n\\nrm        Remove one or more containers                 # 移除一个或者多个容器\\n\\nrmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\\n\\nrun       Run a command in a new container              # 创建一个新的容器并运行一个命令\\n\\nsave      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 \\n\\nload]\\n\\nsearch    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像\\n\\nstart     Start a stopped containers                    # 启动容器\\n\\nstop      Stop a running containers                     # 停止容器\\n\\ntag       Tag an image into a repository                # 给源中镜像打标签\\n\\ntop       Lookup the running processes of a container   # 查看容器中运行的进程信息\\n\\nunpause   Unpause a paused container                    # 取消暂停容器\\n\\nversion   Show the docker version information           # 查看 docker 版本号\\n\\nwait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值\\n```\",\"articleCover\":\"https://static.jishudaniu.com/articles/495b49617f83556109b1dee076c22f31.jpg\",\"articleTitle\":\"Docker常用命令\",\"categoryName\":\"运维\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:42:03', NULL);
INSERT INTO `t_operation_log` VALUES (771, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"\\n```shell\\n\\nattach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像\\n\\nbuild     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像\\n\\ncommit    Create a new image from a container changes   # 提交当前容器为新的镜像\\n\\ncp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中\\n\\ncreate    Create a new container                        # 创建一个新的容器，同 run，但不启动容器\\n\\ndiff      Inspect changes on a container\'s filesystem   # 查看 docker 容器变化\\n\\nevents    Get real time events from the server          # 从 docker 服务获取容器实时事件\\n\\nexec      Run a command in an existing container        # 在已存在的容器上运行命令\\n\\nexport    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\\n\\nhistory   Show the history of an image                  # 展示一个镜像形成历史\\n\\nimages    List images                                   # 列出系统当前镜像\\n\\nimport    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]\\n\\ninfo      Display system-wide information               # 显示系统相关信息\\n\\ninspect   Return low-level information on a container   # 查看容器详细信息\\n\\nkill      Kill a running container                      # kill 指定 docker 容器\\n\\nload      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]\\n\\nlogin     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器\\n\\nlogout    Log out from a Docker registry server          # 从当前 Docker registry 退出\\n\\nlogs      Fetch the logs of a container                 # 输出当前容器日志信息\\n\\nport      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口\\n\\npause     Pause all processes within a container        # 暂停容器\\n\\nps        List containers                               # 列出容器列表\\n\\npull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像\\n\\npush      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器\\n\\nrestart   Restart a running container                   # 重启运行的容器\\n\\nrm        Remove one or more containers                 # 移除一个或者多个容器\\n\\nrmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\\n\\nrun       Run a command in a new container              # 创建一个新的容器并运行一个命令\\n\\nsave      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 \\n\\nload]\\n\\nsearch    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像\\n\\nstart     Start a stopped containers                    # 启动容器\\n\\nstop      Stop a running containers                     # 停止容器\\n\\ntag       Tag an image into a repository                # 给源中镜像打标签\\n\\ntop       Lookup the running processes of a container   # 查看容器中运行的进程信息\\n\\nunpause   Unpause a paused container                    # 取消暂停容器\\n\\nversion   Show the docker version information           # 查看 docker 版本号\\n\\nwait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值\\n```\",\"articleCover\":\"https://static.jishudaniu.com/articles/495b49617f83556109b1dee076c22f31.jpg\",\"articleTitle\":\"Docker常用命令\",\"categoryName\":\"运维\",\"id\":54,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:43:18', NULL);
INSERT INTO `t_operation_log` VALUES (772, '分类模块', '新增或修改', '/admin/categories', 'com.jishudaniu.dkblog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"frontend\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 16:59:42', NULL);
INSERT INTO `t_operation_log` VALUES (773, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head文件引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```vue\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n</template>\\n\\n<script>\\nexport default {\\n}\\n</script>\\n\\n<style scoped>\\n\\n</style>\\n```\\n不是vue项目用template标签里的就行\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"集成APlayer+Meetingjs音乐播放器插件\",\"categoryName\":\"frontend\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 17:02:01', NULL);
INSERT INTO `t_operation_log` VALUES (774, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head文件引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```html\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n```\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"集成APlayer+Meetingjs音乐播放器插件\",\"categoryName\":\"frontend\",\"id\":55,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 17:04:02', NULL);
INSERT INTO `t_operation_log` VALUES (775, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head文件引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```html\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n```\\n左下角是效果\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"集成APlayer+Meetingjs音乐播放器插件\",\"categoryName\":\"frontend\",\"id\":55,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 17:05:57', NULL);
INSERT INTO `t_operation_log` VALUES (776, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"前段时间在github上面的脚本挂了（ps：打卡接口屏蔽了国外ip）），想着能不能搬到linux上去。然后配上我的学生机就开始了。\\n打卡api以我的自己为例\\n\\n```shell\\nhttps://fxgl.jx.edu.cn/高校id/public/homeQd?loginName=学号id&loginType=0\\n//把高校id和学号替换成自己的\\n```\\n| 学校名称                      | 学校标识码 | 所在地   |\\n| ----------------------------- | ---------- | -------- |\\n| 南昌大学                      | 4136010403 | 南昌市   |\\n| 华东交通大学                  | 4136010404 | 南昌市   |\\n| 东华理工大学                  | 4136010405 | 抚州市   |\\n| 南昌航空大学                  | 4136010406 | 南昌市   |\\n| 江西理工大学                  | 4136010407 | 赣州市   |\\n| 景德镇陶瓷大学                | 4136010408 | 景德镇市 |\\n| 江西农业大学                  | 4136010410 | 南昌市   |\\n| 江西中医药大学                | 4136010412 | 南昌市   |\\n| 赣南医学院                    | 4136010413 | 赣州市   |\\n| 江西师范大学                  | 4136010414 | 南昌市   |\\n| 上饶师范学院                  | 4136010416 | 上饶市   |\\n| 宜春学院                      | 4136010417 | 宜春市   |\\n| 赣南师范大学                  | 4136010418 | 赣州市   |\\n| 井冈山大学                    | 4136010419 | 吉安市   |\\n| 江西财经大学                  | 4136010421 | 南昌市   |\\n| 江西科技学院                  | 4136010846 | 南昌市   |\\n| 景德镇学院                    | 4136010894 | 景德镇市 |\\n| 萍乡学院                      | 4136010895 | 萍乡市   |\\n| 江西科技师范大学              | 4136011318 | 南昌市   |\\n| 南昌工程学院                  | 4136011319 | 南昌市   |\\n| 江西警察学院                  | 4136011504 | 南昌市   |\\n| 新余学院                      | 4136011508 | 新余市   |\\n| 九江学院                      | 4136011843 | 九江市   |\\n| 江西工程学院                  | 4136012766 | 新余市   |\\n| 南昌理工学院                  | 4136012795 | 南昌市   |\\n| 江西应用科技学院              | 4136012938 | 南昌市   |\\n| 江西服装学院                  | 4136013418 | 南昌市   |\\n| 南昌工学院                    | 4136013421 | 南昌市   |\\n| 南昌大学科学技术学院          | 4136013429 | 南昌市   |\\n| 南昌大学共青学院              | 4136013430 | 九江市   |\\n| 华东交通大学理工学院          | 4136013431 | 南昌市   |\\n| 东华理工大学长江学院          | 4136013432 | 抚州市   |\\n| 南昌航空大学科技学院          | 4136013433 | 南昌市   |\\n| 江西理工大学应用科学学院      | 4136013434 | 赣州市   |\\n| 景德镇陶瓷大学科技艺术学院    | 4136013435 | 景德镇市 |\\n| 江西农业大学南昌商学院        | 4136013436 | 南昌市   |\\n| 江西中医药大学科技学院        | 4136013437 | 南昌市   |\\n| 江西师范大学科学技术学院      | 4136013438 | 南昌市   |\\n| 赣南师范大学科技学院          | 4136013439 | 赣州市   |\\n| 江西科技师范大学理工学院      | 4136013440 | 南昌市   |\\n| 江西财经大学现代经济管理 学院 | 4136013441 | 南昌市   |\\n| 豫章师范学院                  | 4136013774 | 南昌市   |\\n| 南昌师范学院                  | 4136014437 | 南昌市   |\\n| 上饶幼儿师范高等专科学校      | 3636000312 | 上饶市   |\\n| 抚州幼儿师范高等专科学校      | 3636000519 | 抚州市   |\\n| 江西工业职业技术学院          | 4136010839 | 南昌市   |\\n| 江西医学高等专科学校          | 4136010888 | 上饶市   |\\n| 九江职业大学                  | 4136011505 | 九江市   |\\n| 九江职业技术学院              | 4136011785 | 九江市   |\\n| 江西司法警官职业学院          | 4136012929 | 南昌市   |\\n| 江西陶瓷工艺美术职业技术 学院 | 4136012930 | 景德镇市 |\\n| 江西旅游商贸职业学院          | 4136012932 | 南昌市   |\\n| 江西电力职业技术学院          | 4136012933 | 南昌市   |\\n| 江西环境工程职业学院          | 4136012934 | 赣州市   |\\n| 江西艺术职业学院              | 4136012936 | 南昌市   |\\n| 鹰潭职业技术学院              | 4136012937 | 鹰潭市   |\\n| 江西信息应用职业技术学院      | 4136012939 | 南昌市   |\\n| 江西交通职业技术学院          | 4136012940 | 南昌市   |\\n| 江西财经职业学院              | 4136012941 | 九江市   |\\n| 江西应用技术职业学院          | 4136012942 | 赣州市   |\\n| 江西现代职业技术学院          | 4136012943 | 南昌市   |\\n| 江西工业工程职业技术学院      | 4136012944 | 萍乡市   |\\n| 江西机电职业技术学院          | 4136012976 | 南昌市   |\\n| 江西科技职业学院              | 4136013419 | 南昌市   |\\n| 南昌职业学院                  | 4136013420 | 南昌市   |\\n| 江西外语外贸职业学院          | 4136013422 | 南昌市   |\\n| 江西工业贸易职业技术学院      | 4136013423 | 南昌市   |\\n| 宜春职业技术学院              | 4136013424 | 宜春市   |\\n| 江西应用工程职业学院          | 4136013425 | 萍乡市   |\\n| 江西生物科技职业学院          | 4136013426 | 南昌市   |\\n| 江西建设职业技术学院          | 4136013427 | 南昌市   |\\n| 抚州职业技术学院              | 4136013428 | 抚州市   |\\n| 江西中医药高等专科学校        | 4136013775 | 抚州市   |\\n| 江西先锋软件职业技术学院      | 4136013776 | 南昌市   |\\n| 江西经济管理职业学院          | 4136013866 | 南昌市   |\\n| 江西制造职业技术学院          | 4136013867 | 南昌市   |\\n| 江西工程职业学院              | 4136013868 | 南昌市   |\\n| 江西青年职业学院              | 4136013869 | 南昌市   |\\n| 上饶职业技术学院              | 4136013870 | 上饶市   |\\n| 江西航空职业技术学院          | 4136013871 | 南昌市   |\\n| 江西农业工程职业学院          | 4136013872 | 宜春市   |\\n| 赣西科技职业学院              | 4136013873 | 新余市   |\\n| 江西卫生职业学院              | 4136013965 | 南昌市   |\\n| 江西新能源科技职业学院        | 4136014166 | 新余市   |\\n| 江西枫林涉外经贸职业学院      | 4136014167 | 九江市   |\\n| 江西泰豪动漫职业学院          | 4136014168 | 南昌市   |\\n| 江西冶金职业技术学院          | 4136014241 | 新余市   |\\n| 江西管理职业学院              | 4136014249 | 南昌市   |\\n| 江西传媒职业学院              | 4136014250 | 南昌市   |\\n| 江西工商职业技术学院          | 4136014321 | 南昌市   |\\n| 景德镇陶瓷职业技术学院        | 4136014402 | 景德镇市 |\\n| 共青科技职业学院              | 4136014403 | 九江市   |\\n| 赣州师范高等专科学校          | 4136014465 | 赣州市   |\\n| 江西水利职业学院              | 4136014476 | 南昌市   |\\n| 宜春幼儿师范高等专科学校      | 4136014494 | 宜春市   |\\n| 吉安职业技术学院              | 4136014504 | 吉安市   |\\n| 江西洪州职业学院              | 4136014505 | 宜春市   |\\n| 江西师范高等专科学校          | 4136014537 | 鹰潭市   |\\n| 南昌影视传播职业学院          | 4136014544 | 南昌市   |\\n| 赣南卫生健康职业学院          | 4136014569 | 赣州市   |\\n\\n这里是江西的其他地区的自己百度，有些学校学号不等于id号。具体要自己查\\n\\n## linux操作\\n用ftp工具把文件上传，文件下载和配置[看这](看这)\\n用到python3和crontab安装:\\n```shell\\nyum install python3\\nyum install python3-pip\\nyum install crontabs\\npython3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py //查看打卡成不成功\\n```\\n\\n文件地址：\\n![](https://static-jsdn.oss-cn-shenzhen.aliyuncs.com/img/20220226174853.png)\\n命令：\\n```shell\\ncrontab –e //crontab脚本编辑文件\\n0 2 * * * python3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py\\n//每天晚上两点自动打卡，我自己的经常不打卡所以多设置几个比较好\\n```\\n\\n```shell\\ncrontab -l //检查\\nservice crond start //启动\\n```\",\"articleCover\":\"https://static.jishudaniu.com/articles/681d5410a7dda848709ac71f7d04ab63.jpg\",\"articleTitle\":\"高校支付宝自动打卡\",\"categoryName\":\"运维\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 18:09:03', NULL);
INSERT INTO `t_operation_log` VALUES (777, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head文件引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```html\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n```\\n左下角是效果\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"APlayer+Meetingjs音乐播放器\",\"categoryName\":\"frontend\",\"id\":55,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 19:20:49', NULL);
INSERT INTO `t_operation_log` VALUES (778, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"前段时间在github上面的脚本挂了（ps：打卡接口屏蔽了国外ip）），想着能不能搬到linux上去。然后配上我的学生机就开始了。\\n**打卡api：**\\n```shell\\nhttps://fxgl.jx.edu.cn/高校id/public/homeQd?loginName=学号id&loginType=0\\n//把高校id和学号替换成自己的\\n```\\n| 学校名称                      | 学校标识码 | 所在地   |\\n| ----------------------------- | ---------- | -------- |\\n| 南昌大学                      | 4136010403 | 南昌市   |\\n| 华东交通大学                  | 4136010404 | 南昌市   |\\n| 东华理工大学                  | 4136010405 | 抚州市   |\\n| 南昌航空大学                  | 4136010406 | 南昌市   |\\n| 江西理工大学                  | 4136010407 | 赣州市   |\\n| 景德镇陶瓷大学                | 4136010408 | 景德镇市 |\\n| 江西农业大学                  | 4136010410 | 南昌市   |\\n| 江西中医药大学                | 4136010412 | 南昌市   |\\n| 赣南医学院                    | 4136010413 | 赣州市   |\\n| 江西师范大学                  | 4136010414 | 南昌市   |\\n| 上饶师范学院                  | 4136010416 | 上饶市   |\\n| 宜春学院                      | 4136010417 | 宜春市   |\\n| 赣南师范大学                  | 4136010418 | 赣州市   |\\n| 井冈山大学                    | 4136010419 | 吉安市   |\\n| 江西财经大学                  | 4136010421 | 南昌市   |\\n| 江西科技学院                  | 4136010846 | 南昌市   |\\n| 景德镇学院                    | 4136010894 | 景德镇市 |\\n| 萍乡学院                      | 4136010895 | 萍乡市   |\\n| 江西科技师范大学              | 4136011318 | 南昌市   |\\n| 南昌工程学院                  | 4136011319 | 南昌市   |\\n| 江西警察学院                  | 4136011504 | 南昌市   |\\n| 新余学院                      | 4136011508 | 新余市   |\\n| 九江学院                      | 4136011843 | 九江市   |\\n| 江西工程学院                  | 4136012766 | 新余市   |\\n| 南昌理工学院                  | 4136012795 | 南昌市   |\\n| 江西应用科技学院              | 4136012938 | 南昌市   |\\n| 江西服装学院                  | 4136013418 | 南昌市   |\\n| 南昌工学院                    | 4136013421 | 南昌市   |\\n| 南昌大学科学技术学院          | 4136013429 | 南昌市   |\\n| 南昌大学共青学院              | 4136013430 | 九江市   |\\n| 华东交通大学理工学院          | 4136013431 | 南昌市   |\\n| 东华理工大学长江学院          | 4136013432 | 抚州市   |\\n| 南昌航空大学科技学院          | 4136013433 | 南昌市   |\\n| 江西理工大学应用科学学院      | 4136013434 | 赣州市   |\\n| 景德镇陶瓷大学科技艺术学院    | 4136013435 | 景德镇市 |\\n| 江西农业大学南昌商学院        | 4136013436 | 南昌市   |\\n| 江西中医药大学科技学院        | 4136013437 | 南昌市   |\\n| 江西师范大学科学技术学院      | 4136013438 | 南昌市   |\\n| 赣南师范大学科技学院          | 4136013439 | 赣州市   |\\n| 江西科技师范大学理工学院      | 4136013440 | 南昌市   |\\n| 江西财经大学现代经济管理 学院 | 4136013441 | 南昌市   |\\n| 豫章师范学院                  | 4136013774 | 南昌市   |\\n| 南昌师范学院                  | 4136014437 | 南昌市   |\\n| 上饶幼儿师范高等专科学校      | 3636000312 | 上饶市   |\\n| 抚州幼儿师范高等专科学校      | 3636000519 | 抚州市   |\\n| 江西工业职业技术学院          | 4136010839 | 南昌市   |\\n| 江西医学高等专科学校          | 4136010888 | 上饶市   |\\n| 九江职业大学                  | 4136011505 | 九江市   |\\n| 九江职业技术学院              | 4136011785 | 九江市   |\\n| 江西司法警官职业学院          | 4136012929 | 南昌市   |\\n| 江西陶瓷工艺美术职业技术 学院 | 4136012930 | 景德镇市 |\\n| 江西旅游商贸职业学院          | 4136012932 | 南昌市   |\\n| 江西电力职业技术学院          | 4136012933 | 南昌市   |\\n| 江西环境工程职业学院          | 4136012934 | 赣州市   |\\n| 江西艺术职业学院              | 4136012936 | 南昌市   |\\n| 鹰潭职业技术学院              | 4136012937 | 鹰潭市   |\\n| 江西信息应用职业技术学院      | 4136012939 | 南昌市   |\\n| 江西交通职业技术学院          | 4136012940 | 南昌市   |\\n| 江西财经职业学院              | 4136012941 | 九江市   |\\n| 江西应用技术职业学院          | 4136012942 | 赣州市   |\\n| 江西现代职业技术学院          | 4136012943 | 南昌市   |\\n| 江西工业工程职业技术学院      | 4136012944 | 萍乡市   |\\n| 江西机电职业技术学院          | 4136012976 | 南昌市   |\\n| 江西科技职业学院              | 4136013419 | 南昌市   |\\n| 南昌职业学院                  | 4136013420 | 南昌市   |\\n| 江西外语外贸职业学院          | 4136013422 | 南昌市   |\\n| 江西工业贸易职业技术学院      | 4136013423 | 南昌市   |\\n| 宜春职业技术学院              | 4136013424 | 宜春市   |\\n| 江西应用工程职业学院          | 4136013425 | 萍乡市   |\\n| 江西生物科技职业学院          | 4136013426 | 南昌市   |\\n| 江西建设职业技术学院          | 4136013427 | 南昌市   |\\n| 抚州职业技术学院              | 4136013428 | 抚州市   |\\n| 江西中医药高等专科学校        | 4136013775 | 抚州市   |\\n| 江西先锋软件职业技术学院      | 4136013776 | 南昌市   |\\n| 江西经济管理职业学院          | 4136013866 | 南昌市   |\\n| 江西制造职业技术学院          | 4136013867 | 南昌市   |\\n| 江西工程职业学院              | 4136013868 | 南昌市   |\\n| 江西青年职业学院              | 4136013869 | 南昌市   |\\n| 上饶职业技术学院              | 4136013870 | 上饶市   |\\n| 江西航空职业技术学院          | 4136013871 | 南昌市   |\\n| 江西农业工程职业学院          | 4136013872 | 宜春市   |\\n| 赣西科技职业学院              | 4136013873 | 新余市   |\\n| 江西卫生职业学院              | 4136013965 | 南昌市   |\\n| 江西新能源科技职业学院        | 4136014166 | 新余市   |\\n| 江西枫林涉外经贸职业学院      | 4136014167 | 九江市   |\\n| 江西泰豪动漫职业学院          | 4136014168 | 南昌市   |\\n| 江西冶金职业技术学院          | 4136014241 | 新余市   |\\n| 江西管理职业学院              | 4136014249 | 南昌市   |\\n| 江西传媒职业学院              | 4136014250 | 南昌市   |\\n| 江西工商职业技术学院          | 4136014321 | 南昌市   |\\n| 景德镇陶瓷职业技术学院        | 4136014402 | 景德镇市 |\\n| 共青科技职业学院              | 4136014403 | 九江市   |\\n| 赣州师范高等专科学校          | 4136014465 | 赣州市   |\\n| 江西水利职业学院              | 4136014476 | 南昌市   |\\n| 宜春幼儿师范高等专科学校      | 4136014494 | 宜春市   |\\n| 吉安职业技术学院              | 4136014504 | 吉安市   |\\n| 江西洪州职业学院              | 4136014505 | 宜春市   |\\n| 江西师范高等专科学校          | 4136014537 | 鹰潭市   |\\n| 南昌影视传播职业学院          | 4136014544 | 南昌市   |\\n| 赣南卫生健康职业学院          | 4136014569 | 赣州市   |\\n\\n这里是江西的其他地区的自己百度，有些学校学号不等于id号。具体要自己查\\n\\n## linux操作\\n用ftp工具把文件上传，文件下载和配置[看这](看这)\\n用到python3和crontab安装:\\n```shell\\nyum install python3\\nyum install python3-pip\\nyum install crontabs\\npython3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py //查看打卡成不成功\\n```\\n\\n**文件地址：**\\n![](https://static-jsdn.oss-cn-shenzhen.aliyuncs.com/img/20220226174853.png)\\n命令：\\n```shell\\ncrontab –e //crontab脚本编辑文件\\n0 2 * * * python3 /root/AutoZFBXiaoYuanFangYiSign-main/sign.py\\n//每天晚上两点自动打卡，我自己的经常不打卡所以多设置几个比较好\\n```\\n\\n```shell\\ncrontab -l //检查\\nservice crond start //启动\\n```\",\"articleCover\":\"https://static.jishudaniu.com/articles/681d5410a7dda848709ac71f7d04ab63.jpg\",\"articleTitle\":\"高校支付宝自动打卡\",\"categoryName\":\"运维\",\"id\":56,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 23:52:57', NULL);
INSERT INTO `t_operation_log` VALUES (779, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head中引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```html\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n```\\n左下角是效果\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"APlayer+Meetingjs音乐播放器\",\"categoryName\":\"frontend\",\"id\":55,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.170.31', '江西省吉安市 电信', '2022-02-26 23:54:18', NULL);
INSERT INTO `t_operation_log` VALUES (780, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[16]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:20', NULL);
INSERT INTO `t_operation_log` VALUES (781, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[15]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:22', NULL);
INSERT INTO `t_operation_log` VALUES (782, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[14]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:24', NULL);
INSERT INTO `t_operation_log` VALUES (783, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[13]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:26', NULL);
INSERT INTO `t_operation_log` VALUES (784, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[12]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:27', NULL);
INSERT INTO `t_operation_log` VALUES (785, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[11]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:28', NULL);
INSERT INTO `t_operation_log` VALUES (786, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[10]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:30', NULL);
INSERT INTO `t_operation_log` VALUES (787, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[2]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:35', NULL);
INSERT INTO `t_operation_log` VALUES (788, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[4]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:37', NULL);
INSERT INTO `t_operation_log` VALUES (789, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[5]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:40', NULL);
INSERT INTO `t_operation_log` VALUES (790, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[3]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:41', NULL);
INSERT INTO `t_operation_log` VALUES (791, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[22]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:49', NULL);
INSERT INTO `t_operation_log` VALUES (792, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[20]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:51', NULL);
INSERT INTO `t_operation_log` VALUES (793, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[18]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:54', NULL);
INSERT INTO `t_operation_log` VALUES (794, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[17]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:55', NULL);
INSERT INTO `t_operation_log` VALUES (795, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[9]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:57', NULL);
INSERT INTO `t_operation_log` VALUES (796, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[8]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:38:59', NULL);
INSERT INTO `t_operation_log` VALUES (797, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[7]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:39:02', NULL);
INSERT INTO `t_operation_log` VALUES (798, '留言模块', '删除', '/admin/messages', 'com.jishudaniu.dkblog.controller.MessageController.deleteMessages', '删除留言', '[[6]]', 'DELETE', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-01 22:39:05', NULL);
INSERT INTO `t_operation_log` VALUES (799, '分类模块', '新增或修改', '/admin/categories', 'com.jishudaniu.dkblog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"backend\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-03 01:13:41', NULL);
INSERT INTO `t_operation_log` VALUES (800, '标签模块', '新增或修改', '/admin/tags', 'com.jishudaniu.dkblog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"SpringBoot\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-03 01:28:16', NULL);
INSERT INTO `t_operation_log` VALUES (801, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"**1、启动类里面使用@EnableScheduling 注解开启功能，自动扫描：**\\n\\n\\n\\n```java\\n@SpringBootApplication\\n@EnableScheduling //开启定时任务\\npublic class MainApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(MainApplication.class, args);\\n    }\\n}\\n```\\n\\n**3、新建一个Job类：**\\n\\n> - 要在任务的类上写@Component\\n> - 要在任务方法上写@Scheduled\\n\\n\\n\\n```java\\nimport org.springframework.scheduling.annotation.Scheduled;\\nimport org.springframework.stereotype.Component;\\n\\nimport java.util.Date;\\n\\n\\n@Component\\npublic class Jobs {\\n    //表示方法执行完成后5秒\\n    @Scheduled(fixedDelay = 5000)\\n    public void fixedDelayJob() throws InterruptedException {\\n        System.out.println(\\\"fixedDelay 每隔5秒\\\" + new Date());\\n    }\\n\\n    //表示每隔3秒\\n    @Scheduled(fixedRate = 3000)\\n    public void fixedRateJob() {\\n\\n        System.out.println(\\\"fixedRate 每隔3秒\\\" + new Date());\\n    }\\n\\n    //表示每天8时30分0秒执行\\n    @Scheduled(cron = \\\"0 0,30 0,8 ? * ? \\\")\\n    public void cronJob() {\\n        System.out.println(new Date() + \\\" ...>>cron....\\\");\\n    }\\n}\\n```\\n\\n*执行结果如下：*\\n\\n\\n\\n```css\\nfixedRate 每隔3秒Thu Jun 20 20:26:41 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:43 CST 2019\\nfixedRate 每隔3秒Thu Jun 20 20:26:44 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:48 CST 2019\\n```\\n\\n## 三、总结\\n\\n> - fixedDelay和fixedRate，单位是毫秒，这里这里就是5秒和3秒，它们的区别就是：fixedRate就是每多次分钟一次，不论你业务执行花费了多少时间。我都是1分钟执行1次，而fixedDelay是当任务执行完毕后1分钟在执行。所以根据实际业务不同，可以选择不同的方式。\\n> - cron表达式：比如你要设置每天什么时候执行，就可以用它\\n>    cron表达式，有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。\\n>    cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：\\n\\n\\n\\n```undefined\\n* 第一位，表示秒，取值0-59\\n* 第二位，表示分，取值0-59\\n* 第三位，表示小时，取值0-23\\n* 第四位，日期天/日，取值1-31\\n* 第五位，日期月份，取值1-12\\n* 第六位，星期，取值1-7，星期一，星期二...，注：不是第1周，第二周的意思\\n          另外：1表示星期天，2表示星期一。\\n* 第7为，年份，可以留空，取值1970-2099\\n```\\n\\n> cron中，还有一些特殊的符号，含义如下：\\n\\n\\n\\n```jsx\\n(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...\\n(?)问号：问号只能出现在日期和星期这两个位置。\\n(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12\\n(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四\\n(/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*/y，等同于0/y\\n```\\n\\n> 下面列举几个例子供大家来验证：\\n\\n\\n\\n```bash\\n0 0 3 * * ?     每天3点执行\\n0 5 3 * * ?     每天3点5分执行\\n0 5 3 ? * *     每天3点5分执行，与上面作用相同\\n0 5/10 3 * * ?  每天3点的 5分，15分，25分，35分，45分，55分这几个时间点执行\\n0 10 3 ? * 1    每周星期天，3点10分 执行，注：1表示星期天    \\n0 10 3 ? * 1#3  每个月的第三个星期，星期天 执行，#号只能出现在星期的位置\\n```\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/193a084cdf280332dd5e156ddd0433d0.jpg\",\"articleTitle\":\"SpringBoot启动定时任务\",\"categoryName\":\"backend\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-03 01:31:14', NULL);
INSERT INTO `t_operation_log` VALUES (802, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"**1、启动类里面使用@EnableScheduling 注解开启功能，自动扫描：**\\n\\n\\n\\n```java\\n@SpringBootApplication\\n@EnableScheduling //开启定时任务\\npublic class MainApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(MainApplication.class, args);\\n    }\\n}\\n```\\n\\n**3、新建一个Job类：**\\n\\n> - 要在任务的类上写@Component\\n> - 要在任务方法上写@Scheduled\\n\\n\\n\\n```java\\nimport org.springframework.scheduling.annotation.Scheduled;\\nimport org.springframework.stereotype.Component;\\n\\nimport java.util.Date;\\n\\n\\n@Component\\npublic class Jobs {\\n    //表示方法执行完成后5秒\\n    @Scheduled(fixedDelay = 5000)\\n    public void fixedDelayJob() throws InterruptedException {\\n        System.out.println(\\\"fixedDelay 每隔5秒\\\" + new Date());\\n    }\\n\\n    //表示每隔3秒\\n    @Scheduled(fixedRate = 3000)\\n    public void fixedRateJob() {\\n\\n        System.out.println(\\\"fixedRate 每隔3秒\\\" + new Date());\\n    }\\n\\n    //表示每天8时30分0秒执行\\n    @Scheduled(cron = \\\"0 0,30 0,8 ? * ? \\\")\\n    public void cronJob() {\\n        System.out.println(new Date() + \\\" ...>>cron....\\\");\\n    }\\n}\\n```\\n\\n*执行结果如下：*\\n\\n\\n\\n```css\\nfixedRate 每隔3秒Thu Jun 20 20:26:41 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:43 CST 2019\\nfixedRate 每隔3秒Thu Jun 20 20:26:44 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:48 CST 2019\\n```\\n\\n## 三、总结\\n\\n> - fixedDelay和fixedRate，单位是毫秒，这里这里就是5秒和3秒，它们的区别就是：fixedRate就是每多次分钟一次，不论你业务执行花费了多少时间。我都是1分钟执行1次，而fixedDelay是当任务执行完毕后1分钟在执行。所以根据实际业务不同，可以选择不同的方式。\\n> - cron表达式：比如你要设置每天什么时候执行，就可以用它\\n>    cron表达式，有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。\\n>    cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：\\n\\n\\n\\n```undefined\\n* 第一位，表示秒，取值0-59\\n* 第二位，表示分，取值0-59\\n* 第三位，表示小时，取值0-23\\n* 第四位，日期天/日，取值1-31\\n* 第五位，日期月份，取值1-12\\n* 第六位，星期，取值1-7，星期一，星期二...，注：不是第1周，第二周的意思\\n          另外：1表示星期天，2表示星期一。\\n* 第7为，年份，可以留空，取值1970-2099\\n```\\n\\n> cron中，还有一些特殊的符号，含义如下：\\n\\n\\n\\n```bash\\n(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...\\n(?)问号：问号只能出现在日期和星期这两个位置。\\n(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12\\n(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四\\n(/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*/y，等同于0/y\\n```\\n\\n> 下面列举几个例子供大家来验证：\\n\\n\\n\\n```bash\\n0 0 3 * * ?     每天3点执行\\n0 5 3 * * ?     每天3点5分执行\\n0 5 3 ? * *     每天3点5分执行，与上面作用相同\\n0 5/10 3 * * ?  每天3点的 5分，15分，25分，35分，45分，55分这几个时间点执行\\n0 10 3 ? * 1    每周星期天，3点10分 执行，注：1表示星期天    \\n0 10 3 ? * 1#3  每个月的第三个星期，星期天 执行，#号只能出现在星期的位置\\n```\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/193a084cdf280332dd5e156ddd0433d0.jpg\",\"articleTitle\":\"SpringBoot启动定时任务\",\"categoryName\":\"backend\",\"id\":57,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-03 01:46:50', NULL);
INSERT INTO `t_operation_log` VALUES (803, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## 1、启动类里面使用@EnableScheduling 注解开启功能，自动扫描：\\n\\n\\n\\n```java\\n@SpringBootApplication\\n@EnableScheduling //开启定时任务\\npublic class MainApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(MainApplication.class, args);\\n    }\\n}\\n```\\n\\n## 2、新建一个Job类：\\n\\n> - 要在任务的类上写@Component\\n> - 要在任务方法上写@Scheduled\\n\\n\\n\\n```java\\nimport org.springframework.scheduling.annotation.Scheduled;\\nimport org.springframework.stereotype.Component;\\n\\nimport java.util.Date;\\n\\n\\n@Component\\npublic class Jobs {\\n    //表示方法执行完成后5秒\\n    @Scheduled(fixedDelay = 5000)\\n    public void fixedDelayJob() throws InterruptedException {\\n        System.out.println(\\\"fixedDelay 每隔5秒\\\" + new Date());\\n    }\\n\\n    //表示每隔3秒\\n    @Scheduled(fixedRate = 3000)\\n    public void fixedRateJob() {\\n\\n        System.out.println(\\\"fixedRate 每隔3秒\\\" + new Date());\\n    }\\n\\n    //表示每天8时30分0秒执行\\n    @Scheduled(cron = \\\"0 0,30 0,8 ? * ? \\\")\\n    public void cronJob() {\\n        System.out.println(new Date() + \\\" ...>>cron....\\\");\\n    }\\n}\\n```\\n\\n*执行结果如下：*\\n\\n\\n\\n```css\\nfixedRate 每隔3秒Thu Jun 20 20:26:41 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:43 CST 2019\\nfixedRate 每隔3秒Thu Jun 20 20:26:44 CST 2019\\nfixedDelay 每隔5秒Thu Jun 20 20:26:48 CST 2019\\n```\\n\\n## 3、总结\\n\\n> - fixedDelay和fixedRate，单位是毫秒，这里这里就是5秒和3秒，它们的区别就是：fixedRate就是每多次分钟一次，不论你业务执行花费了多少时间。我都是1分钟执行1次，而fixedDelay是当任务执行完毕后1分钟在执行。所以根据实际业务不同，可以选择不同的方式。\\n> - cron表达式：比如你要设置每天什么时候执行，就可以用它\\n>    cron表达式，有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。\\n>    cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：\\n\\n\\n\\n```html\\n* 第一位，表示秒，取值0-59\\n* 第二位，表示分，取值0-59\\n* 第三位，表示小时，取值0-23\\n* 第四位，日期天/日，取值1-31\\n* 第五位，日期月份，取值1-12\\n* 第六位，星期，取值1-7，星期一，星期二...，注：不是第1周，第二周的意思\\n          另外：1表示星期天，2表示星期一。\\n* 第7为，年份，可以留空，取值1970-2099\\n```\\n\\n> cron中，还有一些特殊的符号，含义如下：\\n\\n\\n\\n```bash\\n(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...\\n(?)问号：问号只能出现在日期和星期这两个位置。\\n(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12\\n(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四\\n(/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*/y，等同于0/y\\n```\\n\\n> 下面列举几个例子供大家来验证：\\n\\n\\n\\n```bash\\n0 0 3 * * ?     每天3点执行\\n0 5 3 * * ?     每天3点5分执行\\n0 5 3 ? * *     每天3点5分执行，与上面作用相同\\n0 5/10 3 * * ?  每天3点的 5分，15分，25分，35分，45分，55分这几个时间点执行\\n0 10 3 ? * 1    每周星期天，3点10分 执行，注：1表示星期天    \\n0 10 3 ? * 1#3  每个月的第三个星期，星期天 执行，#号只能出现在星期的位置\\n```\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/193a084cdf280332dd5e156ddd0433d0.jpg\",\"articleTitle\":\"SpringBoot启动定时任务\",\"categoryName\":\"backend\",\"id\":57,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.163', '江西省吉安市 电信', '2022-03-03 01:50:53', NULL);
INSERT INTO `t_operation_log` VALUES (804, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"##### 1.首先在head中引入样式\\n```html\\n<link rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\\\">\\n```\\n##### 2.引入js文件\\n```html\\n<script src=\\\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\\\"></script>\\n<!-- require MetingJS -->\\n<script src=\\\"https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\\\"></script>\\n```\\n##### 3.下面帖代码\\n```html\\n<template>\\n  <meting-js server=\\\"netease\\\"\\n             type=\\\"playlist\\\"\\n             id=\\\"7052482444\\\"\\n             fixed=\\\"true\\\"\\n             autoplay=\\\"true\\\"\\n             loop=\\\"all\\\"\\n             order=\\\"random\\\"\\n             preload=\\\"auto\\\"\\n             list-folded=\\\"ture\\\"\\n             list-max-height=\\\"500px\\\"\\n></meting-js>\\n```\\n左下角是效果\",\"articleCover\":\"https://static.jishudaniu.com/articles/40c069414191e01f62f4e2b21eb8abf1.jpg\",\"articleTitle\":\"APlayer音乐播放器\",\"categoryName\":\"frontend\",\"id\":55,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.173.156', '江西省吉安市 电信', '2022-03-03 12:51:49', NULL);
INSERT INTO `t_operation_log` VALUES (805, '标签模块', '新增或修改', '/admin/tags', 'com.jishudaniu.dkblog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"daily\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.116', '江西省吉安市 电信', '2022-03-06 17:20:05', NULL);
INSERT INTO `t_operation_log` VALUES (806, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"### 资源不在于多而在于精，分享一些常用的\\n\\n#### 开源项目：\\n\\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\\n2. [github全球最大的代码托管平台](https://github.com)\\n3. [gitee中国最大的托管平台](https://gitee.com)\\n4. https://sourceforge.net/\\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\\n\\n#### 疑难杂症解决：\\n\\n1. [google](https://www.google.com/)\\n2. [stackoverflow（一般只要你会搜bug都能解决）](https://www.stackoverflow.com/)\\n3. [baidu](https://www.baidu.com/)\\n4. [b乎（人均985，211）](https://www.zhihu.com/)\\n5. [简书质量一直可以](https://www.jianshu.com/)\\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\\n7. https://www.csdn.net/\\n8. [稀土掘金](https://juejin.cn/)\\n9. [b站](https://bilibili.com/)\\n\\n#### 素材:\\n\\n1. [jQuery插件库](https://www.iconfont.cn/)\\n2. https://pixabay.com/zh/\\n3. https://unsplash.com/\\n4. http://www.pexels.com/\\n5. https://gitmind.cn/app/doc/d74790416\\n6. https://zhutix.com/ico/gang-chrome/\\n\\n#### 在线设计类:\\n\\n1. [在线PS](https://www.uupoop.com/#/old)\\n2. [在线音频剪辑](https://www.weixinsyt.com/)\\n3. [在线视频剪辑](https://www.kapwing.com/)\\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\\n\\n#### 在线编程:\\n\\n1. https://jsrun.net/\\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\\n3. [编程中国](https://www.bccn.net/)\\n\\n####  学习网站:\\n\\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\\n4. [CodeGym](https://codegym.cc/)\\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg\",\"articleTitle\":\"个人收藏网站分享\",\"categoryName\":\"backend\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.116', '江西省吉安市 电信', '2022-03-06 17:21:54', NULL);
INSERT INTO `t_operation_log` VALUES (807, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"### 资源不在于多而在于精，分享一些常用的\\n\\n#### 开源项目：\\n\\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\\n2. [github全球最大的代码托管平台](https://github.com)\\n3. [gitee中国最大的托管平台](https://gitee.com)\\n4. https://sourceforge.net/\\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\\n\\n#### 疑难杂症解决：\\n\\n1. [google](https://www.google.com/)\\n2. [stackoverflow（一般只要你会搜bug都能解决）](https://www.stackoverflow.com/)\\n3. [baidu](https://www.baidu.com/)\\n4. [b乎](https://www.zhihu.com/)\\n5. [简书质量一直可以](https://www.jianshu.com/)\\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\\n7. https://www.csdn.net/\\n8. [稀土掘金](https://juejin.cn/)\\n9. [b站](https://bilibili.com/)\\n\\n#### 素材:\\n\\n1. [jQuery插件库](https://www.iconfont.cn/)\\n2. https://pixabay.com/zh/\\n3. https://unsplash.com/\\n4. http://www.pexels.com/\\n5. https://gitmind.cn/app/doc/d74790416\\n6. https://zhutix.com/ico/gang-chrome/\\n\\n#### 在线设计类:\\n\\n1. [在线PS](https://www.uupoop.com/#/old)\\n2. [在线音频剪辑](https://www.weixinsyt.com/)\\n3. [在线视频剪辑](https://www.kapwing.com/)\\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\\n\\n#### 在线编程:\\n\\n1. https://jsrun.net/\\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\\n3. [编程中国](https://www.bccn.net/)\\n\\n####  学习网站:\\n\\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\\n4. [CodeGym](https://codegym.cc/)\\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg\",\"articleTitle\":\"个人收藏网站分享\",\"categoryName\":\"backend\",\"id\":58,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.116', '江西省吉安市 电信', '2022-03-06 21:35:20', NULL);
INSERT INTO `t_operation_log` VALUES (808, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"### 资源不在于多而在于精，分享一些常用的\\n\\n#### 开源项目：\\n\\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\\n2. [github全球最大的代码托管平台](https://github.com)\\n3. [gitee中国最大的托管平台](https://gitee.com)\\n4. https://sourceforge.net/\\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\\n\\n#### 疑难杂症解决：\\n\\n1. [google](https://www.google.com/)\\n2. [stackoverflow（一般只要你会搜bug都能解决）](https://www.stackoverflow.com/)\\n3. [baidu](https://www.baidu.com/)\\n4. [b乎](https://www.zhihu.com/)\\n5. [简书质量一直可以](https://www.jianshu.com/)\\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\\n7. https://www.csdn.net/\\n8. [稀土掘金](https://juejin.cn/)\\n9. [b站](https://bilibili.com/)\\n\\n#### 素材:\\n\\n1. [jQuery插件库](https://www.iconfont.cn/)\\n2. https://pixabay.com/zh/\\n3. https://unsplash.com/\\n4. http://www.pexels.com/\\n5. https://gitmind.cn/app/doc/d74790416\\n6. https://zhutix.com/ico/gang-chrome/\\n\\n#### 在线设计类:\\n\\n1. [在线PS](https://www.uupoop.com/#/old)\\n2. [在线音频剪辑](https://www.weixinsyt.com/)\\n3. [在线视频剪辑](https://www.kapwing.com/)\\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\\n\\n#### 在线编程:\\n\\n1. https://jsrun.net/\\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\\n3. [编程中国](https://www.bccn.net/)\\n\\n####  学习网站:\\n\\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\\n4. [CodeGym](https://codegym.cc/)\\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg\",\"articleTitle\":\"个人收藏网站分享\",\"categoryName\":\"backend\",\"id\":58,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.171.116', '江西省吉安市 电信', '2022-03-06 21:35:42', NULL);
INSERT INTO `t_operation_log` VALUES (809, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"### 资源不在于多而在于精，分享一些常用的\\n\\n#### 开源项目：\\n\\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\\n2. [github全球最大的代码托管平台](https://github.com)\\n3. [gitee中国最大的托管平台](https://gitee.com)\\n4. https://sourceforge.net/\\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\\n\\n#### 疑难杂症解决：\\n\\n1. [google](https://www.google.com/)\\n2. [stackoverflow（一般只要你会搜bug都能解决）](https://www.stackoverflow.com/)\\n3. [baidu](https://www.baidu.com/)\\n4. [b乎](https://www.zhihu.com/)\\n5. [简书质量一直可以](https://www.jianshu.com/)\\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\\n7. https://www.csdn.net/\\n8. [稀土掘金](https://juejin.cn/)\\n9. [b站](https://bilibili.com/)\\n\\n#### 素材:\\n\\n1. [jQuery插件库](https://www.iconfont.cn/)\\n2. https://pixabay.com/zh/\\n3. https://unsplash.com/\\n4. http://www.pexels.com/\\n5. https://gitmind.cn/app/doc/d74790416\\n6. https://zhutix.com/ico/gang-chrome/\\n\\n#### 在线设计类:\\n\\n1. [在线PS](https://www.uupoop.com/#/old)\\n2. [在线音频剪辑](https://www.weixinsyt.com/)\\n3. [在线视频剪辑](https://www.kapwing.com/)\\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\\n\\n#### 在线编程:\\n\\n1. https://jsrun.net/\\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\\n3. [编程中国](https://www.bccn.net/)\\n\\n####  学习网站:\\n\\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\\n4. [CodeGym](https://codegym.cc/)\\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg\",\"articleTitle\":\"个人收藏网站分享\",\"categoryName\":\"backend\",\"id\":58,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.168.31', '江西省吉安市 电信', '2022-03-07 01:37:56', NULL);
INSERT INTO `t_operation_log` VALUES (810, '文章模块', '修改', '/admin/articles/top', 'com.jishudaniu.dkblog.controller.ArticleController.updateArticleTop', '修改文章置顶', '[{\"id\":53,\"isTop\":0}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.168.31', '江西省吉安市 电信', '2022-03-07 01:38:16', NULL);
INSERT INTO `t_operation_log` VALUES (811, '文章模块', '修改', '/admin/articles/top', 'com.jishudaniu.dkblog.controller.ArticleController.updateArticleTop', '修改文章置顶', '[{\"id\":58,\"isTop\":1}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.168.31', '江西省吉安市 电信', '2022-03-07 01:38:18', NULL);
INSERT INTO `t_operation_log` VALUES (812, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 部署服务器\\n\\n## 安装mysql\\n\\nrpm -qa|grep mysql #无输出说明没有安装\\n\\n### 下载和安装mysql源\\n\\nwget [https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm](https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fget%2Fmysql80-community-release-el7-3.noarch.rpm)\\n\\n### 安装mysql源\\n\\n```\\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\\n```\\n\\n### 查看mysql相关资源\\n\\n```\\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\\n```\\n\\n如果没有安装yum-config-manager 需要安装yum -y install yum-utils\\n\\n选择mysql版本:\\n\\n/*使用MySQL Yum Repository安装MySQL，默认会选择当前最新的稳定版本\\n\\n使用命令：yum repolist all | grep mysql，查看当前yum repolist的所有版本*/\\n\\n```\\nyum repolist all | grep mysql\\n```\\n\\n### 切换版本\\n\\n```\\nsudo yum-config-manager --disable mysql80-community\\n\\nsudo yum-config-manager --enable mysql57-community\\n```\\n\\n### 安装mysql:\\n\\n该命令会安装MySQL服务器 (mysql-community-server) 及其所需的依赖、相关组件，包括mysql-community-client、mysql-community-common、mysql-community-libs等。安装时间会比较长\\n\\n```\\nsudo yum install mysql-community-server\\n```\\n\\n### 启动Mysql\\n\\n```\\nsystemctl start mysqld.service\\n\\nsystemctl status mysqld.service\\n```\\n\\n### 停止Mysql\\n\\n```\\nsystemctl stop mysqld.service\\n```\\n\\n### 重启Mysql\\n\\n```\\nsystemctl restart mysqld.service\\n```\\n\\n### 初始密码\\n\\nMySQL第一次启动后会创建超级管理员账号root@localhost，初始密码存储在日志文件中：\\n\\n```\\ngrep \'temporary password\' /var/log/mysqld.log\\n```\\n\\n### 进入mysql客户端\\n\\nmysql -u root  -p\\n\\n输入上面的临时密码password\\n\\n### 修改默认密码\\n\\n```\\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'admin123\'\\n```\\n\\n### 设置开机启动\\n\\n```\\nsystemctl enable mysqld\\n\\nsystemctl daemon-reload\\n\\n```\\n\\n### 开放远程连接\\n\\n```\\nmysql>use mysql;\\n\\nmsyql>update user set user.Host=\'%\' where user.User=\'root\';\\n\\nmysql>flush privileges;\\n```\\n\\n## 安装JDK\\n\\n自行百度\\n\\n推荐清华镜像源jdk8\\n\\n```\\nwget https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_openj9_linuxXL_8u282b08_openj9-0.24.0.tar.gz\\n```\\n\\n### 配置环境变量\\n\\nvim /etc/profile\\n\\nshift+G划到底部 添加环境变量\\n\\n```\\nexport JAVA_HOME= **YOUR_JAVA_PATH**\\nexport JRE_HOME=$JAVA_HOME/jre\\nexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib\\nexport PATH=$JAVA_HOME/bin:$PATH\\n```\\n\\n刷新\\n\\n```\\nsource /etc/profile\\n\\njava -version\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/29ccc97d96ac3a7abb8d8e13dea450d4.jpg\",\"articleTitle\":\"mysql安装配置\",\"categoryName\":\"运维\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.168.31', '江西省吉安市 电信', '2022-03-07 02:27:50', NULL);
INSERT INTO `t_operation_log` VALUES (813, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"# 部署服务器\\n\\n## 安装mysql\\n\\nrpm -qa|grep mysql #无输出说明没有安装\\n\\n### 下载和安装mysql源\\n\\nwget [https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm](https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fget%2Fmysql80-community-release-el7-3.noarch.rpm)\\n\\n### 安装mysql源\\n\\n``` shell\\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\\n```\\n\\n### 查看mysql相关资源\\n\\n``` shell\\nsudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm\\n```\\n\\n如果没有安装yum-config-manager 需要安装yum -y install yum-utils\\n\\n选择mysql版本:\\n\\n/*使用MySQL Yum Repository安装MySQL，默认会选择当前最新的稳定版本\\n\\n使用命令：yum repolist all | grep mysql，查看当前yum repolist的所有版本*/\\n\\n``` shell\\nyum repolist all | grep mysql\\n```\\n\\n### 切换版本\\n\\n``` shell\\nsudo yum-config-manager --disable mysql80-community\\n\\nsudo yum-config-manager --enable mysql57-community\\n```\\n\\n### 安装mysql:\\n\\n该命令会安装MySQL服务器 (mysql-community-server) 及其所需的依赖、相关组件，包括mysql-community-client、mysql-community-common、mysql-community-libs等。安装时间会比较长\\n\\n``` shell\\nsudo yum install mysql-community-server\\n```\\n\\n### 启动Mysql\\n\\n``` shell\\nsystemctl start mysqld.service\\n\\nsystemctl status mysqld.service\\n```\\n\\n### 停止Mysql\\n\\n``` shell\\nsystemctl stop mysqld.service\\n```\\n\\n### 重启Mysql\\n\\n``` shell\\nsystemctl restart mysqld.service\\n```\\n\\n### 初始密码\\n\\nMySQL第一次启动后会创建超级管理员账号root@localhost，初始密码存储在日志文件中：\\n\\n``` shell\\ngrep \'temporary password\' /var/log/mysqld.log\\n```\\n\\n### 进入mysql客户端\\n\\nmysql -u root  -p\\n\\n输入上面的临时密码password\\n\\n### 修改默认密码\\n\\n``` shell\\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'admin123\'\\n```\\n\\n### 设置开机启动\\n\\n``` shell\\nsystemctl enable mysqld\\n\\nsystemctl daemon-reload\\n\\n```\\n\\n### 开放远程连接\\n\\n``` shell\\nmysql>use mysql;\\n\\nmsyql>update user set user.Host=\'%\' where user.User=\'root\';\\n\\nmysql>flush privileges;\\n```\\n\\n## 安装JDK\\n\\n自行百度\\n\\n推荐清华镜像源jdk8\\n\\n``` shell\\nwget https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jdk/x64/linux/OpenJDK8U-jdk_x64_linux_openj9_linuxXL_8u282b08_openj9-0.24.0.tar.gz\\n```\\n\\n### 配置环境变量\\n\\nvim /etc/profile\\n\\nshift+G划到底部 添加环境变量\\n\\n``` shell\\nexport JAVA_HOME= **YOUR_JAVA_PATH**\\nexport JRE_HOME=$JAVA_HOME/jre\\nexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib\\nexport PATH=$JAVA_HOME/bin:$PATH\\n```\\n\\n刷新\\n\\n``` shell\\nsource /etc/profile\\n\\njava -version\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/29ccc97d96ac3a7abb8d8e13dea450d4.jpg\",\"articleTitle\":\"mysql安装配置\",\"categoryName\":\"运维\",\"id\":59,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '59.55.168.31', '江西省吉安市 电信', '2022-03-07 18:05:52', NULL);
INSERT INTO `t_operation_log` VALUES (814, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\nSpringApplication.run(Application.class, args);\\n\\n}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\t\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  System.out.println(\\\"DemoController.hello()\\\");\\n\\n  map.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  //会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  return\\\"/hello\\\";\\n\\n}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### 三. JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### 四. springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 五、全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\nSpring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\n[http://localhost/](http://localhost/bbtForum.do?method=listBoardTopic&topicId=1&userId=10&userName=tom)[itxxzSpring4](http://localhost/bbtForum.do?method=listBoardTopic&id=1&userId=10&userName=tom)method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/itxxzSpring4?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如\\n\\n```java \\n@Scope(\\\"session\\\")\\n@Repository()\\npublic class UserSessionBean implementsSerializable {} \\n```\\n\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n​    @Scope中可以指定如下值：\\n​    singleton:定义bean的范围为每个spring容器一个实例（默认值）\\n​    prototype:定义bean可以被多次实例化（使用一次就创建一次）\\n​    request:定义bean的范围是http请求（springMVC中有效）\\n​    session:定义bean的范围是http会话（springMVC中有效）\\n​    global-session:定义bean的范围是全局http会话（portlet中有效） \\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n\\n#### @Required\\n\\n• 例如\\n\\n```java\\n@required       \\npublic setName(String name){}\\n\\n```\\n\\n\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring全家桶注解汇总\",\"categoryName\":\"backend\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-15 19:38:48', NULL);
INSERT INTO `t_operation_log` VALUES (815, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\nSpring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如\\n\\n```java \\n@Scope(\\\"session\\\")\\n@Repository()\\npublic class UserSessionBean implementsSerializable {} \\n```\\n\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n    @Scope中可以指定如下值：\\n    singleton:定义bean的范围为每个spring容器一个实例（默认值）\\n    prototype:定义bean可以被多次实例化（使用一次就创建一次）\\n    request:定义bean的范围是http请求（springMVC中有效）\\n    session:定义bean的范围是http会话（springMVC中有效）\\n    global-session:定义bean的范围是全局http会话（portlet中有效） \\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n\\n#### @Required\\n\\n• 例如\\n\\n```java\\n@required       \\npublic setName(String name){}\\n\\n```\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring全家桶注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-15 20:32:24', NULL);
INSERT INTO `t_operation_log` VALUES (816, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"Springboot注解\\n\\n一、注解(annotations)列表 @ApiOperation\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n二、注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n\\n\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\nSpringApplication.run(Application.class, args);\\n\\n}\\n\\n}\\n\\n\\n\\n \\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n@RequestMapping(“/test”)\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\nreturn”ok”;\\n\\n}\\n\\n \\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n\\n\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n   System.out.println(\\\"DemoController.hello()\\\");\\n\\n   map.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n   //会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n   return\\\"/hello\\\";\\n\\n}\\n\\n}\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n\\n\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n   return\\\"ok\\\";\\n\\n}\\n\\n}\\n\\n\\n\\n \\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n三、JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。\\n\\n四、springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n五、全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\nSpring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n（1）@Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n（2）@Service\\n\\n• 例如\\n  @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n（3）@Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n（4）@RequestMapping\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\") 本文来自www.itxxz.com \\npublic class BbtForumController {\\n             @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n  • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n  • 说明\\n    @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/itxxzSpring4?method=listBoardTopic&topicId=1&userId=10&userName=tom copyright www.itxxz.com \\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n（5）@RequestParam\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/itxxzSpring4?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n            默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n            既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n            内部包含了 request 对象\\n\\n• java.util.Locale \\n            绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n                可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n            可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n            被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n            它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ） 本文来自www.itxxz.com \\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n             它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n             而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n             为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n            可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\nOwner owner = this.clinic.loadOwner(ownerId);\\nmodel.addAttribute(owner);\\nreturn \\\"ownerForm\\\";\\n\\n}\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n（6）@ModelAttribute\\n• 作用域：request\\n • 例如\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){\\n\\n• 或者\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n（7）@Cacheable 和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n（8）@Resource\\n\\n• 例如\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n • 或者\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n（9）@PostConstruct 和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n\\n（10）@Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式：  @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n（11）@Scope\\n• 例如\\n@Scope(\\\"session\\\")\\n@Repository()\\npublic class UserSessionBean implementsSerializable {} \\n\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n       @Scope中可以指定如下值：\\n       singleton:定义bean的范围为每个spring容器一个实例（默认值）\\n       prototype:定义bean可以被多次实例化（使用一次就创建一次）\\n       request:定义bean的范围是http请求（springMVC中有效）\\n       session:定义bean的范围是http会话（springMVC中有效）\\n       global-session:定义bean的范围是全局http会话（portlet中有效） \\n\\n（12）@SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n（13）@InitBinder \\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n\\nSimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\ndateFormat.setLenient(false);\\nbinder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n\\n（14）@Required\\n• 例如\\n @required             \\npublic  setName(String name){}\\n• 说明 copyright www.itxxz.com \\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如\\n@Autowired\\n @Qualifier(\\\"softService\\\")\\nprivate ISoftPMService softPMService;\\n \\n\\n \\n\\n \\n\\n \\n\\n下面是其他注解，包括组合注解\\n（1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下：\\n@ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码；\\n@ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping   和  @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上；\\n2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态\\n（5）@RequestParam，@PathParam，@PathVariable等注解区别\\n@RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务\\n@PathParam：绑定一个路径段资源的方法参数的值\\n@QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法.\\n@HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数\\n@CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数\\n@MatrixParam：用来绑定包含多个   property (属性)=value(值)   方法参数表达式\\n\\n \\n\\n \\n\\n \\n\\nMybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。 \\n\\n@SelectProvider(type = TestSqlProvider.class, method = \\\"getSql\\\") ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(\\\"select * from ....\\\")注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。 \\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。 \\n\\n@Results(value = { \\n@Result(id = true, property = \\\"id\\\", column = \\\"test_id\\\",javaType = String.class, jdbcType = JdbcType.VARCHAR), \\n@Result(property = \\\"testText\\\", column = \\\"test_text\\\",javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = \\\"id\\\", column =\\\"test_id\\\", javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = \\\"id\\\", column = \\\"test_id\\\")，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。 \\n\\n@Param(\\\"id\\\") ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3....的形式，而是对应名称，该名称就在这里定义。 \\n\\n@ResultMap(value = \\\"getByTestText\\\") ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =\\\"getByTestText\\\"，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = \\\"insertSql\\\") ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。 \\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。 \\n\\n@UpdateProvider(type = TestSqlProvider.class, method = \\\"updateSql\\\") ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。 \\n\\n@Param(\\\"testBean\\\") ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。 \\n\\n@DeleteProvider(type = TestSqlProvider.class, method = \\\"deleteSql\\\") ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。 \\n\\n \\n\\nSpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上\\n*用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中\\n*一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(\\\"name\\\")，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List<EasyUITreeNode> getItemTreeNode(@RequestParam(value=\\\"id\\\",defaultValue=\\\"0\\\")long parentId)\\n\\n(4) @Controller\\n控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示\\n(5) @RequestMapping\\nRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired\\n@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource\\n\\n@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes\\n代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n @SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n \\n\\n(8) @PathVariable\\n用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam\\n@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(\\\"name\\\")，它有三个常用参数：defaultValue = \\\"0\\\", required = false, value = \\\"isApp\\\"；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component\\n相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository\\n用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring全家桶注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-15 20:40:23', NULL);
INSERT INTO `t_operation_log` VALUES (817, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\nSpring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n@Scope中可以指定如下值：\\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\\nrequest:定义bean的范围是http请求（springMVC中有效）\\nsession:定义bean的范围是http会话（springMVC中有效）\\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n（14）@Required • 例如 @required\\npublic setName(String name){} • 说明 copyright www.itxxz.com\\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\\n\\n下面是其他注解，包括组合注解 （1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\\n\\n### Mybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\\n\\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\\n\\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\\n\\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\\n\\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\\n\\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\\n\\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\\n\\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\\n\\n### SpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\\n\\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n@SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository 用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"ssm框架注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-15 23:59:29', NULL);
INSERT INTO `t_operation_log` VALUES (818, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\nSpring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n@Scope中可以指定如下值：\\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\\nrequest:定义bean的范围是http请求（springMVC中有效）\\nsession:定义bean的范围是http会话（springMVC中有效）\\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n（14）@Required • 例如 @required\\npublic setName(String name){} • 说明 copyright www.itxxz.com\\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\\n\\n下面是其他注解，包括组合注解 （1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\\n\\n### Mybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\\n\\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\\n\\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\\n\\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\\n\\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\\n\\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\\n\\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\\n\\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\\n\\n### SpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\\n\\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n@SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository 用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring家族注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-16 00:35:49', NULL);
INSERT INTO `t_operation_log` VALUES (819, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\n### Spring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 itxxz.com \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n@Scope中可以指定如下值：\\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\\nrequest:定义bean的范围是http请求（springMVC中有效）\\nsession:定义bean的范围是http会话（springMVC中有效）\\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n（14）@Required • 例如 @required\\npublic setName(String name){} • 说明 copyright www.itxxz.com\\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\\n\\n下面是其他注解，包括组合注解 （1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\\n\\n### Mybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\\n\\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\\n\\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\\n\\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\\n\\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\\n\\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\\n\\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\\n\\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\\n\\n### SpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\\n\\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n@SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository 用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring家族注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-16 00:39:41', NULL);
INSERT INTO `t_operation_log` VALUES (820, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\n### Spring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\npublic String listBoardTopic(int topicId,User user) {}\\n}\\n • 方法\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n@Scope中可以指定如下值：\\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\\nrequest:定义bean的范围是http请求（springMVC中有效）\\nsession:定义bean的范围是http会话（springMVC中有效）\\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n（14）@Required • 例如 @required\\npublic setName(String name){} • 说明 \\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\\n\\n下面是其他注解，包括组合注解 （1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\\n\\n### Mybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\\n\\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\\n\\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\\n\\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\\n\\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\\n\\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\\n\\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\\n\\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\\n\\n### SpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\\n\\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n@SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository 用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring家族注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-16 00:42:09', NULL);
INSERT INTO `t_operation_log` VALUES (821, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"## Springboot注解\\n\\n### 一. 注解列表\\n\\n@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让[spring](http://lib.csdn.net/base/javaee) Boot扫描到Configuration类并把它加入到程序上下文。\\n\\n@Configuration 等同于spring的XML配置文件；使用[Java](http://lib.csdn.net/base/javase)代码可以检查类型安全。\\n\\n@EnableAutoConfiguSuppressWaration 自动配置。\\n\\n@ComponentScan 组件扫描，可自动发现和装配一些Bean。\\n\\n@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。\\n\\n@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。\\n\\n@Autowired自动导入。\\n\\n@PathVariable获取参数。\\n\\n@JsonBackReference解决嵌套外链问题。\\n\\n@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。\\n\\n### 二. 注解(annotations)详解\\n\\n@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\\n\\n``` java\\npackage com.example.myproject;\\n\\nimport org.springframework.boot.SpringApplication;\\n\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\n\\n \\n\\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\\n\\npublic class Application {\\n\\npublic static void main(String[] args) {\\n\\n\\tSpringApplication.run(Application.class, args);\\n\\n\\t}\\n\\n}\\n```\\n\\n@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\\n\\n\\n\\n ```java\\n@RequestMapping(\\\"/test\\\")\\n\\n@ResponseBody\\n\\npublic String test(){\\n\\n\\treturn \\\"OK\\\";\\n\\n}\\n ```\\n\\n\\n\\n@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\\n\\n```java\\n@Controller\\n\\n@RequestMapping(“/demoInfo”)\\n\\npublicclass DemoController {\\n\\n@Autowired\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@RequestMapping(\\\"/hello\\\")\\n\\npublic String hello(Map<String,Object> map){\\n\\n  \\tSystem.out.println(\\\"DemoController.hello()\\\");\\n\\n  \\tmap.put(\\\"hello\\\",\\\"from TemplateController.helloHtml\\\");\\n\\n  \\t//会使用hello.html或者hello.ftl模板进行渲染显示.\\n\\n  \\treturn\\\"/hello\\\";\\n\\n\\t}\\n\\n}\\n\\n```\\n\\n\\n\\n \\n\\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\\n\\n```java\\npackage com.kfit.demo.web;\\n\\n \\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\n\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n \\n\\n \\n\\n@RestController\\n\\n@RequestMapping(“/demoInfo2”)\\n\\npublicclass DemoController2 {\\n\\n \\n\\n@RequestMapping(\\\"/test\\\")\\n\\npublic String test(){\\n\\n  return\\\"ok\\\";\\n\\n}\\n\\n}\\n```\\n\\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\\n\\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库](http://lib.csdn.net/base/mysql)连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\\n\\n@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\\n\\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\\n\\n@Import：用来导入其他配置类。\\n\\n@ImportResource：用来加载xml配置文件。\\n\\n@Autowired：自动导入依赖的bean\\n\\n@Service：一般用于修饰service层的组件\\n\\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\\n\\n@Bean：用@Bean标注方法等价于XML中配置的bean。\\n\\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\\n\\n@Value(value = “#{message}”)\\n\\nprivate String message;\\n\\n \\n\\n@Inject：等价于默认的@Autowired，只是没有required属性；\\n\\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\\n\\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\\n\\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\\n\\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\\n\\n@Autowired\\n\\n@Qualifier(value = “demoInfoService”)\\n\\nprivate DemoInfoService demoInfoService;\\n\\n \\n\\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\\n\\n### JPA注解\\n\\n@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\\n\\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\\n\\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\\n\\n@Column：如果字段名与列名相同，则可以省略。\\n\\n@Id：表示该属性为主键。\\n\\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\\n\\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\\n\\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\\n\\n@JsonIgnore：作用是json序列化时将[Java ](http://lib.csdn.net/base/java)bean中的一些属性忽略掉,序列化和反序列化都受影响。\\n\\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\\n\\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate](http://lib.csdn.net/base/javaee)配置文件中的一对一，一对多，多对一。\\n\\n### springMVC相关注解\\n\\n@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： \\nparams:指定request中必须包含某些参数值是，才让该方法处理。 \\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。 \\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式 \\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等 \\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; \\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\\n\\n@RequestParam：用在方法的参数前面。 \\n@RequestParam \\nString a =request.getParameter(“a”)。\\n\\n@PathVariable:路径变量。如\\n\\nRequestMapping(“user/get/mac/{macAddress}”)\\n\\npublic String getByMacAddress(@PathVariable String macAddress){\\n\\n//do something;\\n\\n}\\n\\n参数与大括号里的名字一样要相同。\\n\\n \\n\\n### 全局异常处理\\n\\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\\n\\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\\n\\n \\n\\n### Spring注解\\n\\n@Controller\\n@Service\\n@Autowired\\n@RequestMapping\\n@RequestParam\\n@ModelAttribute\\n@Cacheable\\n@CacheFlush\\n@Resource\\n@PostConstruct\\n@PreDestroy\\n@Repository\\n@Component （不推荐使用）\\n@Scope\\n@SessionAttributes\\n@InitBinder\\n@Required\\n@Qualifier\\n\\n\\n\\n#### @Controller\\n\\n • 例如\\n@Controller\\n public class SoftCreateController extends SimpleBaseController {}\\n • 或者\\n@Controller(\\\"userController\\\")\\n\\n• 说明\\n @Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写 \\n\\n#### @Service\\n\\n• 例如\\n @Service\\n public class SoftCreateServiceImpl implements ISoftCreateService {}\\n • 或者\\n @Service(\\\"softCreateServiceImpl\\\")\\n\\n • 说明\\n@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写\\n\\n#### @Autowired\\n\\n• 例如\\n @Autowired\\nprivate ISoftPMService softPMService;\\n• 或者\\n@Autowired(required=false)\\nprivate ISoftPMService softPMService = new SoftPMServiceImpl();\\n\\n • 说明\\n@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。 \\n\\n与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();\\n\\n@Autowired 标注作用于 Map 类型时，如果 Map 的 key 为 String 类型，则 Spring 会将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。\\n\\n@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。\\n\\n#### @RequestMapping\\n\\n• 类\\n```java\\n@Controller\\n@RequestMapping(\\\"/bbtForum.do\\\")\\npublic class BbtForumController {\\n       @RequestMapping(params = \\\"method=listBoardTopic\\\")\\n \\tpublic String listBoardTopic(int topicId,User user) {}\\n}\\n```\\n • 方法\\n```java\\n @RequestMapping(\\\"/softpg/downSoftPg.do\\\")\\n @RequestMapping(value=\\\"/softpg/ajaxLoadSoftId.do\\\",method = POST)\\n@RequestMapping(value = \\\"/osu/product/detail.do\\\", params = { \\\"modify=false\\\" }, method =POST)\\n```\\n\\n • 说明\\n  @RequestMapping 可以声明到类或方法上\\n\\n• 参数绑定说明\\n如果我们使用以下的 URL 请求：\\nhttp://localhost/xxxx?method=listBoardTopic&topicId=1&userId=10&userName=tom\\ntopicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的 userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。\\n\\n#### @RequestParam\\n\\n• 参数绑定说明\\n@RequestParam(\\\"id\\\")\\nhttp://localhost/xxxx?method=listBoardTopic&id=1&userId=10&userName=tom\\nlistBoardTopic(@RequestParam(\\\"id\\\")int topicId,User user) 中的 topicId 绑定到 id 这个 URL 参数， 那么可以通过对入参使用 @RequestParam 注解来达到目的 \\n@RequestParam(required=false)：参数不是必须的，默认为true\\n@RequestParam(value=\\\"id\\\",required=false)\\n\\n请求处理方法入参的可选类型\\n• Java 基本数据类型和 String\\n      默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则\\n\\n • request/response/session\\n      既可以是 Servlet API 的也可以是 Portlet API 对应的对象，Spring 会将它们绑定到Servlet 和 Portlet 容器的相应对象上 \\n\\n• org.springframework.web.context.request.WebRequest\\n      内部包含了 request 对象\\n\\n• java.util.Locale \\n      绑定到 request 对应的 Locale 对象上\\n\\n• java.io.InputStream/java.io.Reader\\n        可以借此访问 request 的内容 \\n\\n• java.io.OutputStream / java.io.Writer\\n      可以借此操作 response 的内容\\n\\n• 任何标注了 @RequestParam 注解的入参 \\n      被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。\\n\\n• java.util.Map / org.springframework.ui.ModelMap\\n      它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）\\n\\n• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）\\n       它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。\\n       而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调 整\\n\\n • org.springframework.validation.Errors / org.springframework.validation.BindingResult\\n       为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面 \\n\\n• org.springframework.web.bind.support.SessionStatus\\n      可以通过该类型 status 对象显式结束表单的处理，这相当于触发 session 清除其中的通过@SessionAttributes 定义的属性 \\n\\n请求处理方法返回值的可选类型\\n\\n• void\\n此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：\\n@RequestMapping(\\\"/welcome.do\\\")\\npublic void welcomeHandler() {}\\n对应的逻辑视图名为 “ welcome ”\\n\\n• String\\n此时逻辑视图名为返回的字符，如以下的方法：\\n\\n```java\\n@RequestMapping(method = RequestMethod.GET)\\npublic String setupForm(@RequestParam(\\\"ownerId\\\") int ownerId, ModelMap model) {\\n\\n    Owner owner = this.clinic.loadOwner(ownerId);\\n    model.addAttribute(owner);\\n    return \\\"ownerForm\\\";\\n\\n}\\n```\\n\\n\\n对应的逻辑视图名为 “ ownerForm ”\\n\\n• org.springframework.ui.ModelMap\\n和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：\\n@RequestMapping(\\\"/vets.do\\\")\\npublic ModelMap vetsHandler() { \\nreturn new ModelMap(this.clinic.getVets());\\n}\\n对应的逻辑视图名为 “ vets ” ，返回的 ModelMap 将被作为请求对应的模型对象，可以在 JSP 视图页面中访问到。\\n\\n• ModelAndView\\n当然还可以是传统的 ModelAndView 。\\n\\n#### @ModelAttribute\\n\\n• 作用域：request\\n • 例如\\n\\n```java\\n@RequestMapping(\\\"/base/userManageCooper/init.do\\\")\\npublic String handleInit(@ModelAttribute(\\\"queryBean\\\") ManagedUser sUser,Model model,){}\\n```\\n\\n\\n\\n• 或者\\n\\n```java\\n@ModelAttribute(\\\"coopMap\\\")// 将coopMap 返回到页 面\\npublic Map<Long,CooperatorInfo> coopMapItems(){}\\n```\\n\\n\\n\\n• 说明\\n@ModelAttribute 声明在属性上，表示该属性的value 来源于model 里\\\"queryBean\\\" ，并被保存到model 里@ModelAttribute 声明在方法上，表示该方法的返回值被保存到model 里 \\n\\n@ModelAttribute使用大致有有两种：\\n\\n运用在**参数**上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；\\n\\n运用在**方法**上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；\\n\\n\\n#### @Cacheable和@CacheFlush\\n\\n • @Cacheable ：声明一个方法的返回值应该被缓 存\\n 例如：@Cacheable(modelId = \\\"testCaching\\\")\\n\\n• @CacheFlush ：声明一个方法是清空缓存的触发器\\n例如：@CacheFlush(modelId = \\\"testCaching\\\")\\n\\n• 说明\\n要配合缓存处理器使用\\n\\n\\n#### @Resource\\n\\n• 例如\\n\\n```java\\n@Resource\\nprivate DataSource dataSource; // inject the bean named ‘dataSource’\\n```\\n\\n\\n • 或者\\n\\n```java\\n@Resource(name=\\\"dataSource\\\")\\n@Resource(type=DataSource.class)\\n```\\n\\n• 说明\\n@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找， \\n此时与@Autowired 类 似.\\n\\n在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为\\\"\\\")，否则注入失败；\\n\\n#### @PostConstruct和@PreDestroy\\n\\n• @PostConstruct\\n在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执 行\\n（注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入））。\\n\\n• @PreDestroy\\n\\n在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。 \\n\\n@Repository\\n• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。\\n\\n#### @Component （不推荐使用）\\n\\n@Component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式： @Repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。\\n目前版本（2.5 ）中，这些注解与@Component 的语义是一样的，完全通用， 在Spring 以后的版本中可能会给它们追加更多的语义。 所以，我们推荐使用@Repository 、@Service 、@Controller 来替代@Component 。\\n\\n#### @Scope\\n\\n• 例如@Scope(“session”) @Repository() public class UserSessionBean implementsSerializable {}\\n• 说明\\n\\n在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，\\n同样可以通过@Scope 注解来完成\\n\\n@Scope中可以指定如下值：\\nsingleton:定义bean的范围为每个spring容器一个实例（默认值）\\nprototype:定义bean可以被多次实例化（使用一次就创建一次）\\nrequest:定义bean的范围是http请求（springMVC中有效）\\nsession:定义bean的范围是http会话（springMVC中有效）\\nglobal-session:定义bean的范围是全局http会话（portlet中有效）\\n\\n#### @SessionAttributes\\n\\n• 说明\\nSpring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，\\n以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。\\n这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。\\n@SessionAttributes 只能声明在类上，而不能声明在方法上。\\n• 例如\\n@SessionAttributes(\\\"currUser\\\") // 将ModelMap 中属性名为currUser 的属性\\n@SessionAttributes({\\\"attr1\\\",\\\"attr2\\\"})\\n@SessionAttributes(types = User.class)\\n@SessionAttributes(types = {User.class,Dept.class})\\n@SessionAttributes(types = {User.class,Dept.class},value={\\\"attr1\\\",\\\"attr2\\\"})\\n\\n#### @InitBinder\\n\\n• 说明\\n如果希望某个属性编辑器仅作用于特定的 Controller ，\\n可以在 Controller 中定义一个标注 @InitBinder 注解的方法，\\n可以在该方法中向 Controller 了注册若干个属性编辑器\\n\\n• 例如\\n\\n```java\\n@InitBinder\\npublic void initBinder(WebDataBinder binder) {\\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n    dateFormat.setLenient(false);\\n    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\\n}\\n```\\n\\n\\n（14）@Required • 例如 @required\\npublic setName(String name){} • 说明 \\n\\n@ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非 setXxxx() 类型的方法则被忽略。\\n\\n（15）@Qualifier\\n\\n• 例如 @Autowired @Qualifier(“softService”) private ISoftPMService softPMService;\\n\\n下面是其他注解，包括组合注解 （1）@Autowired\\n\\n@ApiOperation和@ApiParam为添加的API相关注解，个参数说明如下： @ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； @ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”\\n\\n实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。\\n\\nSwagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档。\\n\\n（2）@RequestMapping 和 @GetMapping @PostMapping 区别\\n\\n@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上\\n\\n@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。该注解将HTTP Post 映射到 特定的处理方法上(3) @ResponseBody 和 @RequestBody 的作用\\n\\n@ResponseBody是作用在方法上的， 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据\\n\\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机： 返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上. 作用：该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上； 2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。使用时机： GET、POST方式提时， 根据request header Content-Type的值来判断:\\n\\n（4）@Transactional 事物注解\\n\\n@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。功能：在出现异常的情况下，保证数据的一致性；数据提交操作回滚至异常发生前的状态 （5）@RequestParam，@PathParam，@PathVariable等注解区别 @RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充。。\\n\\n@PathParam这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包\\n\\n（6）\\n\\n@FormParam：可以用来注入web表单的参数为REST风格的Web服务 @PathParam：绑定一个路径段资源的方法参数的值 @QueryParam：绑定一个路径段资源的方法参数的值，和RequestParam作用一致，跟@pathparam不同,@queryparam中,指定的是URL中的参数是以键值对的形式出现的。用在get方法. @HeaderParam; 提取　　HTTP标头（ HTTP header）并将它绑定到一个方法的参数 @CookieParam；读取信息存储为一个cookie，并将它绑定到一个方法的参数 @MatrixParam：用来绑定包含多个 property (属性)=value(值) 方法参数表达式\\n\\n### Mybatis\\n\\n@CacheNamespace(size = 512) ： 定义在该命名空间内允许使用内置缓存，最大值为512个对象引用，读写默认是开启的，缓存内省刷新时间为默认3600000毫秒，写策略是拷贝整个对象镜像到全新堆（如同CopyOnWriteList）因此线程安全。\\n\\n@SelectProvider(type = TestSqlProvider.class, method = “getSql”) ： 提供查询的SQL语句，如果你不用这个注解，你也可以直接使用@Select(“select * from …”)注解，把查询SQL抽取到一个类里面，方便管理，同时复杂的SQL也容易操作，type =TestSqlProvider.class就是存放SQL语句的类，而method =\\\"getSql\\\"表示get接口方法需要到TestSqlProvider类的getSql方法中获取SQL语句。\\n\\n@Options(useCache = true, flushCache = false, timeout = 10000) ： 一些查询的选项开关，比如useCache = true表示本次查询结果被缓存以提高下次查询速度，flushCache = false表示下次查询时不刷新缓存，timeout = 10000表示查询结果缓存10000秒。\\n\\n@Results(value = { @Result(id = true, property = “id”, column = “test_id”,javaType = String.class, jdbcType = JdbcType.VARCHAR), @Result(property = “testText”, column = “test_text”,javaType = String.class, jdbcType = JdbcType.VARCHAR) }) ： 表示sql查询返回的结果集，@Results是以@Result为元素的数组，@Result表示单条属性-字段的映射关系，如：@Result(id = true, property = “id”, column =“test_id”, javaType = String.class, jdbcType = JdbcType.VARCHAR)可以简写为：@Result(id =true, property = “id”, column = “test_id”)，id = true表示这个test_id字段是个PK，查询时mybatis会给予必要的优化，应该说数组中所有的@Result组成了单个记录的映射关系，而@Results则单个记录的集合。另外还有一个非常重要的注解@ResultMap也和@Results差不多，到时会讲到。\\n\\n@Param(“id”) ：全局限定别名，定义查询参数在sql语句中的位置不再是顺序下标0,1,2,3…的形式，而是对应名称，该名称就在这里定义。\\n\\n@ResultMap(value = “getByTestText”) ：重要的注解，可以解决复杂的映射关系，包括resultMap嵌套，鉴别器discriminator等等。注意一旦你启用该注解，你将不得不在你的映射文件中配置你的resultMap，而value = \\\"getByTestText\\\"即为映射文件中的resultMap ID(注意此处的value =“getByTestText”，必须是在映射文件中指定命名空间路径)。@ResultMap在某些简单场合可以用@Results代替，但是复杂查询，比如联合、嵌套查询@ResultMap就会显得解耦方便更容易管理\\n\\n@InsertProvider(type = TestSqlProvider.class, method = “insertSql”) ：用法和含义@SelectProvider一样，只不过是用来插入数据库而用的。\\n\\n@Options(flushCache = true, timeout = 20000) ：对于需要更新数据库的操作，需要重新刷新缓存flushCache = true使缓存同步。\\n\\n@UpdateProvider(type = TestSqlProvider.class, method = “updateSql”) ：用法和含义@SelectProvider一样，只不过是用来更新数据库而用的。\\n\\n@Param(“testBean”) ：是一个自定义的对象，指定了sql语句中的表现形式，如果要在sql中引用对象里面的属性，只要使用testBean.id，testBean.textText即可，mybatis会通过反射找到这些属性值。\\n\\n@DeleteProvider(type = TestSqlProvider.class, method = “deleteSql”) ：用法和含义@SelectProvider一样，只不过是用来删除数据而用的。\\n\\n### SpringMVC\\n\\n（1）@PathVariable绑定URI模板变量值。注解绑定它传过来的值到方法的参数上 *用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n@PathVariable是用来获得请求url中的动态参数的，用于将请求URL中的模板变量映射到功能处理方法的参数上\\n\\n（2）@RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求,类似于struts的action请求\\n\\n（3）@responsebody表示该方法的返回结果直接写入HTTP response body中 *一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response *body中\\n\\n在SpringMVC后台控制层获取参数的方式主要有两种:\\n\\n一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取。这里主要讲这个注解 @RequestParam\\n\\n接下来我们看一下@RequestParam注解主要有哪些参数：\\n\\nvalue：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；\\n\\nrequired：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；\\n\\ndefaultValue：默认值，表示如果请求中没有同名参数时的默认值，例如：\\n\\npublic List getItemTreeNode(@RequestParam(value=“id”,defaultValue=“0”)long parentId)\\n\\n(4) @Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示 (5) @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\\n\\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\\n\\nvalue， method；\\n\\nvalue: 指定请求的实际地址，指定的地址可以是URI Template 模式method：指定请求的method类型， GET、POST、PUT、DELETE等；\\n\\nconsumes，produces\\n\\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\\n\\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\\n\\nparams，headers\\n\\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\\n\\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\\n\\n(6) @Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入\\n\\n共同点:两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\\n\\n不同点: （1）@Autowired:@Autowired为Spring提供的注解，需要导入包@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）装配，可以结合@Qualifier注解一起使用\\n\\n（2）@Resource:@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\\n\\n(7) @ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\\n\\n@SessionAttributes即将值放到session作用域中，写在class上面。\\n\\n(8) @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\\n\\n(9)@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\\n\\n(10)@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\\n\\n(11)@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\\n\\n(12)@Repository 用于注解dao层，在daoImpl类上面注解\",\"articleCover\":\"https://static.jishudaniu.com/articles/9788a7c1af82df0391d3c33329057e2f.jpeg\",\"articleTitle\":\"spring家族注解汇总\",\"categoryName\":\"backend\",\"id\":60,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '116.23.168.141', '广东省广州市 电信', '2022-03-16 00:47:39', NULL);
INSERT INTO `t_operation_log` VALUES (822, '文章模块', '新增或修改', '/admin/articles', 'com.jishudaniu.dkblog.controller.ArticleController.saveOrUpdateArticle', '添加或修改文章', '[{\"articleContent\":\"### 资源不在于多而在于精，分享一些常用的\\n\\n#### 开源项目：\\n\\n1. [开源中国，程序员获取一手资讯](https://www.oschina.net/)\\n2. [github全球最大的代码托管平台](https://github.com)\\n3. [gitee中国最大的托管平台](https://gitee.com)\\n4. https://sourceforge.net/\\n5. [和鲸社区（python项目比较多）](https://www.heywhale.com/)\\n\\n#### 疑难杂症解决：\\n\\n1. [google](https://www.google.com/)\\n2. [stackoverflow（解决bug的好去处）](https://www.stackoverflow.com/)\\n3. [baidu](https://www.baidu.com/)\\n4. [b乎](https://www.zhihu.com/)\\n5. [简书质量一直可以](https://www.jianshu.com/)\\n6. [博客园,反正是比csdn强](https://www.cnblogs.com/)\\n7. https://www.csdn.net/\\n8. [稀土掘金](https://juejin.cn/)\\n9. [b站](https://bilibili.com/)\\n\\n#### 素材:\\n\\n1. [jQuery插件库](https://www.iconfont.cn/)\\n2. https://pixabay.com/zh/\\n3. https://unsplash.com/\\n4. http://www.pexels.com/\\n5. https://gitmind.cn/app/doc/d74790416\\n6. https://zhutix.com/ico/gang-chrome/\\n\\n#### 在线设计类:\\n\\n1. [在线PS](https://www.uupoop.com/#/old)\\n2. [在线音频剪辑](https://www.weixinsyt.com/)\\n3. [在线视频剪辑](https://www.kapwing.com/)\\n4. [Gif Super，一个帮助您快速编辑GIF的在线工具网站](https://gifsuper.com/)\\n\\n#### 在线编程:\\n\\n1. https://jsrun.net/\\n2. [CodePen: Online Code Editor and Front End Web Developer Community](https://codepen.io/)\\n3. [编程中国](https://www.bccn.net/)\\n\\n####  学习网站:\\n\\n1. [mall-learning大佬macrozheng写的文档](http://www.macrozheng.com/#/?id=mall-learning)\\n2. [JavaGuide,github100kstar的学习笔记](https://javaguide.cn/)\\n3. [GitHub指南,作者10000小时的github使用经验](http://github.phodal.com/)\\n4. [CodeGym](https://codegym.cc/)\\n5. [菜鸟教程 - 学的不仅是技术，更是梦想！](https://www.runoob.com/)\\n6. [w3cschool - 编程狮，随时随地学编程](https://www.w3cschool.cn/)\\n7. [Alibaba Java 技术图谱-阿里云开发者社区](https://developer.aliyun.com/graph/java)\\n8. [CS-Notes](https://www.cyc2018.xyz/#算法)\\n9. [Learn to Code — For Free — Coding Courses for Busy People](https://www.freecodecamp.org/learn/?messages=success[0]%3Dflash.signin-success)\\n10. [Git中文教程](https://git-scm.com/book/zh/v2)\\n\\n\",\"articleCover\":\"https://static.jishudaniu.com/articles/4d83f8cb0c337a138d07d026e34c5949.jpg\",\"articleTitle\":\"个人收藏网站分享\",\"categoryName\":\"backend\",\"id\":58,\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, 'DarkChen', '119.32.47.238', '广东省广州市 联通', '2022-03-20 15:28:51', NULL);

-- ----------------------------
-- Table structure for t_page
-- ----------------------------
DROP TABLE IF EXISTS `t_page`;
CREATE TABLE `t_page`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '页面id',
  `page_name` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '页面名',
  `page_label` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '页面标签',
  `page_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '页面封面',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 903 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '页面' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_page
-- ----------------------------
INSERT INTO `t_page` VALUES (1, '首页', 'home', '', '2021-08-07 10:32:36', '2021-10-04 15:42:46');
INSERT INTO `t_page` VALUES (2, '归档', 'archive', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:43:14');
INSERT INTO `t_page` VALUES (3, '分类', 'category', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:43:31');
INSERT INTO `t_page` VALUES (4, '标签', 'tag', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:43:38');
INSERT INTO `t_page` VALUES (5, '相册', 'album', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:43:53');
INSERT INTO `t_page` VALUES (6, '友链', 'link', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:44:02');
INSERT INTO `t_page` VALUES (7, '关于', 'about', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:44:08');
INSERT INTO `t_page` VALUES (8, '留言', 'message', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:44:17');
INSERT INTO `t_page` VALUES (9, '个人中心', 'user', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-07 10:32:36', '2021-10-04 15:45:17');
INSERT INTO `t_page` VALUES (10, '文章列表', 'articleList', 'https://bing.ioliu.cn/v1/rand?w=1280&h=776', '2021-08-10 15:36:19', '2021-10-04 15:45:45');

-- ----------------------------
-- Table structure for t_photo
-- ----------------------------
DROP TABLE IF EXISTS `t_photo`;
CREATE TABLE `t_photo`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_id` int NOT NULL COMMENT '相册id',
  `photo_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片名',
  `photo_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '照片描述',
  `photo_src` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片地址',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '照片' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_photo
-- ----------------------------

-- ----------------------------
-- Table structure for t_photo_album
-- ----------------------------
DROP TABLE IF EXISTS `t_photo_album`;
CREATE TABLE `t_photo_album`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册名',
  `album_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册描述',
  `album_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册封面',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态值 1公开 2私密',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '相册' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_photo_album
-- ----------------------------

-- ----------------------------
-- Table structure for t_resource
-- ----------------------------
DROP TABLE IF EXISTS `t_resource`;
CREATE TABLE `t_resource`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '资源名',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '权限路径',
  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '请求方式',
  `parent_id` int NULL DEFAULT NULL COMMENT '父权限id',
  `is_anonymous` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否匿名访问 0否 1是',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 280 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_resource
-- ----------------------------
INSERT INTO `t_resource` VALUES (165, '分类模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (166, '博客信息模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (167, '友链模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (168, '文章模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (169, '日志模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (170, '标签模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (171, '照片模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (172, '用户信息模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (173, '用户账号模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (174, '留言模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (175, '相册模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (176, '菜单模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (177, '角色模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (178, '评论模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (179, '资源模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (180, '页面模块', NULL, NULL, NULL, 0, '2021-08-11 21:04:21', NULL);
INSERT INTO `t_resource` VALUES (181, '查看博客信息', '/', 'GET', 166, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:29');
INSERT INTO `t_resource` VALUES (182, '查看关于我信息', '/about', 'GET', 166, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:29');
INSERT INTO `t_resource` VALUES (183, '查看后台信息', '/admin', 'GET', 166, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (184, '修改关于我信息', '/admin/about', 'PUT', 166, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (185, '查看后台文章', '/admin/articles', 'GET', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (186, '添加或修改文章', '/admin/articles', 'POST', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (187, '恢复或删除文章', '/admin/articles', 'PUT', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (188, '物理删除文章', '/admin/articles', 'DELETE', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (189, '上传文章图片', '/admin/articles/images', 'POST', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (190, '修改文章置顶', '/admin/articles/top', 'PUT', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (191, '根据id查看后台文章', '/admin/articles/*', 'GET', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (192, '查看后台分类列表', '/admin/categories', 'GET', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (193, '添加或修改分类', '/admin/categories', 'POST', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (194, '删除分类', '/admin/categories', 'DELETE', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (195, '搜索文章分类', '/admin/categories/search', 'GET', 165, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (196, '查询后台评论', '/admin/comments', 'GET', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (197, '删除评论', '/admin/comments', 'DELETE', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (198, '审核评论', '/admin/comments/review', 'PUT', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (199, '查看后台友链列表', '/admin/links', 'GET', 167, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (200, '保存或修改友链', '/admin/links', 'POST', 167, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (201, '删除友链', '/admin/links', 'DELETE', 167, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (202, '查看菜单列表', '/admin/menus', 'GET', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (203, '新增或修改菜单', '/admin/menus', 'POST', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (204, '删除菜单', '/admin/menus/*', 'DELETE', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (205, '查看后台留言列表', '/admin/messages', 'GET', 174, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (206, '删除留言', '/admin/messages', 'DELETE', 174, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (207, '审核留言', '/admin/messages/review', 'PUT', 174, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (208, '查看操作日志', '/admin/operation/logs', 'GET', 169, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (209, '删除操作日志', '/admin/operation/logs', 'DELETE', 169, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (210, '获取页面列表', '/admin/pages', 'GET', 180, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (211, '保存或更新页面', '/admin/pages', 'POST', 180, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (212, '删除页面', '/admin/pages/*', 'DELETE', 180, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (213, '根据相册id获取照片列表', '/admin/photos', 'GET', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (214, '保存照片', '/admin/photos', 'POST', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (215, '更新照片信息', '/admin/photos', 'PUT', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (216, '删除照片', '/admin/photos', 'DELETE', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (217, '移动照片相册', '/admin/photos/album', 'PUT', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (218, '查看后台相册列表', '/admin/photos/albums', 'GET', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (219, '保存或更新相册', '/admin/photos/albums', 'POST', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (220, '上传相册封面', '/admin/photos/albums/cover', 'POST', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (221, '获取后台相册列表信息', '/admin/photos/albums/info', 'GET', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (222, '根据id删除相册', '/admin/photos/albums/*', 'DELETE', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (223, '根据id获取后台相册信息', '/admin/photos/albums/*/info', 'GET', 175, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (224, '更新照片删除状态', '/admin/photos/delete', 'PUT', 171, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (225, '查看资源列表', '/admin/resources', 'GET', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (226, '新增或修改资源', '/admin/resources', 'POST', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (227, '导入swagger接口', '/admin/resources/import/swagger', 'GET', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (228, '删除资源', '/admin/resources/*', 'DELETE', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (229, '保存或更新角色', '/admin/role', 'POST', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (230, '查看角色菜单选项', '/admin/role/menus', 'GET', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (231, '查看角色资源选项', '/admin/role/resources', 'GET', 179, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (232, '查询角色列表', '/admin/roles', 'GET', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (233, '删除角色', '/admin/roles', 'DELETE', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (234, '查询后台标签列表', '/admin/tags', 'GET', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (235, '添加或修改标签', '/admin/tags', 'POST', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (236, '删除标签', '/admin/tags', 'DELETE', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (237, '搜索文章标签', '/admin/tags/search', 'GET', 170, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (238, '查看当前用户菜单', '/admin/user/menus', 'GET', 176, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (239, '查询后台用户列表', '/admin/users', 'GET', 173, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (240, '修改用户禁用状态', '/admin/users/disable', 'PUT', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (241, '查看在线用户', '/admin/users/online', 'GET', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (242, '修改管理员密码', '/admin/users/password', 'PUT', 173, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (243, '查询用户角色选项', '/admin/users/role', 'GET', 177, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (244, '修改用户角色', '/admin/users/role', 'PUT', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (245, '下线用户', '/admin/users/*/online', 'DELETE', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (246, '获取网站配置', '/admin/website/config', 'GET', 166, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (247, '更新网站配置', '/admin/website/config', 'PUT', 166, 0, '2021-08-11 21:04:22', '2022-02-21 21:49:14');
INSERT INTO `t_resource` VALUES (248, '根据相册id查看照片列表', '/albums/*/photos', 'GET', 171, 1, '2021-08-11 21:04:22', '2021-08-11 21:06:35');
INSERT INTO `t_resource` VALUES (249, '查看首页文章', '/articles', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:45');
INSERT INTO `t_resource` VALUES (250, '查看文章归档', '/articles/archives', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:47');
INSERT INTO `t_resource` VALUES (251, '根据条件查询文章', '/articles/condition', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:47');
INSERT INTO `t_resource` VALUES (252, '搜索文章', '/articles/search', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:48');
INSERT INTO `t_resource` VALUES (253, '根据id查看文章', '/articles/*', 'GET', 168, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:49');
INSERT INTO `t_resource` VALUES (254, '点赞文章', '/articles/*/like', 'POST', 168, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (255, '查看分类列表', '/categories', 'GET', 165, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:26');
INSERT INTO `t_resource` VALUES (256, '查询评论', '/comments', 'GET', 178, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:33');
INSERT INTO `t_resource` VALUES (257, '添加评论', '/comments', 'POST', 178, 0, '2021-08-11 21:04:22', '2021-08-11 21:10:05');
INSERT INTO `t_resource` VALUES (258, '评论点赞', '/comments/*/like', 'POST', 178, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (259, '查询评论下的回复', '/comments/*/replies', 'GET', 178, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:30');
INSERT INTO `t_resource` VALUES (260, '查看友链列表', '/links', 'GET', 167, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:41');
INSERT INTO `t_resource` VALUES (261, '查看留言列表', '/messages', 'GET', 174, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:14');
INSERT INTO `t_resource` VALUES (262, '添加留言', '/messages', 'POST', 174, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:15');
INSERT INTO `t_resource` VALUES (263, '获取相册列表', '/photos/albums', 'GET', 175, 0, '2021-08-11 21:04:22', '2022-02-21 21:48:50');
INSERT INTO `t_resource` VALUES (264, '用户注册', '/register', 'POST', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:01');
INSERT INTO `t_resource` VALUES (265, '查询标签列表', '/tags', 'GET', 170, 1, '2021-08-11 21:04:22', '2021-08-11 21:06:30');
INSERT INTO `t_resource` VALUES (267, '更新用户头像', '/users/avatar', 'POST', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (268, '发送邮箱验证码', '/users/code', 'GET', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:02');
INSERT INTO `t_resource` VALUES (269, '绑定用户邮箱', '/users/email', 'POST', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (270, '更新用户信息', '/users/info', 'PUT', 172, 0, '2021-08-11 21:04:22', NULL);
INSERT INTO `t_resource` VALUES (271, 'qq登录', '/users/oauth/qq', 'POST', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:06');
INSERT INTO `t_resource` VALUES (272, '微博登录', '/users/oauth/weibo', 'POST', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:06');
INSERT INTO `t_resource` VALUES (273, '修改密码', '/users/password', 'PUT', 173, 1, '2021-08-11 21:04:22', '2021-08-11 21:07:09');
INSERT INTO `t_resource` VALUES (274, '上传语音', '/voice', 'POST', 166, 1, '2021-08-11 21:04:22', '2021-08-11 21:05:33');
INSERT INTO `t_resource` VALUES (275, '上传访客信息', '/report', 'POST', 166, 1, '2021-08-24 11:24:08', '2021-08-24 11:24:10');
INSERT INTO `t_resource` VALUES (276, '获取用户区域分布', '/admin/users/area', 'GET', 173, 0, '2021-08-24 11:24:33', NULL);
INSERT INTO `t_resource` VALUES (277, '获取最新文章', '/newest/articlelist', 'GET', 168, 1, '2022-02-05 01:51:31', '2022-02-11 22:10:50');
INSERT INTO `t_resource` VALUES (279, '获取最热文章', '/hottest/articlelist', 'GET', 168, 1, '2022-02-11 22:11:49', '2022-02-11 22:12:06');

-- ----------------------------
-- Table structure for t_role
-- ----------------------------
DROP TABLE IF EXISTS `t_role`;
CREATE TABLE `t_role`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色名',
  `role_label` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色描述',
  `is_disable` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否禁用  0否 1是',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_role
-- ----------------------------
INSERT INTO `t_role` VALUES (1, '管理员', 'admin', 0, '2021-03-22 14:10:21', '2021-08-24 11:25:30');
INSERT INTO `t_role` VALUES (2, '用户', 'user', 0, '2021-03-22 14:25:25', '2021-08-11 21:12:21');
INSERT INTO `t_role` VALUES (3, '测试', 'test', 0, '2021-03-22 14:42:23', '2021-08-24 11:25:39');

-- ----------------------------
-- Table structure for t_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `t_role_menu`;
CREATE TABLE `t_role_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  `menu_id` int NULL DEFAULT NULL COMMENT '菜单id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2310 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_role_menu
-- ----------------------------
INSERT INTO `t_role_menu` VALUES (1397, 8, 1);
INSERT INTO `t_role_menu` VALUES (1398, 8, 2);
INSERT INTO `t_role_menu` VALUES (1399, 8, 6);
INSERT INTO `t_role_menu` VALUES (1400, 8, 7);
INSERT INTO `t_role_menu` VALUES (1401, 8, 8);
INSERT INTO `t_role_menu` VALUES (1402, 8, 9);
INSERT INTO `t_role_menu` VALUES (1403, 8, 10);
INSERT INTO `t_role_menu` VALUES (1404, 8, 3);
INSERT INTO `t_role_menu` VALUES (1405, 8, 11);
INSERT INTO `t_role_menu` VALUES (1406, 8, 12);
INSERT INTO `t_role_menu` VALUES (1407, 8, 202);
INSERT INTO `t_role_menu` VALUES (1408, 8, 13);
INSERT INTO `t_role_menu` VALUES (1409, 8, 14);
INSERT INTO `t_role_menu` VALUES (1410, 8, 201);
INSERT INTO `t_role_menu` VALUES (1411, 8, 4);
INSERT INTO `t_role_menu` VALUES (1412, 8, 16);
INSERT INTO `t_role_menu` VALUES (1413, 8, 15);
INSERT INTO `t_role_menu` VALUES (1414, 8, 17);
INSERT INTO `t_role_menu` VALUES (1415, 8, 18);
INSERT INTO `t_role_menu` VALUES (1416, 8, 19);
INSERT INTO `t_role_menu` VALUES (1417, 8, 20);
INSERT INTO `t_role_menu` VALUES (1418, 8, 5);
INSERT INTO `t_role_menu` VALUES (1595, 9, 1);
INSERT INTO `t_role_menu` VALUES (1596, 9, 2);
INSERT INTO `t_role_menu` VALUES (1597, 9, 6);
INSERT INTO `t_role_menu` VALUES (1598, 9, 7);
INSERT INTO `t_role_menu` VALUES (1599, 9, 8);
INSERT INTO `t_role_menu` VALUES (1600, 9, 9);
INSERT INTO `t_role_menu` VALUES (1601, 9, 10);
INSERT INTO `t_role_menu` VALUES (1602, 9, 3);
INSERT INTO `t_role_menu` VALUES (1603, 9, 11);
INSERT INTO `t_role_menu` VALUES (1604, 9, 12);
INSERT INTO `t_role_menu` VALUES (1605, 9, 202);
INSERT INTO `t_role_menu` VALUES (1606, 9, 13);
INSERT INTO `t_role_menu` VALUES (1607, 9, 14);
INSERT INTO `t_role_menu` VALUES (1608, 9, 201);
INSERT INTO `t_role_menu` VALUES (1609, 9, 4);
INSERT INTO `t_role_menu` VALUES (1610, 9, 16);
INSERT INTO `t_role_menu` VALUES (1611, 9, 15);
INSERT INTO `t_role_menu` VALUES (1612, 9, 17);
INSERT INTO `t_role_menu` VALUES (1613, 9, 18);
INSERT INTO `t_role_menu` VALUES (1614, 9, 19);
INSERT INTO `t_role_menu` VALUES (1615, 9, 20);
INSERT INTO `t_role_menu` VALUES (1616, 9, 5);
INSERT INTO `t_role_menu` VALUES (1639, 13, 2);
INSERT INTO `t_role_menu` VALUES (1640, 13, 6);
INSERT INTO `t_role_menu` VALUES (1641, 13, 7);
INSERT INTO `t_role_menu` VALUES (1642, 13, 8);
INSERT INTO `t_role_menu` VALUES (1643, 13, 9);
INSERT INTO `t_role_menu` VALUES (1644, 13, 10);
INSERT INTO `t_role_menu` VALUES (1645, 13, 3);
INSERT INTO `t_role_menu` VALUES (1646, 13, 11);
INSERT INTO `t_role_menu` VALUES (1647, 13, 12);
INSERT INTO `t_role_menu` VALUES (2252, 1, 1);
INSERT INTO `t_role_menu` VALUES (2253, 1, 2);
INSERT INTO `t_role_menu` VALUES (2254, 1, 6);
INSERT INTO `t_role_menu` VALUES (2255, 1, 7);
INSERT INTO `t_role_menu` VALUES (2256, 1, 8);
INSERT INTO `t_role_menu` VALUES (2257, 1, 9);
INSERT INTO `t_role_menu` VALUES (2258, 1, 10);
INSERT INTO `t_role_menu` VALUES (2259, 1, 3);
INSERT INTO `t_role_menu` VALUES (2260, 1, 11);
INSERT INTO `t_role_menu` VALUES (2261, 1, 12);
INSERT INTO `t_role_menu` VALUES (2262, 1, 202);
INSERT INTO `t_role_menu` VALUES (2263, 1, 13);
INSERT INTO `t_role_menu` VALUES (2264, 1, 201);
INSERT INTO `t_role_menu` VALUES (2265, 1, 213);
INSERT INTO `t_role_menu` VALUES (2266, 1, 14);
INSERT INTO `t_role_menu` VALUES (2267, 1, 15);
INSERT INTO `t_role_menu` VALUES (2268, 1, 16);
INSERT INTO `t_role_menu` VALUES (2269, 1, 4);
INSERT INTO `t_role_menu` VALUES (2270, 1, 214);
INSERT INTO `t_role_menu` VALUES (2271, 1, 209);
INSERT INTO `t_role_menu` VALUES (2272, 1, 17);
INSERT INTO `t_role_menu` VALUES (2273, 1, 18);
INSERT INTO `t_role_menu` VALUES (2274, 1, 205);
INSERT INTO `t_role_menu` VALUES (2275, 1, 206);
INSERT INTO `t_role_menu` VALUES (2276, 1, 208);
INSERT INTO `t_role_menu` VALUES (2277, 1, 210);
INSERT INTO `t_role_menu` VALUES (2278, 1, 19);
INSERT INTO `t_role_menu` VALUES (2279, 1, 20);
INSERT INTO `t_role_menu` VALUES (2280, 1, 5);
INSERT INTO `t_role_menu` VALUES (2281, 3, 1);
INSERT INTO `t_role_menu` VALUES (2282, 3, 2);
INSERT INTO `t_role_menu` VALUES (2283, 3, 6);
INSERT INTO `t_role_menu` VALUES (2284, 3, 7);
INSERT INTO `t_role_menu` VALUES (2285, 3, 8);
INSERT INTO `t_role_menu` VALUES (2286, 3, 9);
INSERT INTO `t_role_menu` VALUES (2287, 3, 10);
INSERT INTO `t_role_menu` VALUES (2288, 3, 3);
INSERT INTO `t_role_menu` VALUES (2289, 3, 11);
INSERT INTO `t_role_menu` VALUES (2290, 3, 12);
INSERT INTO `t_role_menu` VALUES (2291, 3, 202);
INSERT INTO `t_role_menu` VALUES (2292, 3, 13);
INSERT INTO `t_role_menu` VALUES (2293, 3, 201);
INSERT INTO `t_role_menu` VALUES (2294, 3, 213);
INSERT INTO `t_role_menu` VALUES (2295, 3, 14);
INSERT INTO `t_role_menu` VALUES (2296, 3, 15);
INSERT INTO `t_role_menu` VALUES (2297, 3, 16);
INSERT INTO `t_role_menu` VALUES (2298, 3, 4);
INSERT INTO `t_role_menu` VALUES (2299, 3, 214);
INSERT INTO `t_role_menu` VALUES (2300, 3, 209);
INSERT INTO `t_role_menu` VALUES (2301, 3, 17);
INSERT INTO `t_role_menu` VALUES (2302, 3, 18);
INSERT INTO `t_role_menu` VALUES (2303, 3, 205);
INSERT INTO `t_role_menu` VALUES (2304, 3, 206);
INSERT INTO `t_role_menu` VALUES (2305, 3, 208);
INSERT INTO `t_role_menu` VALUES (2306, 3, 210);
INSERT INTO `t_role_menu` VALUES (2307, 3, 19);
INSERT INTO `t_role_menu` VALUES (2308, 3, 20);
INSERT INTO `t_role_menu` VALUES (2309, 3, 5);

-- ----------------------------
-- Table structure for t_role_resource
-- ----------------------------
DROP TABLE IF EXISTS `t_role_resource`;
CREATE TABLE `t_role_resource`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  `resource_id` int NULL DEFAULT NULL COMMENT '权限id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4193 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_role_resource
-- ----------------------------
INSERT INTO `t_role_resource` VALUES (4011, 2, 254);
INSERT INTO `t_role_resource` VALUES (4012, 2, 267);
INSERT INTO `t_role_resource` VALUES (4013, 2, 269);
INSERT INTO `t_role_resource` VALUES (4014, 2, 270);
INSERT INTO `t_role_resource` VALUES (4015, 2, 257);
INSERT INTO `t_role_resource` VALUES (4016, 2, 258);
INSERT INTO `t_role_resource` VALUES (4076, 1, 165);
INSERT INTO `t_role_resource` VALUES (4077, 1, 192);
INSERT INTO `t_role_resource` VALUES (4078, 1, 193);
INSERT INTO `t_role_resource` VALUES (4079, 1, 194);
INSERT INTO `t_role_resource` VALUES (4080, 1, 195);
INSERT INTO `t_role_resource` VALUES (4081, 1, 166);
INSERT INTO `t_role_resource` VALUES (4082, 1, 183);
INSERT INTO `t_role_resource` VALUES (4083, 1, 184);
INSERT INTO `t_role_resource` VALUES (4084, 1, 246);
INSERT INTO `t_role_resource` VALUES (4085, 1, 247);
INSERT INTO `t_role_resource` VALUES (4086, 1, 167);
INSERT INTO `t_role_resource` VALUES (4087, 1, 199);
INSERT INTO `t_role_resource` VALUES (4088, 1, 200);
INSERT INTO `t_role_resource` VALUES (4089, 1, 201);
INSERT INTO `t_role_resource` VALUES (4090, 1, 168);
INSERT INTO `t_role_resource` VALUES (4091, 1, 185);
INSERT INTO `t_role_resource` VALUES (4092, 1, 186);
INSERT INTO `t_role_resource` VALUES (4093, 1, 187);
INSERT INTO `t_role_resource` VALUES (4094, 1, 188);
INSERT INTO `t_role_resource` VALUES (4095, 1, 189);
INSERT INTO `t_role_resource` VALUES (4096, 1, 190);
INSERT INTO `t_role_resource` VALUES (4097, 1, 191);
INSERT INTO `t_role_resource` VALUES (4098, 1, 254);
INSERT INTO `t_role_resource` VALUES (4099, 1, 169);
INSERT INTO `t_role_resource` VALUES (4100, 1, 208);
INSERT INTO `t_role_resource` VALUES (4101, 1, 209);
INSERT INTO `t_role_resource` VALUES (4102, 1, 170);
INSERT INTO `t_role_resource` VALUES (4103, 1, 234);
INSERT INTO `t_role_resource` VALUES (4104, 1, 235);
INSERT INTO `t_role_resource` VALUES (4105, 1, 236);
INSERT INTO `t_role_resource` VALUES (4106, 1, 237);
INSERT INTO `t_role_resource` VALUES (4107, 1, 171);
INSERT INTO `t_role_resource` VALUES (4108, 1, 213);
INSERT INTO `t_role_resource` VALUES (4109, 1, 214);
INSERT INTO `t_role_resource` VALUES (4110, 1, 215);
INSERT INTO `t_role_resource` VALUES (4111, 1, 216);
INSERT INTO `t_role_resource` VALUES (4112, 1, 217);
INSERT INTO `t_role_resource` VALUES (4113, 1, 224);
INSERT INTO `t_role_resource` VALUES (4114, 1, 172);
INSERT INTO `t_role_resource` VALUES (4115, 1, 240);
INSERT INTO `t_role_resource` VALUES (4116, 1, 241);
INSERT INTO `t_role_resource` VALUES (4117, 1, 244);
INSERT INTO `t_role_resource` VALUES (4118, 1, 245);
INSERT INTO `t_role_resource` VALUES (4119, 1, 267);
INSERT INTO `t_role_resource` VALUES (4120, 1, 269);
INSERT INTO `t_role_resource` VALUES (4121, 1, 270);
INSERT INTO `t_role_resource` VALUES (4122, 1, 173);
INSERT INTO `t_role_resource` VALUES (4123, 1, 239);
INSERT INTO `t_role_resource` VALUES (4124, 1, 242);
INSERT INTO `t_role_resource` VALUES (4125, 1, 276);
INSERT INTO `t_role_resource` VALUES (4126, 1, 174);
INSERT INTO `t_role_resource` VALUES (4127, 1, 205);
INSERT INTO `t_role_resource` VALUES (4128, 1, 206);
INSERT INTO `t_role_resource` VALUES (4129, 1, 207);
INSERT INTO `t_role_resource` VALUES (4130, 1, 175);
INSERT INTO `t_role_resource` VALUES (4131, 1, 218);
INSERT INTO `t_role_resource` VALUES (4132, 1, 219);
INSERT INTO `t_role_resource` VALUES (4133, 1, 220);
INSERT INTO `t_role_resource` VALUES (4134, 1, 221);
INSERT INTO `t_role_resource` VALUES (4135, 1, 222);
INSERT INTO `t_role_resource` VALUES (4136, 1, 223);
INSERT INTO `t_role_resource` VALUES (4137, 1, 176);
INSERT INTO `t_role_resource` VALUES (4138, 1, 202);
INSERT INTO `t_role_resource` VALUES (4139, 1, 203);
INSERT INTO `t_role_resource` VALUES (4140, 1, 204);
INSERT INTO `t_role_resource` VALUES (4141, 1, 230);
INSERT INTO `t_role_resource` VALUES (4142, 1, 238);
INSERT INTO `t_role_resource` VALUES (4143, 1, 177);
INSERT INTO `t_role_resource` VALUES (4144, 1, 229);
INSERT INTO `t_role_resource` VALUES (4145, 1, 232);
INSERT INTO `t_role_resource` VALUES (4146, 1, 233);
INSERT INTO `t_role_resource` VALUES (4147, 1, 243);
INSERT INTO `t_role_resource` VALUES (4148, 1, 178);
INSERT INTO `t_role_resource` VALUES (4149, 1, 196);
INSERT INTO `t_role_resource` VALUES (4150, 1, 197);
INSERT INTO `t_role_resource` VALUES (4151, 1, 198);
INSERT INTO `t_role_resource` VALUES (4152, 1, 257);
INSERT INTO `t_role_resource` VALUES (4153, 1, 258);
INSERT INTO `t_role_resource` VALUES (4154, 1, 179);
INSERT INTO `t_role_resource` VALUES (4155, 1, 225);
INSERT INTO `t_role_resource` VALUES (4156, 1, 226);
INSERT INTO `t_role_resource` VALUES (4157, 1, 227);
INSERT INTO `t_role_resource` VALUES (4158, 1, 228);
INSERT INTO `t_role_resource` VALUES (4159, 1, 231);
INSERT INTO `t_role_resource` VALUES (4160, 1, 180);
INSERT INTO `t_role_resource` VALUES (4161, 1, 210);
INSERT INTO `t_role_resource` VALUES (4162, 1, 211);
INSERT INTO `t_role_resource` VALUES (4163, 1, 212);
INSERT INTO `t_role_resource` VALUES (4164, 3, 192);
INSERT INTO `t_role_resource` VALUES (4165, 3, 195);
INSERT INTO `t_role_resource` VALUES (4166, 3, 183);
INSERT INTO `t_role_resource` VALUES (4167, 3, 246);
INSERT INTO `t_role_resource` VALUES (4168, 3, 199);
INSERT INTO `t_role_resource` VALUES (4169, 3, 185);
INSERT INTO `t_role_resource` VALUES (4170, 3, 191);
INSERT INTO `t_role_resource` VALUES (4171, 3, 254);
INSERT INTO `t_role_resource` VALUES (4172, 3, 208);
INSERT INTO `t_role_resource` VALUES (4173, 3, 234);
INSERT INTO `t_role_resource` VALUES (4174, 3, 237);
INSERT INTO `t_role_resource` VALUES (4175, 3, 213);
INSERT INTO `t_role_resource` VALUES (4176, 3, 241);
INSERT INTO `t_role_resource` VALUES (4177, 3, 239);
INSERT INTO `t_role_resource` VALUES (4178, 3, 276);
INSERT INTO `t_role_resource` VALUES (4179, 3, 205);
INSERT INTO `t_role_resource` VALUES (4180, 3, 218);
INSERT INTO `t_role_resource` VALUES (4181, 3, 223);
INSERT INTO `t_role_resource` VALUES (4182, 3, 202);
INSERT INTO `t_role_resource` VALUES (4183, 3, 230);
INSERT INTO `t_role_resource` VALUES (4184, 3, 238);
INSERT INTO `t_role_resource` VALUES (4185, 3, 232);
INSERT INTO `t_role_resource` VALUES (4186, 3, 243);
INSERT INTO `t_role_resource` VALUES (4187, 3, 196);
INSERT INTO `t_role_resource` VALUES (4188, 3, 257);
INSERT INTO `t_role_resource` VALUES (4189, 3, 258);
INSERT INTO `t_role_resource` VALUES (4190, 3, 225);
INSERT INTO `t_role_resource` VALUES (4191, 3, 231);
INSERT INTO `t_role_resource` VALUES (4192, 3, 210);

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标签名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 62 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (28, 'Spring', '2022-02-06 16:39:40', NULL);
INSERT INTO `t_tag` VALUES (29, 'Spring Mvc', '2022-02-06 16:39:50', NULL);
INSERT INTO `t_tag` VALUES (30, 'Vue', '2022-02-06 16:39:55', NULL);
INSERT INTO `t_tag` VALUES (31, 'Docker', '2022-02-06 16:39:59', NULL);
INSERT INTO `t_tag` VALUES (32, 'thymeleaf', '2022-02-06 16:40:16', NULL);
INSERT INTO `t_tag` VALUES (33, 'aliyun', '2022-02-06 16:40:26', NULL);
INSERT INTO `t_tag` VALUES (34, 'big data', '2022-02-06 16:40:52', NULL);
INSERT INTO `t_tag` VALUES (35, 'C++', '2022-02-06 16:41:31', NULL);
INSERT INTO `t_tag` VALUES (36, 'Python', '2022-02-06 16:41:41', NULL);
INSERT INTO `t_tag` VALUES (37, 'JavaScript', '2022-02-06 16:41:48', NULL);
INSERT INTO `t_tag` VALUES (38, 'Jquery', '2022-02-06 16:41:54', NULL);
INSERT INTO `t_tag` VALUES (39, 'SpringCloud', '2022-02-06 16:42:02', NULL);
INSERT INTO `t_tag` VALUES (40, 'linux', '2022-02-06 16:42:43', NULL);
INSERT INTO `t_tag` VALUES (41, 'vuetify', '2022-02-06 16:43:01', NULL);
INSERT INTO `t_tag` VALUES (42, 'mybatis', '2022-02-06 16:43:08', NULL);
INSERT INTO `t_tag` VALUES (43, 'mybatis plus', '2022-02-06 16:43:15', NULL);
INSERT INTO `t_tag` VALUES (44, 'Html+Css', '2022-02-06 16:43:33', NULL);
INSERT INTO `t_tag` VALUES (45, 'Go', '2022-02-06 16:43:42', NULL);
INSERT INTO `t_tag` VALUES (58, '面试', '2022-02-07 16:09:54', NULL);
INSERT INTO `t_tag` VALUES (59, 'nginx', '2022-02-26 16:19:22', NULL);
INSERT INTO `t_tag` VALUES (60, 'SpringBoot', '2022-03-03 01:28:15', NULL);
INSERT INTO `t_tag` VALUES (61, 'daily', '2022-03-06 17:20:04', NULL);

-- ----------------------------
-- Table structure for t_unique_view
-- ----------------------------
DROP TABLE IF EXISTS `t_unique_view`;
CREATE TABLE `t_unique_view`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `create_time` datetime NOT NULL COMMENT '时间',
  `views_count` int NOT NULL COMMENT '访问量',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 77 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_unique_view
-- ----------------------------
INSERT INTO `t_unique_view` VALUES (1, '2021-12-29 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (2, '2021-12-30 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (3, '2021-12-31 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (4, '2022-01-01 00:00:00', 3);
INSERT INTO `t_unique_view` VALUES (5, '2022-01-02 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (6, '2022-01-03 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (7, '2022-01-08 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (8, '2022-01-10 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (9, '2022-01-11 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (10, '2022-01-11 23:59:58', 2);
INSERT INTO `t_unique_view` VALUES (11, '2022-01-14 22:06:42', 0);
INSERT INTO `t_unique_view` VALUES (12, '2022-01-16 17:56:22', 0);
INSERT INTO `t_unique_view` VALUES (13, '2022-01-17 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (14, '2022-01-18 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (15, '2022-01-19 23:59:58', 0);
INSERT INTO `t_unique_view` VALUES (16, '2022-01-24 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (17, '2022-01-25 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (18, '2022-01-31 12:03:14', 1);
INSERT INTO `t_unique_view` VALUES (19, '2022-02-01 16:03:18', 2);
INSERT INTO `t_unique_view` VALUES (20, '2022-02-02 22:54:39', 1);
INSERT INTO `t_unique_view` VALUES (21, '2022-02-03 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (22, '2022-02-04 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (23, '2022-02-05 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (24, '2022-02-06 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (25, '2022-02-07 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (26, '2022-02-08 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (27, '2022-02-09 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (28, '2022-02-10 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (29, '2022-02-11 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (30, '2022-02-12 15:00:35', 2);
INSERT INTO `t_unique_view` VALUES (31, '2022-02-13 11:29:03', 1);
INSERT INTO `t_unique_view` VALUES (32, '2022-02-13 23:59:58', 1);
INSERT INTO `t_unique_view` VALUES (33, '2022-02-15 00:00:00', 0);
INSERT INTO `t_unique_view` VALUES (34, '2022-02-16 15:25:48', 0);
INSERT INTO `t_unique_view` VALUES (35, '2022-02-17 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (36, '2022-02-18 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (37, '2022-02-19 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (38, '2022-02-20 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (39, '2022-02-22 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (40, '2022-02-23 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (41, '2022-02-24 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (42, '2022-02-25 00:00:00', 6);
INSERT INTO `t_unique_view` VALUES (43, '2022-02-26 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (44, '2022-02-27 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (45, '2022-02-28 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (46, '2022-03-01 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (47, '2022-03-02 00:00:00', 7);
INSERT INTO `t_unique_view` VALUES (48, '2022-03-03 00:00:00', 7);
INSERT INTO `t_unique_view` VALUES (49, '2022-03-04 00:00:00', 3);
INSERT INTO `t_unique_view` VALUES (50, '2022-03-05 00:00:00', 10);
INSERT INTO `t_unique_view` VALUES (51, '2022-03-06 00:00:00', 7);
INSERT INTO `t_unique_view` VALUES (52, '2022-03-07 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (53, '2022-03-08 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (54, '2022-03-09 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (55, '2022-03-10 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (56, '2022-03-11 00:00:00', 3);
INSERT INTO `t_unique_view` VALUES (57, '2022-03-12 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (58, '2022-03-13 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (59, '2022-03-14 00:00:00', 4);
INSERT INTO `t_unique_view` VALUES (60, '2022-03-15 00:00:00', 70);
INSERT INTO `t_unique_view` VALUES (61, '2022-03-16 00:00:00', 18);
INSERT INTO `t_unique_view` VALUES (62, '2022-03-17 00:00:00', 4);
INSERT INTO `t_unique_view` VALUES (63, '2022-03-18 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (64, '2022-03-19 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (65, '2022-03-20 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (66, '2022-03-21 00:00:00', 6);
INSERT INTO `t_unique_view` VALUES (67, '2022-03-22 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (68, '2022-03-23 00:00:00', 17);
INSERT INTO `t_unique_view` VALUES (69, '2022-03-24 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (70, '2022-03-25 00:00:00', 8);
INSERT INTO `t_unique_view` VALUES (71, '2022-03-26 00:00:00', 1);
INSERT INTO `t_unique_view` VALUES (72, '2022-03-27 00:00:00', 6);
INSERT INTO `t_unique_view` VALUES (73, '2022-03-28 00:00:00', 2);
INSERT INTO `t_unique_view` VALUES (74, '2022-03-29 00:00:00', 7);
INSERT INTO `t_unique_view` VALUES (75, '2022-03-30 00:00:00', 5);
INSERT INTO `t_unique_view` VALUES (76, '2022-03-31 00:00:00', 6);

-- ----------------------------
-- Table structure for t_user_auth
-- ----------------------------
DROP TABLE IF EXISTS `t_user_auth`;
CREATE TABLE `t_user_auth`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_info_id` int NOT NULL COMMENT '用户信息id',
  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户名',
  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '密码',
  `login_type` tinyint(1) NOT NULL COMMENT '登录类型',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户登录ip',
  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `last_login_time` datetime NULL DEFAULT NULL COMMENT '上次登录时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_auth
-- ----------------------------
INSERT INTO `t_user_auth` VALUES (1, 1, 'admin', '$2a$10$c7vv1iHEw.2q2FVBZ9YYJ.MRtayoQeNcLUTjXNzuYifXFzVHkHapy', 1, '116.199.36.224', '广东省广州市 联通', '2021-08-12 15:43:18', '2022-04-01 03:33:31', '2022-04-01 03:33:31');
INSERT INTO `t_user_auth` VALUES (2, 2, '18970465384@163.com', '$2a$10$aGcpH1710aa/6b6c2ah70eyJKp8ok74UkG8rmlYgUP4S6fyVeh4Tq', 1, '59.55.171.152', '江西省吉安市 电信', '2022-02-13 16:38:54', '2022-03-06 01:49:16', '2022-03-06 01:49:16');
INSERT INTO `t_user_auth` VALUES (3, 3, 'C7F398D7A35111FCDABC9BECEC09E32A', '358C665C184007A427CA6F87E8CB52DD', 2, '59.55.171.163', '江西省吉安市 电信', '2022-02-28 16:18:46', NULL, '2022-02-28 16:18:46');

-- ----------------------------
-- Table structure for t_user_info
-- ----------------------------
DROP TABLE IF EXISTS `t_user_info`;
CREATE TABLE `t_user_info`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱号',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '用户头像',
  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户简介',
  `web_site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '个人网站',
  `is_disable` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否禁用',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_info
-- ----------------------------
INSERT INTO `t_user_info` VALUES (1, 'admin@qq.com', 'DarkChen', 'https://static.jishudaniu.com/avatar/59d30ad4e3895aac2bf43ac9f4f1d848.gif', '随便写写', 'www.jishudaniu.com', 0, '2021-08-12 15:43:17', '2022-02-26 15:58:39');
INSERT INTO `t_user_info` VALUES (2, '18970465384@163.com', '用户1492780303010516993', 'https://static.jishudaniu.com/avatar/9f3d55d92b72395244fb3142e2db3720.jpg', NULL, '', 0, '2022-02-13 16:38:53', '2022-02-13 16:40:02');
INSERT INTO `t_user_info` VALUES (3, NULL, 'Dark Chen', 'http://thirdqq.qlogo.cn/g?b=oidb&k=ia4hLzFsWTUIUQzWvpNtiaPw&s=40&t=1629015718', NULL, NULL, 0, '2022-02-28 16:18:46', NULL);

-- ----------------------------
-- Table structure for t_user_role
-- ----------------------------
DROP TABLE IF EXISTS `t_user_role`;
CREATE TABLE `t_user_role`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NULL DEFAULT NULL COMMENT '用户id',
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 580 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_role
-- ----------------------------
INSERT INTO `t_user_role` VALUES (577, 1, 1);
INSERT INTO `t_user_role` VALUES (578, 2, 2);
INSERT INTO `t_user_role` VALUES (579, 3, 2);

-- ----------------------------
-- Table structure for t_website_config
-- ----------------------------
DROP TABLE IF EXISTS `t_website_config`;
CREATE TABLE `t_website_config`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `config` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '配置信息',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_website_config
-- ----------------------------
INSERT INTO `t_website_config` VALUES (1, '{\"alipayQRCode\":\"https://static.jishudaniu.com/config/a8a1c0b3b104d7a3efada67a1e018f05.png\",\"gitee\":\"https://gitee.com/ShitError\",\"github\":\"https://github.com/ShitError\",\"isChatRoom\":0,\"isCommentReview\":0,\"isEmailNotice\":1,\"isMessageReview\":0,\"isMusicPlayer\":0,\"isReward\":1,\"qq\":\"1938976625\",\"socialLoginList\":[\"qq\"],\"socialUrlList\":[\"qq\",\"github\",\"gitee\"],\"touristAvatar\":\"https://static.jishudaniu.com/config/26f83c764cbe7b29e0178192cd0d35b9.jpg\",\"userAvatar\":\"https://static.jishudaniu.com/config/ad7a39d6afe97ec03d31e6eff69f5a87.jpg\",\"websiteAuthor\":\"DarkChen\",\"websiteAvatar\":\"https://static.jishudaniu.com/config/59d30ad4e3895aac2bf43ac9f4f1d848.gif\",\"websiteCreateTime\":\"2021-11-06\",\"websiteIntro\":\"与恶龙缠斗过久,自身亦成为恶龙。凝视深渊过久,深渊将回以凝视。\",\"websiteName\":\"DK-BLOG\",\"websiteNotice\":\"\",\"websiteRecordNo\":\"赣ICP备2021003856号\",\"websocketUrl\":\"ws://127.0.0.1:8080/websocket\",\"weiXinQRCode\":\"https://static.jishudaniu.com/config/7e6d510c2f91f48fbf23147b0de44251.png\"}', '2021-08-09 19:37:30', '2022-03-25 15:40:27');

SET FOREIGN_KEY_CHECKS = 1;
